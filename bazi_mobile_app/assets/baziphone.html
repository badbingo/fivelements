<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="专业八字预测系统，精准排盘，详细分析">
    <meta name="keywords" content="八字,命理,预测,排盘,五行">
    <title>专业八字预测系统</title>
    
    <!-- 字体和图标 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Chart.js 和插件 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    
    
    <!-- 增强版五行计算器（包含土性变化逻辑） -->
    <script>
/**
 * 增强版身强身弱计算模块
 * 包含土性变化逻辑的实现
 * 作者：八字系统
 * 日期：2024
 */

// 土性变化计算逻辑
class EarthTransformationCalculator {
    constructor() {
        // 湿土定义（容易受水影响的土）
        this.wetEarth = ['丑', '辰'];
        
        // 燥土定义（不易受水影响的土）
        this.dryEarth = ['未', '戌'];
        
        // 水元素（天干地支）
        this.waterStems = ['壬', '癸'];
        this.waterBranches = ['子', '亥'];
        
        // 三合局定义
        this.tripleCombinations = {
            '申子辰': { element: 'water', branches: ['申', '子', '辰'] },
            '亥卯未': { element: 'wood', branches: ['亥', '卯', '未'] },
            '寅午戌': { element: 'fire', branches: ['寅', '午', '戌'] },
            '巳酉丑': { element: 'metal', branches: ['巳', '酉', '丑'] }
        };
    }
    
    /**
     * 分析三合局对土的影响
     * @param {Array} branches - 地支数组
     * @returns {Object} 三合局分析结果
     */
    analyzeTripleCombinations(branches) {
        const result = {
            hasTriple: false,
            tripleInfo: null,
            earthImpact: {
                affected: false,
                reduction: 0,
                reason: ''
            }
        };
        
        // 检查巳酉丑三合金局
        const siYouChou = ['巳', '酉', '丑'];
        const foundBranches = siYouChou.filter(branch => branches.includes(branch));
        
        if (foundBranches.length >= 2) {
            result.hasTriple = true;
            result.tripleInfo = {
                type: '巳酉丑',
                element: 'metal',
                count: foundBranches.length,
                branches: foundBranches,
                isComplete: foundBranches.length === 3
            };
            
            // 如果丑土参与合金局
            if (foundBranches.includes('丑')) {
                result.earthImpact.affected = true;
                result.earthImpact.reduction = foundBranches.length === 3 ? 0.7 : 0.5; // 全三合减弱更多
                result.earthImpact.reason = `丑土参与${foundBranches.length === 3 ? '全' : '半'}三合金局，土气被金泄，力量减弱${(result.earthImpact.reduction * 100).toFixed(0)}%`;
            }
        }
        
        return result;
    }
    
    /**
     * 分析湿土遇水变性
     * @param {Array} stems - 天干数组
     * @param {Array} branches - 地支数组
     * @returns {Object} 土性变化分析结果
     */
    analyzeEarthTransformation(stems, branches) {
        const transformations = [];
        const elementAdjustments = {
            wood: 0, fire: 0, earth: 0, metal: 0, water: 0
        };
        
        branches.forEach((branch, index) => {
            if (this.wetEarth.includes(branch)) {
                const transformation = this.checkWetEarthTransformation(stems, branches, index);
                if (transformation.hasTransformation) {
                    transformations.push(transformation);
                    // 应用变化到五行调整
                    elementAdjustments.earth -= transformation.reductionRate;
                    elementAdjustments.water += transformation.waterIncrease;
                }
            }
        });
        
        return {
            hasTransformation: transformations.length > 0,
            hasAnyTransformation: transformations.length > 0,
            transformations: transformations,
            elementAdjustments: elementAdjustments,
            totalEarthReduction: transformations.reduce((sum, t) => sum + t.reductionRate, 0),
            totalWaterIncrease: transformations.reduce((sum, t) => sum + t.waterIncrease, 0)
        };
    }
    
    /**
     * 检查单个湿土的变性情况
     * @param {Array} stems - 天干数组
     * @param {Array} branches - 地支数组
     * @param {number} position - 湿土在地支中的位置
     * @returns {Object} 变性分析结果
     */
    checkWetEarthTransformation(stems, branches, position) {
        const branch = branches[position];
        const stem = stems[position];
        
        const result = {
            branch: branch,
            position: position,
            hasTransformation: false,
            originalElement: 'earth',
            newElement: null,
            transformationType: null,
            waterSources: [],
            reductionRate: 0,
            waterIncrease: 0,
            reason: ''
        };
        
        let waterInfluence = 0;
        const waterSources = [];
        
        // 1. 检查本柱天干是否为水
        if (this.waterStems.includes(stem)) {
            waterInfluence += 0.8; // 本柱天干水影响最大
            waterSources.push(`本柱天干${stem}`);
        }
        
        // 2. 检查相邻地支是否为水
        if (position > 0 && this.waterBranches.includes(branches[position - 1])) {
            waterInfluence += 0.6;
            waterSources.push(`左邻地支${branches[position - 1]}`);
        }
        if (position < branches.length - 1 && this.waterBranches.includes(branches[position + 1])) {
            waterInfluence += 0.6;
            waterSources.push(`右邻地支${branches[position + 1]}`);
        }
        
        // 3. 检查其他天干水的影响
        stems.forEach((s, i) => {
            if (i !== position && this.waterStems.includes(s)) {
                waterInfluence += 0.4;
                const positionName = ['年', '月', '日', '时'][i];
                waterSources.push(`${positionName}干${s}`);
            }
        });
        
        // 4. 检查其他地支水的影响
        branches.forEach((b, i) => {
            if (i !== position && Math.abs(i - position) > 1 && this.waterBranches.includes(b)) {
                waterInfluence += 0.3;
                const positionName = ['年', '月', '日', '时'][i];
                waterSources.push(`${positionName}支${b}`);
            }
        });
        
        // 5. 判断是否发生变性
        if (waterInfluence >= 0.5) { // 水影响达到阈值
            result.hasTransformation = true;
            result.waterSources = waterSources;
            
            // 计算土力减弱和水力增强的程度
            if (waterInfluence >= 1.5) {
                result.reductionRate = 0.7; // 土力减弱70%
                result.waterIncrease = 0.5; // 增加50%水力
                result.newElement = 'water';
                result.transformationType = 'strong';
                result.reason = `${branch}土受强水影响，土性大幅减弱，偏向水性`;
            } else if (waterInfluence >= 1.0) {
                result.reductionRate = 0.5; // 土力减弱50%
                result.waterIncrease = 0.3; // 增加30%水力
                result.newElement = 'water';
                result.transformationType = 'medium';
                result.reason = `${branch}土受中等水影响，土性减弱，略偏水性`;
            } else {
                result.reductionRate = 0.3; // 土力减弱30%
                result.waterIncrease = 0.2; // 增加20%水力
                result.newElement = null;
                result.transformationType = 'weakened';
                result.reason = `${branch}土受轻微水影响，土性略有减弱`;
            }
        }
        
        return result;
    }
    
    /**
     * 增强版五行力量计算
     * @param {Array} stems - 天干数组
     * @param {Array} branches - 地支数组
     * @param {Object} branchElements - 地支藏干映射
     * @returns {Object} 调整后的五行力量分布
     */
    calculateEnhancedElements(stems, branches, branchElements) {
        const elements = { wood: 0, fire: 0, earth: 0, metal: 0, water: 0 };
        
        // 基础映射
        const stemElementMap = {
            '甲': 'wood', '乙': 'wood', '丙': 'fire', '丁': 'fire', '戊': 'earth',
            '己': 'earth', '庚': 'metal', '辛': 'metal', '壬': 'water', '癸': 'water'
        };
        
        const branchElementMap = {
            '子': 'water', '丑': 'earth', '寅': 'wood', '卯': 'wood', '辰': 'earth',
            '巳': 'fire', '午': 'fire', '未': 'earth', '申': 'metal', '酉': 'metal',
            '戌': 'earth', '亥': 'water'
        };
        
        // 1. 分析三合局影响
        const tripleAnalysis = this.analyzeTripleCombinations(branches);
        
        // 2. 分析土性变化
        const earthTransformation = this.analyzeEarthTransformation(stems, branches);
        
        // 3. 计算天干五行（不受土性变化影响）
        stems.forEach(stem => {
            const element = stemElementMap[stem];
            if (element) elements[element] += 1;
        });
        
        // 4. 计算地支主气（考虑土性变化）
        branches.forEach((branch, index) => {
            let element = branchElementMap[branch];
            
            if (element === 'earth') {
                // 检查是否有土性变化
                const transformation = earthTransformation.transformations.find(t => t.position === index);
                if (transformation) {
                    // 土力减弱，水力增强
                    elements[element] += (1 - transformation.reductionRate);
                    elements['water'] += transformation.waterIncrease;
                } else {
                    elements[element] += 1;
                }
            } else {
                elements[element] += 1;
            }
        });
        
        // 5. 计算地支藏干（考虑土性变化）
        branches.forEach((branch, index) => {
            const branchInfo = branchElements[branch];
            if (branchInfo && branchInfo.hidden) {
                branchInfo.hidden.forEach(hiddenStem => {
                    const element = stemElementMap[hiddenStem];
                    if (element) {
                        if (element === 'earth') {
                            const transformation = earthTransformation.transformations.find(t => t.position === index);
                            if (transformation) {
                                // 藏干土力也受影响
                                elements[element] += 0.5 * (1 - transformation.reductionRate * 0.5);
                                elements['water'] += 0.5 * transformation.waterIncrease * 0.5;
                            } else {
                                elements[element] += 0.5;
                            }
                        } else {
                            elements[element] += 0.5;
                        }
                    }
                });
            }
        });
        
        // 6. 应用三合局影响
        if (tripleAnalysis.hasTriple) {
            const tripleInfo = tripleAnalysis.tripleInfo;
            if (tripleInfo.type === '巳酉丑') {
                // 巳酉丑合金局的影响
                const strengthBonus = tripleInfo.isComplete ? 1.0 : 0.6;
                elements['metal'] += strengthBonus; // 增强金力
                elements['water'] += strengthBonus * 0.5; // 金生水
                elements['fire'] = Math.max(0, elements['fire'] - 0.3); // 火被金克
                
                // 如果丑土参与，额外减弱土力
                if (tripleAnalysis.earthImpact.affected) {
                    elements['earth'] = Math.max(0, elements['earth'] - tripleAnalysis.earthImpact.reduction);
                }
            }
        }
        
        // 7. 应用月令占比修复逻辑
        const monthBranch = branches[1]; // 月支
        if (monthBranch) {
            const monthElement = branchElementMap[monthBranch];
            if (monthElement && elements[monthElement] > 0) {
                // 计算总分
                const total = Object.values(elements).reduce((sum, val) => sum + val, 0);
                
                // 计算当前月令占比
                const currentRatio = elements[monthElement] / total;
                
                // 如果月令占比正好是25%，说明可能需要修复
                if (Math.abs(currentRatio - 0.25) < 0.001) {
                    // 应用修复：月令得分 = 基础分 + 月令加成
                    const baseScore = elements[monthElement];
                    const monthBonus = 1.25; // 月令加成25%
                    elements[monthElement] = baseScore + monthBonus;
                    
                    console.log(`月令占比修复应用: ${monthBranch}(${monthElement}) 从 ${baseScore} 调整为 ${elements[monthElement]}`);
                }
            }
        }
        
        return {
            elements: elements,
            tripleAnalysis: tripleAnalysis,
            earthTransformation: earthTransformation,
            adjustments: {
                tripleImpact: tripleAnalysis.hasTriple,
                earthTransformation: earthTransformation.hasTransformation,
                totalEarthReduction: earthTransformation.totalEarthReduction + (tripleAnalysis.earthImpact.affected ? tripleAnalysis.earthImpact.reduction : 0),
                totalWaterIncrease: earthTransformation.totalWaterIncrease
            }
        };
    }
    
    /**
     * 从格判断（考虑土性变化）
     * @param {number} supportRatio - 生扶力量比例
     * @param {Object} analysisResult - 分析结果
     * @returns {Object} 从格判断结果
     */
    analyzeCongGe(supportRatio, analysisResult) {
        const result = {
            isCongGe: false,
            type: '',
            reason: '',
            confidence: 0
        };
        
        // 从弱格判断（生扶力量极少）
        if (supportRatio <= 0.2) {
            result.isCongGe = true;
            result.type = '从弱';
            result.confidence = (0.2 - supportRatio) / 0.2; // 越小置信度越高
            result.reason = `生扶力量仅${(supportRatio * 100).toFixed(1)}%，日主极弱，顺从克泄耗的力量`;
            
            // 如果有土性变化，增加置信度
            if (analysisResult.earthTransformation && analysisResult.earthTransformation.hasTransformation) {
                result.confidence = Math.min(1, result.confidence + 0.2);
                result.reason += '，土性变化进一步减弱日主力量';
            }
        }
        // 从强格判断（生扶力量极多）
        else if (supportRatio >= 0.8) {
            result.isCongGe = true;
            result.type = '从强';
            result.confidence = (supportRatio - 0.8) / 0.2;
            result.reason = `生扶力量达${(supportRatio * 100).toFixed(1)}%，日主极强，顺从生扶的力量`;
        }
        
        return result;
    }
    
    /**
     * 获取土性变化的详细说明
     * @param {Array} transformations - 土性变化数组
     * @returns {string} 变化说明
     */
    getTransformationDescription(transformations) {
        if (transformations.length === 0) {
            return '无土性变化';
        }
        
        const descriptions = transformations.map(t => {
            switch (t.transformationType) {
                case 'strong':
                    return `${t.branch}土受强水影响，土性大幅减弱，偏向水性（土力-${(t.reductionRate * 100).toFixed(0)}%，水力+${(t.waterIncrease * 100).toFixed(0)}%）`;
                case 'medium':
                    return `${t.branch}土受中等水影响，土性减弱，略偏水性（土力-${(t.reductionRate * 100).toFixed(0)}%，水力+${(t.waterIncrease * 100).toFixed(0)}%）`;
                case 'weakened':
                    return `${t.branch}土受轻微水影响，土性略有减弱（土力-${(t.reductionRate * 100).toFixed(0)}%，水力+${(t.waterIncrease * 100).toFixed(0)}%）`;
                default:
                    return `${t.branch}发生未知变化`;
            }
        });
        
        return descriptions.join('；');
    }
}

// 导出模块
if (typeof module !== 'undefined' && module.exports) {
    module.exports = EarthTransformationCalculator;
} else if (typeof window !== 'undefined') {
    window.EarthTransformationCalculator = EarthTransformationCalculator;
}
    </script>
    
    
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --gold-color: #f39c12;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --light-bg: #f8f9fa;
            --dark-bg: #2c3e50;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --border-color: #e9ecef;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15);
            --border-radius: 12px;
            --transition: all 0.3s ease;
            /* Added for unified UI blocks */
            --text-color: #2c3e50;
            --primary-rgb: 44, 62, 80;   /* rgb of #2c3e50 */
            --success-rgb: 39, 174, 96;  /* rgb of #27ae60 */
            --warning-rgb: 243, 156, 18; /* rgb of #f39c12 */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Noto Serif SC', sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            width: 100%;
            margin: 0;
            padding: 20px 0;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        /* Card Styles */
        .card {
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 2px solid #3498db;
            padding: 30px;
            margin: 0 0 30px 0;
            transition: var(--transition);
            width: 100%;
            box-sizing: border-box;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }

        .card-header i {
            font-size: 1.5rem;
            color: var(--secondary-color);
            margin-right: 15px;
        }

        .card-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Form Styles */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }

        .form-group label i {
            margin-right: 8px;
            color: var(--secondary-color);
        }

        .form-group input,
        .form-group select {
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            transition: var(--transition);
            -webkit-appearance: none; /* 修复Safari下拉框样式 */
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;utf8,<svg fill='%232c3e50' height='24' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/><path d='M0 0h24v24H0z' fill='none'/></svg>");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 20px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        /* Form Text Helper */
        .form-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 5px;
            display: block;
        }

        /* Button Styles */
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
        }

        .btn i {
            margin-right: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--secondary-color), #2980b9);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
        }

        .btn-center {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }

        .btn-center .btn {
            width: 60%;
            max-width: 200px;
        }

        /* Bazi Table - 优化版 */
        .bazi-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin: 20px 0;
            font-size: 1.1rem;
            border-radius: 16px;
            overflow: hidden;
            background: linear-gradient(135deg, #ffffff, #f8fafc);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.08),
                0 2px 8px rgba(0, 0, 0, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.8);
        }

        .bazi-table th,
        .bazi-table td {
            padding: 16px 12px;
            text-align: center;
            border: none;
            position: relative;
            vertical-align: middle;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .bazi-table tr:not(:last-child) td,
        .bazi-table tr:not(:last-child) th {
            border-bottom: 1px solid rgba(226, 232, 240, 0.6);
        }
        
        .bazi-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
            font-size: 1rem;
            text-transform: uppercase;
        }

        .bazi-table td {
            background: transparent;
            font-weight: 500;
            color: #374151;
        }
        
        .bazi-table td:first-child {
            font-weight: 700;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.08), rgba(118, 75, 162, 0.08));
            color: #4c1d95;
            border-right: 1px solid rgba(226, 232, 240, 0.8);
        }

        .bazi-table .pillar-header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            font-size: 0.95rem;
        }

        .bazi-table .stem {
            position: relative;
            padding: 12px 0;
            font-weight: 600;
            font-size: 1.15rem;
        }

        .bazi-table .branch {
            position: relative;
            padding: 12px 0;
            font-weight: 600;
            font-size: 1.15rem;
        }
        
        /* 添加柱子之间的分隔线 */
        .bazi-table th:not(:last-child),
        .bazi-table td:not(:last-child) {
            border-right: 1px solid rgba(226, 232, 240, 0.8);
        }
        
        /* 鼠标悬停效果 */
        .bazi-table tbody tr:hover td {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
            transform: translateY(-1px);
        }
        
        /* 移动端适配 */
        @media (max-width: 768px) {
            .bazi-table {
                font-size: 0.95rem;
                margin: 15px 0;
            }
            
            .bazi-table th,
            .bazi-table td {
                padding: 12px 8px;
            }
            
            .bazi-table .stem,
            .bazi-table .branch {
                font-size: 1rem;
                padding: 10px 0;
            }
        }
        
        @media (max-width: 480px) {
            .bazi-table {
                font-size: 0.9rem;
            }
            
            .bazi-table th,
            .bazi-table td {
                padding: 10px 6px;
            }
            
            .bazi-table .stem,
            .bazi-table .branch {
                font-size: 0.95rem;
                padding: 8px 0;
            }
        }
        
        /* 年命纳音、日柱、特殊格局移动端适配 */
        @media (max-width: 768px) {
            .bazi-info-grid {
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 8px !important;
            }
            
            .bazi-info-card {
                padding: 12px !important;
            }
            
            .bazi-info-card div:first-child {
                font-size: 0.75rem !important;
            }
            
            .bazi-info-card div:last-child {
                font-size: 0.9rem !important;
            }
        }
        
        @media (max-width: 480px) {
            .bazi-info-grid {
                gap: 10px !important;
            }
            
            .bazi-info-card {
                padding: 14px !important;
            }
            
            .bazi-info-card div:first-child {
                font-size: 0.8rem !important;
                margin-bottom: 6px !important;
            }
            
            .bazi-info-card div:last-child {
                font-size: 1rem !important;
            }
        }

        /* Chart Container - 优化版 */
        .chart-container,
        .current-chart-container {
            position: relative !important;
            height: 250px !important;
            margin: 35px 0 !important;
            border-radius: 12px !important;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85)) !important;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08) !important;
            padding: 20px !important;
            backdrop-filter: blur(5px) !important;
            overflow: hidden !important;
        }
        
        .chart-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
        }

/* Loading Spinner Styles */
.loading-spinner {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 20px;
}

.spinner-circle {
    width: 20px;
    height: 20px;
    border: 3px solid #f3f3f3;
    border-top: 3px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

        .chart-description {
            margin-top: 25px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
            border-radius: 12px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
            backdrop-filter: blur(5px);
            border-left: 4px solid var(--secondary-color);
        }
        
        .chart-description h4 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
        }
        
        .chart-description h4 i {
            margin-right: 10px;
            color: var(--secondary-color);
        }
        
        .chart-description p {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        
        .chart-description strong {
            color: var(--primary-color);
        }

        /* Analysis Sections - 优化版 */
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin: 40px 0;
        }

        .analysis-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85));
            border-radius: 15px;
            padding: 35px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
            border-left: 4px solid var(--secondary-color);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
            margin: 25px 0;
        }
        
        .analysis-card::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at top right, rgba(52, 152, 219, 0.1), transparent 70%);
            border-radius: 0 0 0 100%;
        }

        .analysis-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }

        .analysis-card h3 {
            color: var(--primary-color);
            margin-bottom: 22px;
            display: flex;
            align-items: center;
            font-size: 1.5em;
            position: relative;
            padding-bottom: 15px;
        }
        
        .analysis-card h3::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, var(--secondary-color), transparent);
            border-radius: 3px;
        }

        .analysis-card h3 i {
            margin-right: 12px;
            color: var(--secondary-color);
            font-size: 1.1em;
        }
        
        .analysis-card p {
            line-height: 1.7;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(3px);
        }

        .loading-overlay .loading {
            width: 60px;
            height: 60px;
            margin-bottom: 20px;
        }

        .loading-overlay p {
            color: white;
            font-size: 18px;
            margin: 0;
            text-align: center;
        }

        /* Beautiful Spinner */
        .beautiful-spinner {
            width: 20px;
            height: 20px;
            position: relative;
            display: inline-block;
        }

        .beautiful-spinner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-top: 2px solid #3498db;
            border-right: 2px solid #e74c3c;
            border-radius: 50%;
            animation: beautiful-spin 1s linear infinite;
        }

        .beautiful-spinner::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: calc(100% - 6px);
            height: calc(100% - 6px);
            border: 2px solid transparent;
            border-top: 2px solid #f39c12;
            border-left: 2px solid #9b59b6;
            border-radius: 50%;
            animation: beautiful-spin 0.8s linear infinite reverse;
        }

        @keyframes beautiful-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Tab System - 优化版 */
        .tab-container {
            margin: 35px 0;
        }

        .tab-nav {
            display: flex;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85));
            border-radius: 12px 12px 0 0;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
            position: relative;
            z-index: 2;
            backdrop-filter: blur(5px);
        }



        /* Analysis Buttons Container - 紧凑布局 */
        .analysis-buttons-container {
            margin-top: 20px;
        }
        
        .analysis-buttons-container .analysis-btn {
            padding: 16px 20px;
            margin: 12px 0;
        }
        
        .analysis-buttons-container .analysis-btn-desc {
            font-size: 13px;
            margin-top: 6px;
        }
        
        .analysis-buttons-container .analysis-btn-title {
            font-size: 15px;
        }
        
        /* Analysis Button - 优化版 */
        .analysis-btn {
            width: 100%;
            padding: 22px 25px;
            margin: 18px 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85));
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .analysis-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, var(--secondary-color), transparent);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .analysis-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            background: linear-gradient(135deg, rgba(255,255,255,1), rgba(255,255,255,0.9));
        }
        
        .analysis-btn:hover::before {
            opacity: 1;
        }
        
        /* 五行主题颜色 - 命理全解（土） */
        .analysis-btn[data-analysis="full-analysis"] {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.15), rgba(255, 193, 7, 0.08));
            border-left: 4px solid #ffc107;
        }
        
        .analysis-btn[data-analysis="full-analysis"]:hover {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.25), rgba(255, 193, 7, 0.15));
        }
        
        .analysis-btn[data-analysis="full-analysis"]::before {
            background: linear-gradient(to bottom, #ffc107, transparent);
        }
        
        /* 流年分析（火） */
        .analysis-btn[data-analysis="annual-fortune"] {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
            border-left: 4px solid #e74c3c;
        }
        
        .analysis-btn[data-analysis="annual-fortune"]:hover {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.25), rgba(231, 76, 60, 0.15));
        }
        
        .analysis-btn[data-analysis="annual-fortune"]::before {
            background: linear-gradient(to bottom, #e74c3c, transparent);
        }
        
        /* 流月分析（水） */
        .analysis-btn[data-analysis="monthly-fortune"] {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
            border-left: 4px solid #3498db;
        }
        
        .analysis-btn[data-analysis="monthly-fortune"]:hover {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.25), rgba(52, 152, 219, 0.15));
        }
        
        .analysis-btn[data-analysis="monthly-fortune"]::before {
            background: linear-gradient(to bottom, #3498db, transparent);
        }
        
        /* 十年大运分析（金） */
        .analysis-btn[data-analysis="decade-fortune"] {
            background: linear-gradient(135deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
            border-left: 4px solid #95a5a6;
        }
        
        .analysis-btn[data-analysis="decade-fortune"]:hover {
            background: linear-gradient(135deg, rgba(149, 165, 166, 0.25), rgba(149, 165, 166, 0.15));
        }
        
        .analysis-btn[data-analysis="decade-fortune"]::before {
            background: linear-gradient(to bottom, #95a5a6, transparent);
        }
        
        /* 性格分析（木） */
        .analysis-btn[data-analysis="personality"] {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
            border-left: 4px solid #27ae60;
        }
        
        .analysis-btn[data-analysis="personality"]:hover {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.25), rgba(39, 174, 96, 0.15));
        }
        
        .analysis-btn[data-analysis="personality"]::before {
            background: linear-gradient(to bottom, #27ae60, transparent);
        }
        
        /* 事业财富（土-深色） */
        .analysis-btn[data-analysis="career-wealth"] {
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.15), rgba(230, 126, 34, 0.08));
            border-left: 4px solid #e67e22;
        }
        
        .analysis-btn[data-analysis="career-wealth"]:hover {
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.25), rgba(230, 126, 34, 0.15));
        }
        
        .analysis-btn[data-analysis="career-wealth"]::before {
            background: linear-gradient(to bottom, #e67e22, transparent);
        }
        
        /* 婚姻分析（火-粉色） */
        .analysis-btn[data-analysis="marriage"] {
            background: linear-gradient(135deg, rgba(233, 30, 99, 0.15), rgba(233, 30, 99, 0.08));
            border-left: 4px solid #e91e63;
        }
        
        .analysis-btn[data-analysis="marriage"]:hover {
            background: linear-gradient(135deg, rgba(233, 30, 99, 0.25), rgba(233, 30, 99, 0.15));
        }
        
        .analysis-btn[data-analysis="marriage"]::before {
            background: linear-gradient(to bottom, #e91e63, transparent);
        }
        
        /* 子女分析（木-浅绿） */
        .analysis-btn[data-analysis="children"] {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.15), rgba(76, 175, 80, 0.08));
            border-left: 4px solid #4caf50;
        }
        
        .analysis-btn[data-analysis="children"]:hover {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.25), rgba(76, 175, 80, 0.15));
        }
        
        .analysis-btn[data-analysis="children"]::before {
            background: linear-gradient(to bottom, #4caf50, transparent);
        }
        
        /* 健康分析（水-青色） */
        .analysis-btn[data-analysis="health"] {
            background: linear-gradient(135deg, rgba(0, 188, 212, 0.15), rgba(0, 188, 212, 0.08));
            border-left: 4px solid #00bcd4;
        }
        
        .analysis-btn[data-analysis="health"]:hover {
            background: linear-gradient(135deg, rgba(0, 188, 212, 0.25), rgba(0, 188, 212, 0.15));
        }
        
        .analysis-btn[data-analysis="health"]::before {
            background: linear-gradient(to bottom, #00bcd4, transparent);
        }

        .analysis-btn.loading {
            pointer-events: none;
            opacity: 0.7;
        }

        .analysis-btn-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .analysis-btn-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .analysis-btn:hover .analysis-btn-title {
            color: var(--secondary-color);
            transform: translateX(5px);
        }

        .analysis-btn-title i {
            margin-right: 12px;
            color: var(--secondary-color);
            transition: all 0.3s ease;
        }
        
        .analysis-btn:hover .analysis-btn-title i {
            transform: scale(1.2);
        }

        .analysis-btn-desc {
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.5;
            transition: all 0.3s ease;
        }
        
        .analysis-btn:hover .analysis-btn-desc {
            color: var(--text-primary);
        }

        .analysis-content {
            margin-top: 25px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
            border-radius: 12px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
            backdrop-filter: blur(5px);
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        /* 展开内容的五行主题背景色 */
        .analysis-content[data-analysis="full-analysis"] {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.12), rgba(255, 193, 7, 0.05));
        }
        
        .analysis-content[data-analysis="annual-fortune"] {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.12), rgba(231, 76, 60, 0.05));
        }
        
        .analysis-content[data-analysis="monthly-fortune"] {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.12), rgba(52, 152, 219, 0.05));
        }
        
        .analysis-content[data-analysis="decade-fortune"] {
            background: linear-gradient(135deg, rgba(149, 165, 166, 0.12), rgba(149, 165, 166, 0.05));
        }
        
        .analysis-content[data-analysis="personality"] {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.12), rgba(39, 174, 96, 0.05));
        }
        
        .analysis-content[data-analysis="career-wealth"] {
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.12), rgba(230, 126, 34, 0.05));
        }
        
        .analysis-content[data-analysis="marriage"] {
            background: linear-gradient(135deg, rgba(233, 30, 99, 0.12), rgba(233, 30, 99, 0.05));
        }
        
        .analysis-content[data-analysis="children"] {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.12), rgba(76, 175, 80, 0.05));
        }
        
        .analysis-content[data-analysis="health"] {
            background: linear-gradient(135deg, rgba(0, 188, 212, 0.12), rgba(0, 188, 212, 0.05));
        }

        .analysis-content.show {
            display: block;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            body {
                overflow-x: auto;
            }
            
            .page-container {
                width: 100%;
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 15px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px 0;
            }

            .header h1 {
                font-size: 2rem;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            .tab-nav {
                flex-direction: column;
            }

            .analysis-grid {
                grid-template-columns: 1fr;
                gap: 20px;
                margin: 25px 0;
            }
            
            /* 移动设备上的表单元素样式调整 */
            .form-group input,
            .form-group select {
                font-size: 16px; /* 防止iOS上自动缩放 */
                padding: 12px 40px 12px 15px; /* 增加右侧padding，为下拉箭头留出空间 */
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }
            
            /* 确保下拉箭头在移动设备上可见 */
            .form-group select {
                background-position: right 15px center;
                background-size: 16px;
            }
            
            /* 调整卡片内边距 */
            .card {
                padding: 20px 15px;
            }
        }
        
        /* 小屏幕设备的额外调整 */
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.8rem;
            }
            
            .card-header h2 {
                font-size: 1.3rem;
            }
            
            .btn {
                width: 100%;
                padding: 12px 20px;
                font-size: 1rem;
            }
            
            /* 确保表单元素在小屏幕上更易于点击 */
            .form-group input,
            .form-group select {
                height: 48px; /* 增加高度使触摸更容易 */
            }
        }

        /* 命格/财富等级移动端优化 */
        @media (max-width: 768px) {
            /* 分析卡片移动端优化 */
            .analysis-card {
                padding: 25px !important;
                margin: 20px 0 !important;
                border-radius: 12px !important;
            }
            
            .analysis-card h3 {
                font-size: 1.3em !important;
                margin-bottom: 18px !important;
                padding-bottom: 12px !important;
            }
            
            /* 分析卡片内容优化 */
            .analysis-card #fate-level-content > div:first-child > div:first-child,
            .analysis-card #wealth-level-content > div:first-child > div:first-child {
                font-size: 2rem !important;
            }
            
            .analysis-card #fate-level-content > div:first-child > div:nth-child(2),
            .analysis-card #wealth-level-content > div:first-child > div:nth-child(2) {
                font-size: 1.1rem !important;
            }
            
            /* 评分构成网格保持双列布局 */
            .analysis-card div[style*="grid-template-columns: repeat(auto-fit, minmax(280px, 1fr))"] {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 8px !important;
            }
            
            .analysis-card div[style*="grid-template-columns: repeat(2, minmax(0, 1fr))"] {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 6px !important;
            }
            
            /* 评分卡片内边距和字体调整 */
            .analysis-card div[style*="border-radius: 8px; padding: 15px"] {
                padding: 10px !important;
            }
            
            .analysis-card div[style*="border-radius: 6px; padding: 12px"] {
                padding: 8px !important;
                font-size: 0.85rem !important;
            }
            
            /* 大分数字体调整 */
            .analysis-card div[style*="font-size: 1.5rem; font-weight: bold"] {
                font-size: 1.2rem !important;
            }
            
            /* 汇总区域弹性布局 */
            .analysis-card div[style*="display: flex; justify-content: space-between; align-items: center"] {
                flex-direction: column !important;
                gap: 8px !important;
                align-items: flex-start !important;
            }
        }
        
        @media (max-width: 480px) {
            /* 超小屏幕进一步缩小 */
            .analysis-card {
                padding: 20px !important;
                margin: 15px 0 !important;
            }
            
            .analysis-card h3 {
                font-size: 1.2em !important;
                margin-bottom: 15px !important;
            }
            
            .analysis-card #fate-level-content > div:first-child > div:first-child,
            .analysis-card #wealth-level-content > div:first-child > div:first-child {
                font-size: 1.5rem !important;
            }
            
            .analysis-card #fate-level-content > div:first-child > div:nth-child(2),
            .analysis-card #wealth-level-content > div:first-child > div:nth-child(2) {
                font-size: 1rem !important;
            }
            
            .analysis-card div[style*="font-size: 1.2rem"] {
                font-size: 1rem !important;
            }
            
            .analysis-card div[style*="padding: 8px"] {
                padding: 6px !important;
                font-size: 0.8rem !important;
            }
        }
        
        /* 十二长生运势分析移动端优化 */
        @media (max-width: 768px) {
            /* 十二长生卡片在移动端保持双列但更紧凑 */
            .analysis-card div[style*="grid-template-columns: repeat(2, 1fr)"] {
                gap: 6px !important;
            }
            
            .analysis-card div[style*="padding: 8px"] {
                padding: 6px !important;
            }
        }
        
        @media (max-width: 480px) {
            /* 超小屏幕十二长生卡片优化 */
            .analysis-card div[style*="grid-template-columns: repeat(2, 1fr)"] {
                gap: 4px !important;
            }
            
            .analysis-card div[style*="padding: 8px"] {
                padding: 4px !important;
                font-size: 0.8rem !important;
            }
        }

        /* Bazi Q&A Styles */
        .bazi-qa-container {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85));
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            backdrop-filter: blur(5px);
        }
        
        .bazi-qa-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .bazi-qa-header h3 {
            color: var(--primary-color);
            font-size: 1.5em;
            margin: 0 0 8px 0;
            font-weight: 600;
        }
        
        .bazi-qa-header h3 i {
            margin-right: 8px;
            color: var(--secondary-color);
        }
        
        .bazi-qa-subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
            margin: 0;
            line-height: 1.5;
        }
        
        .bazi-qa-input-section {
            margin-bottom: 20px;
        }
        
        .bazi-qa-input-wrapper {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }
        
        #bazi-qa-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid rgba(52, 152, 219, 0.2);
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            height: 48px;
            background: rgba(255,255,255,0.9);
            transition: all 0.3s ease;
        }
        
        #bazi-qa-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
            background: rgba(255,255,255,1);
        }
        
        .bazi-qa-submit {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 48px;
        }
        
        .bazi-qa-submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        
        .bazi-qa-submit:active {
            transform: translateY(0);
        }
        
        .bazi-qa-response {
            background: rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid var(--primary-color);
            margin-top: 15px;
            line-height: 1.6;
        }
        
        .bazi-qa-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 20px;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        .qa-answer {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
            border-left: 4px solid #007bff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .qa-answer h4 {
            color: #007bff;
            margin: 0 0 15px 0;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .qa-answer h4 i {
            font-size: 1.2em;
        }
        
        .qa-content {
            line-height: 1.7;
            color: #333;
            font-size: 0.95em;
        }
        
        /* 新增样式：段落标题 */
        .qa-content .qa-section-title {
            color: #2c3e50;
            font-weight: 700;
            font-size: 1.05em;
            margin: 15px 0 8px 0;
            padding: 6px 10px;
            background: linear-gradient(135deg, #f1f3f4 0%, #e8eaf6 100%);
            border-left: 4px solid #3498db;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        /* 第一个标题的上边距调整 */
        .qa-content .qa-section-title:first-child {
            margin-top: 5px;
        }
        
        /* 新增样式：段落内容 */
        .qa-content .qa-paragraph {
            margin: 8px 0;
            padding: 0;
            text-align: justify;
            line-height: 1.6;
            text-indent: 0;
        }
        
        /* 段落内的换行样式 */
        .qa-content .qa-paragraph br {
            line-height: 1.4;
            margin: 2px 0;
        }
        
        /* 新增样式：列表容器 */
        .qa-content .qa-list {
            margin: 12px 0;
            padding-left: 0;
            list-style: none;
            background: rgba(248, 249, 250, 0.6);
            border-radius: 6px;
            padding: 10px;
        }
        
        /* 新增样式：列表项 */
        .qa-content .qa-list-item {
            margin: 6px 0;
            padding: 6px 12px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #17a2b8;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            position: relative;
        }
        
        .qa-content .qa-list-item:before {
            content: "▸";
            color: #17a2b8;
            font-weight: bold;
            position: absolute;
            left: -8px;
            top: 6px;
        }
        
        /* 新增样式：高亮文本 */
        .qa-content .qa-highlight {
            color: #e74c3c;
            font-weight: 600;
            background: rgba(231, 76, 60, 0.1);
            padding: 1px 3px;
            border-radius: 3px;
        }
        
        /* 新增样式：强调文本 */
        .qa-content .qa-emphasis {
            color: #8e44ad;
            font-style: italic;
            background: rgba(142, 68, 173, 0.1);
            padding: 1px 3px;
            border-radius: 3px;
        }
        
        /* 新增样式：关键词 */
        .qa-content .qa-keyword {
            color: #2980b9;
            font-weight: 600;
            background: rgba(41, 128, 185, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            border: 1px solid rgba(41, 128, 185, 0.2);
        }
        
        /* 兼容旧样式 */
        .qa-content h1, .qa-content h2, .qa-content h3 {
            color: #2c3e50;
            margin: 15px 0 10px 0;
            font-weight: 600;
        }
        
        .qa-content h1 {
            font-size: 1.4em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        
        .qa-content h2 {
            font-size: 1.2em;
            color: #34495e;
        }
        
        .qa-content h3 {
            font-size: 1.1em;
            color: #7f8c8d;
        }
        
        .qa-content strong {
            color: #e74c3c;
            font-weight: 600;
        }
        
        .qa-content em {
            color: #8e44ad;
            font-style: italic;
        }
        
        .qa-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .qa-content li {
            margin: 5px 0;
            list-style-type: disc;
        }
        
        .qa-content p {
            margin: 10px 0;
            text-align: justify;
        }
        
        /* 移动设备适配 */
        @media (max-width: 768px) {
            .bazi-qa-input-wrapper {
                flex-direction: column;
                align-items: stretch;
            }
            
            .bazi-qa-submit {
                justify-content: center;
            }
        }

        /* Hidden by default */
        .result-section {
            display: none;
        }

        .result-section.show {
            display: block;
        }
    /* 添加外层容器 */
    .page-container {
        width: 100%;
        max-width: 1200px;
        margin: 0 auto;
        overflow-x: hidden;
    }
    
    /* 内部容器使用100%宽度 */
    .container {
        width: 100%;
        margin: 0;
        padding: 20px 0;
    }
    
    /* Safari特定样式 */
    @media not all and (min-resolution:.001dpcm) { 
        @supports (-webkit-appearance:none) {
            .form-group select {
                background-color: white; /* 确保背景色为白色 */
                text-indent: 1px; /* 修复文本对齐问题 */
                text-overflow: ''; /* 处理文本溢出 */
                padding-right: 30px; /* 为下拉箭头留出空间 */
            }
            
            /* 修复Safari上的触摸事件 */
            .form-group select:hover,
            .form-group select:focus {
                cursor: pointer;
                border-color: var(--secondary-color);
            }
        }
    }

            /* 用户管理区域样式 - 现代化设计 */
            .user-area {
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 15px;
                background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
                padding: 20px 30px;
                border-radius: 25px;
                border: 2px solid rgba(59, 130, 246, 0.1);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(59, 130, 246, 0.1);
                backdrop-filter: blur(20px);
                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                margin: 25px auto;
                max-width: 700px;
                position: relative;
                overflow: hidden;
            }

            .user-area::before {
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.05), transparent);
                transition: left 0.6s ease;
            }

            .user-area:hover::before {
                left: 100%;
            }

            .user-area:hover {
                background: linear-gradient(135deg, rgba(255, 255, 255, 1), rgba(248, 250, 252, 0.98));
                box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12), 0 4px 16px rgba(59, 130, 246, 0.15);
                transform: translateY(-2px);
                border-color: rgba(59, 130, 246, 0.2);
            }

            .user-welcome {
                font-size: 16px;
                color: #1e293b;
                font-weight: 600;
                margin-right: 8px;
                display: flex;
                align-items: center;
                gap: 8px;
                letter-spacing: 0.3px;
            }

            .user-welcome::before {
                content: '👋';
                font-size: 18px;
                animation: wave 2s ease-in-out infinite;
            }

            @keyframes wave {
                0%, 100% { transform: rotate(0deg); }
                25% { transform: rotate(20deg); }
                75% { transform: rotate(-10deg); }
            }

            .user-balance {
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 14px;
                font-weight: 700;
                margin-right: 8px;
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
                display: flex;
                align-items: center;
                gap: 6px;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }

            .user-balance::before {
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
                transition: left 0.5s ease;
            }

            .user-balance:hover::before {
                left: 100%;
            }

            .user-balance:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
            }

            .login-btn, .logout-btn, .recharge-btn {
                background: linear-gradient(135deg, #3b82f6, #2563eb);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 20px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                text-decoration: none;
                display: inline-flex;
                align-items: center;
                gap: 8px;
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
                position: relative;
                overflow: hidden;
                letter-spacing: 0.3px;
            }

            .recharge-btn {
                background: linear-gradient(135deg, #f59e0b, #d97706);
                box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
            }

            .logout-btn {
                background: linear-gradient(135deg, #ef4444, #dc2626);
                box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
            }

            .login-btn::before, .logout-btn::before, .recharge-btn::before {
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
                transition: left 0.5s ease;
            }

            .login-btn:hover::before, .logout-btn:hover::before, .recharge-btn:hover::before {
                left: 100%;
            }

            .login-btn:hover, .logout-btn:hover, .recharge-btn:hover {
                transform: translateY(-2px) scale(1.02);
                box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
            }

            .recharge-btn:hover {
                box-shadow: 0 8px 20px rgba(245, 158, 11, 0.4);
            }

            .logout-btn:hover {
                box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
            }

            .login-btn:active, .logout-btn:active, .recharge-btn:active {
                transform: translateY(0) scale(0.98);
            }

            .user-buttons-container {
                display: flex;
                gap: 10px;
                align-items: center;
            }

            /* 移动端适配 */
            @media (max-width: 768px) {
                .user-area {
                    flex-direction: column;
                    gap: 12px;
                    padding: 20px;
                    margin: 20px 15px;
                }

                .user-welcome {
                    font-size: 15px;
                    margin-right: 0;
                    text-align: center;
                }

                .user-balance {
                    margin-right: 0;
                    font-size: 13px;
                }

                .login-btn, .logout-btn, .recharge-btn {
                    padding: 12px 24px;
                    font-size: 15px;
                    min-width: 120px;
                    justify-content: center;
                }
            }

            @media (max-width: 480px) {
                .user-area {
                    gap: 10px;
                    padding: 18px 15px;
                }

                .user-welcome {
                    font-size: 14px;
                }

                .login-btn, .logout-btn, .recharge-btn {
                    padding: 10px 20px;
                    font-size: 14px;
                    width: 100%;
                    max-width: 200px;
                }
            }



            /* 认证弹窗样式 */
            .auth-modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(5px);
                animation: fadeIn 0.3s ease;
            }

            .auth-container {
                position: relative;
                background: linear-gradient(135deg, rgba(255, 248, 220, 0.95), rgba(255, 255, 255, 0.95));
                margin: 5% auto;
                padding: 0;
                border-radius: 15px;
                width: 90%;
                max-width: 400px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(139, 69, 19, 0.2);
                overflow: hidden;
                animation: slideIn 0.3s ease;
            }

            .auth-header {
                background: linear-gradient(135deg, #8B4513, #A0522D);
                color: white;
                padding: 20px;
                text-align: center;
                border-radius: 15px 15px 0 0;
            }

            .auth-header h2 {
                margin: 0 0 5px 0;
                font-size: 24px;
                font-weight: 600;
            }

            .auth-header p {
                margin: 0;
                opacity: 0.9;
                font-size: 14px;
            }

            .auth-tabs {
                display: flex;
                background: rgba(139, 69, 19, 0.1);
            }

            .auth-tab {
                flex: 1;
                padding: 15px;
                text-align: center;
                cursor: pointer;
                background: rgba(139, 69, 19, 0.1);
                color: #8B4513;
                font-weight: 500;
                transition: all 0.3s ease;
                border-bottom: 3px solid transparent;
            }

            .auth-tab.active {
                background: white;
                color: #8B4513;
                border-bottom: 3px solid #8B4513;
            }

            .auth-tab:hover {
                background: rgba(139, 69, 19, 0.2);
            }

            .auth-form {
                display: none;
                padding: 30px;
            }

            .auth-form.active {
                display: block;
            }

            .auth-form .form-group {
                margin-bottom: 20px;
            }

            .auth-form label {
                display: block;
                margin-bottom: 8px;
                color: #8B4513;
                font-weight: 500;
                font-size: 14px;
            }

            .auth-form input {
                width: 100%;
                padding: 12px 15px;
                border: 2px solid rgba(139, 69, 19, 0.2);
                border-radius: 8px;
                font-size: 14px;
                transition: all 0.3s ease;
                background: rgba(255, 255, 255, 0.8);
                box-sizing: border-box;
            }

            .auth-form input:focus {
                outline: none;
                border-color: #8B4513;
                background: white;
                box-shadow: 0 0 0 3px rgba(139, 69, 19, 0.1);
            }

            .password-container {
                position: relative;
            }

            .password-toggle {
                position: absolute;
                right: 12px;
                top: 50%;
                transform: translateY(-50%);
                cursor: pointer;
                color: #8B4513;
                opacity: 0.6;
                transition: opacity 0.3s ease;
            }

            .password-toggle:hover {
                opacity: 1;
            }

            .auth-btn {
                width: 100%;
                background: linear-gradient(135deg, #8B4513, #A0522D);
                color: white;
                border: none;
                padding: 12px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                margin-top: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            }

            .auth-btn:hover {
                background: linear-gradient(135deg, #A0522D, #CD853F);
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(139, 69, 19, 0.3);
            }

            .forgot-password {
                text-align: center;
                margin-top: 15px;
            }

            .forgot-password a {
                color: #8B4513;
                text-decoration: none;
                font-size: 14px;
                transition: color 0.3s ease;
            }

            .forgot-password a:hover {
                color: #A0522D;
                text-decoration: underline;
            }

            .auth-message {
                margin-top: 15px;
                padding: 10px;
                border-radius: 5px;
                text-align: center;
                font-size: 14px;
                display: none;
            }

            .auth-message.success {
                background: rgba(34, 139, 34, 0.1);
                color: #228B22;
                border: 1px solid rgba(34, 139, 34, 0.3);
            }

            .auth-message.error {
                background: rgba(220, 20, 60, 0.1);
                color: #DC143C;
                border: 1px solid rgba(220, 20, 60, 0.3);
            }

            .close-auth {
                position: absolute;
                top: 15px;
                right: 20px;
                color: white;
                font-size: 28px;
                font-weight: bold;
                cursor: pointer;
                z-index: 1001;
                transition: color 0.3s ease;
            }

            .close-auth:hover {
                color: #FFD700;
            }

            /* 充值弹窗样式 */
            .recharge-modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(5px);
                animation: fadeIn 0.3s ease;
            }

            .recharge-container {
                position: relative;
                background: linear-gradient(135deg, rgba(255, 248, 220, 0.95), rgba(255, 255, 255, 0.95));
                margin: 5% auto;
                padding: 0;
                border-radius: 15px;
                width: 90%;
                max-width: 450px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(34, 139, 34, 0.2);
                overflow: hidden;
                animation: slideIn 0.3s ease;
            }

            .recharge-header {
                background: linear-gradient(135deg, #228B22, #32CD32);
                color: white;
                padding: 20px;
                text-align: center;
                border-radius: 15px 15px 0 0;
            }

            .recharge-header h2 {
                margin: 0 0 5px 0;
                font-size: 24px;
                font-weight: 600;
            }

            .recharge-header p {
                margin: 0;
                opacity: 0.9;
                font-size: 14px;
            }

            .recharge-form {
                padding: 30px;
            }

            .recharge-form .form-group {
                margin-bottom: 20px;
            }

            .recharge-form label {
                display: block;
                margin-bottom: 8px;
                color: #228B22;
                font-weight: 500;
                font-size: 14px;
            }

            .recharge-form input[type="number"] {
                width: 100%;
                padding: 12px 15px;
                border: 2px solid rgba(34, 139, 34, 0.2);
                border-radius: 8px;
                font-size: 14px;
                transition: all 0.3s ease;
                background: rgba(255, 255, 255, 0.8);
                box-sizing: border-box;
            }

            .recharge-form input[type="number"]:focus {
                outline: none;
                border-color: #228B22;
                background: white;
                box-shadow: 0 0 0 3px rgba(34, 139, 34, 0.1);
            }

            .payment-methods {
                display: flex;
                flex-direction: row;
                justify-content: space-between;
                gap: 15px;
            }

            .payment-option {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
                border: 2px solid transparent;
                border-radius: 12px;
                background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                position: relative;
                overflow: hidden;
            }

            .payment-option:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
                border-color: #52c41a;
            }

            .payment-option:has(input:checked) {
                background: linear-gradient(135deg, #52c41a 0%, #73d13d 100%);
                color: white;
                border-color: #52c41a;
                box-shadow: 0 6px 20px rgba(82, 196, 26, 0.3);
            }

            .payment-option:has(input:checked) .payment-tag {
                color: rgba(255, 255, 255, 0.9);
            }

            .payment-option input[type="radio"] {
                display: none;
            }

            .payment-option i {
                font-size: 1.8em;
                margin-bottom: 8px;
            }

            .payment-main {
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  text-align: center;
                  font-size: 2.2em;
                  font-weight: 600;
                  margin-bottom: 6px;
              }

            .payment-tag {
                 font-size: 0.8em;
                 color: #666;
                 font-weight: 400;
                 padding: 2px 8px;
                 background: rgba(0, 0, 0, 0.05);
                 border-radius: 12px;
                 margin-top: 4px;
                 text-align: center;
                 display: block;
                 width: 100%;
             }

             /* 余额支付特殊样式 */
             .payment-option:has(input[value="balance"]) {
                 background: linear-gradient(135deg, #722ed1 0%, #9254de 100%);
                 color: white;
             }

             .payment-option:has(input[value="balance"]:checked) {
                 background: linear-gradient(135deg, #531dab 0%, #722ed1 100%);
                 border-color: #722ed1;
                 box-shadow: 0 6px 20px rgba(114, 46, 209, 0.3);
             }

             .payment-option:has(input[value="balance"]) .payment-tag {
                 color: rgba(255, 255, 255, 0.9);
                 background: rgba(255, 255, 255, 0.2);
             }

             /* 余额不足时的禁用样式 */
             .payment-option:has(input[value="balance"]:disabled) {
                 opacity: 0.5;
                 cursor: not-allowed;
                 background: linear-gradient(135deg, #d9d9d9 0%, #f0f0f0 100%);
                 color: #999;
             }

             .payment-option:has(input[value="balance"]:disabled):hover {
                 transform: none;
                 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
             }

            .recharge-form .recharge-btn {
                width: 100%;
                background: linear-gradient(135deg, #228B22, #32CD32);
                color: white;
                border: none;
                padding: 12px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                margin-top: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            }

            .recharge-form .recharge-btn:hover {
                background: linear-gradient(135deg, #32CD32, #90EE90);
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(34, 139, 34, 0.3);
            }

            .recharge-message {
                margin-top: 15px;
                padding: 10px;
                border-radius: 5px;
                text-align: center;
                font-size: 14px;
                display: none;
            }

            .recharge-message.success {
                background: rgba(34, 139, 34, 0.1);
                color: #228B22;
                border: 1px solid rgba(34, 139, 34, 0.3);
            }

            .recharge-message.error {
                background: rgba(220, 20, 60, 0.1);
                color: #DC143C;
                border: 1px solid rgba(220, 20, 60, 0.3);
            }

            .close-recharge {
                position: absolute;
                top: 15px;
                right: 20px;
                color: white;
                font-size: 28px;
                font-weight: bold;
                cursor: pointer;
                z-index: 1001;
                transition: color 0.3s ease;
            }

            .close-recharge:hover {
                color: #FFD700;
            }

            /* 支付方式选项样式 */
            .payment-methods {
                display: flex;
                gap: 15px;
                margin-top: 15px;
            }

            .payment-option {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 10px;
                cursor: pointer;
                padding: 15px 20px;
                border-radius: 6px;
                transition: all 0.3s ease;
                text-align: center;
                min-width: 150px;
                border: 1px solid gold;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
            }

            .payment-option:hover {
                transform: translateY(-3px);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            }

            .payment-option i {
                font-size: 24px;
                color: #ffffff;
            }

            .payment-option input[type="radio"] {
                margin-right: 5px;
            }

            .payment-tag {
                font-size: 12px;
                background: rgba(255, 255, 255, 0.2);
                padding: 2px 6px;
                border-radius: 4px;
                margin-top: 5px;
            }

            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: translateY(-50px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            /* 新的余额支付弹窗样式 */
            .payment-amount-info {
                margin-bottom: 25px;
                padding: 20px;
                background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                border-radius: 12px;
                border-left: 4px solid #667eea;
            }
            
            .amount-description {
                display: flex;
                align-items: center;
                gap: 12px;
                font-size: 16px;
                color: #495057;
            }
            
            .amount-description i {
                color: #667eea;
                font-size: 18px;
            }
            
            .amount-description strong {
                color: #667eea;
                font-size: 18px;
            }
            
            /* 余额显示区域样式 */
            .balance-section {
                margin-bottom: 25px;
                padding: 25px;
                background: linear-gradient(135deg, #fff5f5 0%, #fed7d7 100%);
                border-radius: 15px;
                border: 2px solid #feb2b2;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .balance-display {
                text-align: center;
                margin-bottom: 20px;
            }
            
            .balance-header {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                margin-bottom: 10px;
                color: #744210;
                font-weight: 600;
            }
            
            .balance-header i {
                color: #d69e2e;
                font-size: 20px;
            }
            
            .balance-amount {
                font-size: 32px;
                font-weight: 700;
                color: #2d3748;
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            
            /* 充值按钮样式 */
            .recharge-balance-btn {
                width: 60%;
                padding: 10px;
                background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
            }
            
            .recharge-balance-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 20px rgba(72, 187, 120, 0.3);
            }
            
            /* 余额不足提示样式 */
            .insufficient-balance {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                padding: 15px;
                background: #fed7d7;
                color: #c53030;
                border-radius: 10px;
                margin-bottom: 20px;
                font-weight: 600;
            }
            
            .insufficient-balance i {
                font-size: 18px;
            }
            
            /* 支付按钮样式 */
            .balance-pay-btn {
                width: 100%;
                padding: 18px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                border-radius: 12px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                margin-top: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }
            
            .balance-pay-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
            }
            
            .balance-pay-btn:active {
                transform: translateY(0);
            }
            
            .balance-pay-btn:disabled {
                background: #cbd5e0;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }

            /* 响应式设计 */
            @media (max-width: 768px) {
                .user-area {
                    position: static;
                    margin-bottom: 15px;
                    justify-content: center;
                    flex-wrap: wrap;
                }

                .auth-container, .recharge-container {
                    width: 95%;
                    margin: 2% auto;
                }

                .payment-methods {
                    display: flex;
                    flex-direction: row;
                    justify-content: space-between;
                    gap: 15px;
                }
                .payment-option {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                    border: 2px solid transparent;
                    border-radius: 12px;
                    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
                    cursor: pointer;
                    transition: all 0.3s ease;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                    position: relative;
                    overflow: hidden;
                }
                .payment-option:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
                    border-color: #52c41a;
                }
                .payment-option:has(input:checked) {
                    background: linear-gradient(135deg, #52c41a 0%, #73d13d 100%);
                    color: white;
                    border-color: #52c41a;
                    box-shadow: 0 6px 20px rgba(82, 196, 26, 0.3);
                }
                .payment-option:has(input:checked) .payment-tag {
                    color: rgba(255, 255, 255, 0.9);
                }
                .payment-option input {
                    display: none;
                }
                .payment-option i {
                    font-size: 1.8em;
                    margin-bottom: 8px;
                }
                .payment-main {
                     display: flex;
                     align-items: center;
                     justify-content: center;
                     text-align: center;
                     font-size: 1.1em;
                     font-weight: 600;
                     margin-bottom: 6px;
                 }
                .payment-tag {
                    font-size: 0.8em;
                    color: #666;
                    font-weight: 400;
                    padding: 2px 8px;
                    background: rgba(0, 0, 0, 0.05);
                    border-radius: 12px;
                    margin-top: 4px;
                }
            }

        /* 响应式设计 - 身强身弱分析对比 */
        @media (max-width: 1024px) {
            .strength-comparison-container {
                flex-direction: column !important;
                gap: 15px !important;
            }
            
            .original-strength-section,
            .current-strength-section {
                min-height: 280px;
            }
            
            .chart-container,
            .current-chart-container {
                height: 180px !important;
            }
        }
        
        @media (max-width: 768px) {
            .card {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            /* 五行力量分布移动端优化 */
            .elements-comparison-container {
                flex-direction: column !important;
                gap: 20px !important;
                min-height: auto !important;
            }
            
            .original-elements-section,
            .current-elements-section {
                flex: none !important;
                padding: 15px !important;
                margin-bottom: 0;
            }
            
            .original-elements-section .chart-container,
            .current-elements-section .current-chart-container {
                height: 220px !important;
            }
            
            .original-elements-section .section-header h3,
            .current-elements-section .section-header h3 {
                font-size: 1rem !important;
            }
            
            /* 身强身弱分析移动端优化 */
            .strength-comparison-container {
                flex-direction: column !important;
                gap: 12px !important;
                min-height: auto !important;
            }
            
            .original-strength-section,
            .current-strength-section {
                flex: none !important;
                padding: 12px;
                min-height: 260px;
            }
            
            .section-header h3 {
                font-size: 1rem !important;
            }
            
            .chart-container,
            .current-chart-container {
                height: 240px !important;
                padding: 12px;
            }
            
            .comparison-note {
                padding: 12px;
            }
            
            .comparison-note p {
                font-size: 0.85rem !important;
            }
            
            /* 五行分布概览768px以下优化 */
            #original-elements-summary div[style*="display: flex"],
            #current-elements-summary div[style*="display: flex"] {
                flex-direction: column !important;
                gap: 6px !important;
            }
            
            #original-elements-summary div[style*="min-width: 100px"],
            #current-elements-summary div[style*="min-width: 100px"] {
                min-width: auto !important;
                margin-bottom: 6px !important;
            }
        }
        
        @media (max-width: 480px) {
            .container {
                padding: 15px 0;
            }
            
            .header h1 {
                font-size: 2rem !important;
            }
            
            .header p {
                font-size: 1rem !important;
            }
            
            .card-header h2 {
                font-size: 1.3rem;
            }
            
            /* 五行力量分布小屏幕优化 */
            .original-elements-section,
            .current-elements-section {
                padding: 12px !important;
            }
            
            .original-elements-section .chart-container,
            .current-elements-section .current-chart-container {
                height: 200px !important;
                padding: 8px;
            }
            
            .original-elements-section .section-header h3,
            .current-elements-section .section-header h3 {
                font-size: 0.95rem !important;
            }
            
            #original-elements-summary,
            #current-elements-summary {
                padding: 10px !important;
                font-size: 0.85rem !important;
            }
            
            /* 身强身弱分析小屏幕优化 */
            .original-strength-section,
            .current-strength-section {
                padding: 18px;
                min-height: 320px;
            }
            
            .chart-container,
            .current-chart-container {
                height: 220px !important;
                padding: 12px;
            }
            
            .chart-description {
                padding: 16px !important;
            }
            
            /* 对比说明小屏幕优化 */
             .comparison-note {
                 padding: 10px !important;
                 margin-top: 12px !important;
             }
             
             .comparison-note p {
                 font-size: 0.8rem !important;
                 line-height: 1.4 !important;
             }
             
             /* 五行分布概览移动端优化 */
             #original-elements-summary div[style*="display: flex"],
             #current-elements-summary div[style*="display: flex"] {
                 flex-direction: column !important;
                 gap: 8px !important;
             }
             
             #original-elements-summary div[style*="min-width: 100px"],
             #current-elements-summary div[style*="min-width: 100px"] {
                 min-width: auto !important;
                 margin-bottom: 8px !important;
             }
         }

        /* Recent Records Styles - 2个并排摆放 */
        .recent-records-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .recent-record-item {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85));
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 2px solid rgba(52, 152, 219, 0.6);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }

        .recent-record-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, var(--secondary-color), var(--accent-color));
            opacity: 0;
            transition: all 0.3s ease;
        }

        .recent-record-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border-color: var(--secondary-color);
        }

        .recent-record-item:hover::before {
            opacity: 1;
        }

        .recent-record-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .recent-record-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
        }

        .recent-record-name i {
            margin-right: 6px;
            color: var(--secondary-color);
            font-size: 0.9rem;
        }

        .recent-record-gender {
            padding: 3px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .recent-record-gender.male {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(52, 152, 219, 0.1));
            color: #2980b9;
        }

        .recent-record-gender.female {
            background: linear-gradient(135deg, rgba(233, 30, 99, 0.2), rgba(233, 30, 99, 0.1));
            color: #c2185b;
        }

        .recent-record-info {
            margin-bottom: 10px;
        }

        .recent-record-datetime {
            font-size: 0.85rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
        }

        .recent-record-datetime i {
            margin-right: 5px;
            color: var(--gold-color);
            font-size: 0.8rem;
        }

        .recent-record-bazi {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(52, 152, 219, 0.05);
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Noto Serif SC', serif;
            font-weight: 500;
        }

        .recent-record-pillar {
            text-align: center;
            flex: 1;
        }

        .recent-record-pillar-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }

        .recent-record-pillar-value {
            font-size: 0.9rem;
            color: var(--primary-color);
            font-weight: 600;
        }

        .recent-record-actions {
            display: flex;
            gap: 6px;
            margin-top: 10px;
        }

        .recent-record-btn {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }

        .recent-record-btn i {
            font-size: 0.75rem;
        }

        .recent-record-btn.primary {
            background: linear-gradient(135deg, var(--secondary-color), #2980b9);
            color: white;
        }

        .recent-record-btn.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .recent-record-btn.danger {
            background: linear-gradient(135deg, var(--accent-color), #c0392b);
            color: white;
        }

        .recent-record-btn.danger:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .no-recent-records {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .no-recent-records i {
            font-size: 3rem;
            color: var(--border-color);
            margin-bottom: 15px;
        }

        .no-recent-records p {
            font-size: 1.1rem;
            margin: 0;
        }

        /* 响应式设计 - 最近记录 */
        @media (max-width: 768px) {
            .recent-records-container {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .recent-record-item {
                padding: 10px;
            }
            
            .recent-record-header {
                margin-bottom: 6px;
            }
            
            .recent-record-info {
                margin-bottom: 8px;
            }
            
            .recent-record-actions {
                margin-top: 8px;
                gap: 5px;
            }
            
            .recent-record-btn {
                padding: 5px 8px;
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <!-- 加载遮罩 -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading beautiful-spinner"></div>
        <p id="loadingMessage">正在处理，请稍候...</p>
    </div>
    
    <!-- 余额支付弹窗 -->
    <div class="recharge-modal" id="rechargeModal">
        <div class="recharge-container">
            <span class="close-recharge" id="closeRecharge">&times;</span>
            <div class="recharge-header">
                <h2><i class="fas fa-star"></i> 详批支付</h2>
                <p>根据您的财富等级评分解锁详细分析</p>
            </div>
            
            <form id="rechargeForm" class="recharge-form">
                <!-- 支付金额说明 -->
                <div class="payment-amount-info">
                    <div class="amount-description">
                        <i class="fas fa-info-circle"></i>
                        <span>依据您的财富等级，请您支付 <strong id="paymentAmount">¥0.10</strong> 元</span>
                    </div>
                </div>
                
                <!-- 余额显示区域 -->
                <div class="balance-section">
                    <div class="balance-display">
                        <div class="balance-header">
                            <i class="fas fa-wallet"></i>
                            <span>当前余额</span>
                        </div>
                        <div class="balance-amount">
                            ¥<span id="userBalanceDisplay">0.00</span>
                        </div>
                    </div>
                    
                    <!-- 充值按钮 -->
                    <button type="button" class="recharge-balance-btn" id="rechargeBalanceBtn">
                        <i class="fas fa-plus"></i>
                        充值余额
                    </button>
                </div>
                
                <!-- 余额不足提示 -->
                <div class="insufficient-balance" id="insufficientBalance" style="display: none;">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>余额不足，请先充值</span>
                </div>
                
                <!-- 支付按钮 -->
                <button type="submit" class="balance-pay-btn" id="balancePayBtn">
                    <i class="fas fa-credit-card"></i>
                    <span id="rechargeText">确认支付</span>
                    <span id="rechargeSpinner" style="display:none;"><i class="fas fa-spinner fa-spin"></i> 处理中...</span>
                </button>
                
                <div id="rechargeMessage" class="recharge-message"></div>
            </form>
        </div>
    </div>

    <!-- 真正的充值弹窗 -->
    <div class="recharge-modal" id="actualRechargeModal">
        <div class="recharge-container">
            <span class="close-recharge" id="closeActualRecharge">&times;</span>
            <div class="recharge-header">
                <h2><i class="fas fa-coins"></i> 账户充值</h2>
                <p>请填写充值金额并选择支付方式</p>
            </div>
            
            <form id="actualRechargeForm" class="recharge-form">
                <div class="form-group">
                    <label for="actualRechargeAmount">充值金额</label>
                    <input type="number" id="actualRechargeAmount" placeholder="请输入充值金额" min="1" required>
                </div>
                
                <div class="form-group">
                    <label>支付方式</label>
                    <div class="payment-methods">
                        <label class="payment-option">
                            <input type="radio" name="actualPaymentMethod" value="alipay" checked>
                            <i class="fab fa-alipay"></i> 支付宝 <span class="payment-tag">全球支付</span>
                        </label>
                        <label class="payment-option">
                            <input type="radio" name="actualPaymentMethod" value="wechat">
                            <i class="fab fa-weixin"></i> 微信支付 <span class="payment-tag">国内支付</span>
                        </label>
                    </div>
                </div>
                
                <button type="submit" class="recharge-btn">
                    <span id="actualRechargeText">立即充值</span>
                    <span id="actualRechargeSpinner" style="display:none;">处理中...</span>
                </button>
                
                <div id="actualRechargeMessage" class="recharge-message"></div>
            </form>
        </div>
    </div>

    <!-- 半透明登录注册弹窗 -->
    <div class="auth-modal" id="authModal">
        <div class="auth-container">
            <span class="close-auth" id="closeAuth">&times;</span>
            <div class="auth-header">
                <h2><i class="fas fa-user-circle"></i> 用户中心</h2>
                <p>登录或注册以管理您的账户</p>
            </div>
            
            <div class="auth-tabs">
                <div class="auth-tab active" id="loginTab">登录</div>
                <div class="auth-tab" id="registerTab">注册</div>
            </div>
            
           <!-- 登录表单 -->
            <form id="loginForm" class="auth-form active">
                <div class="form-group">
                    <label for="loginUsername">用户名</label>
                    <input type="text" id="loginUsername" placeholder="请输入用户名" required>
                </div>
                
                <div class="form-group">
                    <label for="loginPassword">密码</label>
                    <div class="password-container">
                        <input type="password" id="loginPassword" placeholder="请输入密码" required>
                        <i class="fas fa-eye password-toggle" onclick="togglePassword('loginPassword', this)"></i>
                    </div>
                </div>
                
                <button type="submit" class="auth-btn" id="submitLogin">
                    <span id="loginText">登录</span>
                    <i class="fas fa-spinner fa-spin" id="loginSpinner" style="display:none;"></i>
                </button>
                
                <div class="forgot-password">
                    <a href="#" onclick="FlutterNavigation.postMessage('password_recovery');return false;">
                        忘记密码?
                    </a>
                </div>
                
                <div id="loginMessage" class="auth-message"></div>
            </form>
            
            <!-- 注册表单 -->
            <form id="registerForm" class="auth-form">
                <div class="form-group">
                    <label for="registerUsername">用户名</label>
                    <input type="text" id="registerUsername" placeholder="请输入用户名(4-16位)" required minlength="4" maxlength="16">
                </div>
                
                <div class="form-group">
                    <label for="registerEmail">电子邮箱</label>
                    <input type="email" id="registerEmail" placeholder="请输入电子邮箱" required>
                </div>
                
                <div class="form-group">
                    <label for="registerPassword">密码</label>
                    <div class="password-container">
                        <input type="password" id="registerPassword" placeholder="请输入密码(至少6位)" required minlength="6">
                        <i class="fas fa-eye password-toggle" onclick="togglePassword('registerPassword', this)"></i>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="registerConfirmPassword">确认密码</label>
                    <div class="password-container">
                        <input type="password" id="registerConfirmPassword" placeholder="请再次输入密码" required>
                        <i class="fas fa-eye password-toggle" onclick="togglePassword('registerConfirmPassword', this)"></i>
                    </div>
                </div>
                
                <button type="submit" class="auth-btn" id="submitRegister">
                    <span id="registerText">注册</span>
                    <i class="fas fa-spinner fa-spin" id="registerSpinner" style="display:none;"></i>
                </button>
                
                <div id="registerMessage" class="auth-message"></div>
            </form>
        </div>
    </div>
    
    <div class="page-container">
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1><i class="fas fa-yin-yang"></i> 专业八字预测系统</h1>
            <p>精准排盘 · 详细分析 · 专业预测</p>
        </header>

        <!-- 用户信息区域 -->
        <div class="user-area">
            <div class="user-welcome" id="userWelcome" style="display:none;">欢迎, <span id="usernameDisplay"></span></div>
            <div class="user-balance" style="display:none; margin: 5px 0;" id="userBalance">
                    <i class="fas fa-coins"></i> 余额: $<span id="balanceAmount">0.00</span>
                </div>
            <button class="login-btn" id="loginBtn">登录/注册</button>
            <div class="user-buttons-container" style="display:none;" id="userButtonsContainer">
                <button class="recharge-btn" id="stripeRechargeBtn" onclick="FlutterNavigation.postMessage('stripe_recharge')"><i class="fas fa-credit-card"></i> 充值</button>
                <button class="logout-btn" id="logoutBtn"><i class="fas fa-sign-out-alt"></i> 退出</button>
            </div>
        </div>

        <!-- Recent Records Section -->
        <section class="recent-records-section" id="recent-records-section" style="display: none;">
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-history"></i>
                    <h2>最近测算记录</h2>
                </div>
                <div class="recent-records-container" id="recent-records-container">
                    <!-- 最近测算记录将在这里显示 -->
                </div>
            </div>
        </section>

        <!-- Input Section -->
        <section class="input-section" id="input-section">
            <div class="card">
                
                <div class="card-header">
                    <i class="fas fa-user-edit"></i>
                    <h2>请输入您的出生信息</h2>
                </div>
                
                <div class="form-grid">
                    <div class="form-group">
                        <label for="name"><i class="fas fa-user"></i> 姓名</label>
                        <input type="text" id="name" placeholder="请输入您的姓名" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="gender"><i class="fas fa-venus-mars"></i> 性别</label>
                        <select id="gender" required>
                            <option value="">请选择性别</option>
                            <option value="male">男</option>
                            <option value="female">女</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="birth-date"><i class="fas fa-calendar-alt"></i> 出生日期</label>
                        <input type="date" id="birth-date" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="birth-time"><i class="fas fa-clock"></i> 出生时间</label>
                        <input type="time" id="birth-time" placeholder="请输入出生时间" required>
                        <small class="form-text">请输入24小时制时间，例如：08:30、15:45</small>
                    </div>
                    </div>
                </div>
                
                <div class="btn-center">
                    <button class="btn btn-primary" id="calculate-btn">
                        <i class="fas fa-calculator"></i> 开始八字测算
                    </button>
                </div>
            </div>
        </section>

        <!-- Result Section -->
        <section class="result-section" id="result-section">
            <!-- Basic Info -->
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-user-circle"></i>
                    <h2 id="user-info-title">基本信息</h2>
                </div>
                <div id="basic-info-content">
                    <!-- 基本信息将在这里显示 -->
                </div>
            </div>

            <!-- Bazi Chart -->
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-table"></i>
                    <h2>八字排盘</h2>
                </div>
                <div id="bazi-chart">
                    <!-- 八字排盘表格将在这里显示 -->
                </div>
            </div>

            <!-- Five Elements Chart -->
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-chart-pie"></i>
                    <h2>五行力量分布与分析</h2>
                    <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: var(--text-secondary); font-weight: normal;">原命局与当前运势的五行力量对比分析</p>
                </div>
                
                <!-- 双图表布局容器 -->
                <div class="elements-comparison-container" style="display: flex; gap: 25px; min-height: 450px; margin-bottom: 20px;">
                    
                    <!-- 左侧：原命局五行分布 -->
                    <div class="original-elements-section" style="flex: 1; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; padding: 20px; border: 2px solid #dee2e6; position: relative; overflow: hidden;">
                        <!-- 装饰性背景元素 -->
                        <div style="position: absolute; top: -20px; right: -20px; width: 80px; height: 80px; background: linear-gradient(45deg, #6c757d, #adb5bd); border-radius: 50%; opacity: 0.1;"></div>
                        
                        <div class="section-header" style="display: flex; align-items: center; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #6c757d;">
                            <i class="fas fa-yin-yang" style="color: #6c757d; font-size: 1.3rem; margin-right: 10px;"></i>
                            <h3 style="margin: 0; color: #495057; font-weight: 600; font-size: 1.1rem;">原命局五行分布</h3>
                        </div>
                        
                        <div class="original-elements-frame" style="display: flex; flex-direction: column; gap: 15px;">
                            <div class="chart-container" style="height: 280px !important; background: white; border-radius: 8px; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                                <canvas id="original-elements-chart"></canvas>
                            </div>
                            <div id="original-elements-summary" style="background: white; padding: 12px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border-left: 4px solid #6c757d; font-size: 0.9rem;">
                                <!-- 原命局五行分布概览 -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- 右侧：当前五行分布 -->
                    <div class="current-elements-section" style="flex: 1; background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%); border-radius: 12px; padding: 20px; border: 2px solid #4caf50; position: relative; overflow: hidden;">
                        <!-- 装饰性背景元素 -->
                        <div style="position: absolute; top: -20px; right: -20px; width: 80px; height: 80px; background: linear-gradient(45deg, #4caf50, #81c784); border-radius: 50%; opacity: 0.15;"></div>
                        
                        <div class="section-header" style="display: flex; align-items: center; margin-bottom: 20px; padding-bottom: 12px; border-bottom: 2px solid #4caf50;">
                            <i class="fas fa-clock" style="color: #4caf50; font-size: 1.3rem; margin-right: 10px;"></i>
                            <h3 style="margin: 0; color: #2e7d32; font-weight: 600; font-size: 1.1rem;">当前五行分布</h3>
                            <span style="margin-left: auto; font-size: 0.8rem; color: #388e3c; background: rgba(76, 175, 80, 0.1); padding: 4px 8px; border-radius: 4px;">含大运流年</span>
                        </div>
                        
                        <div class="current-elements-frame" style="display: flex; flex-direction: column; gap: 15px;">
                            <div class="current-chart-container" style="height: 280px !important; background: white; border-radius: 8px; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                                <canvas id="current-elements-chart"></canvas>
                            </div>
                            <div id="current-elements-summary" style="background: white; padding: 12px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border-left: 4px solid #4caf50; font-size: 0.9rem;">
                                <!-- 当前五行分布概览 -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 五行分析描述 -->
                <div class="chart-description" id="elements-description" style="width: 100%; background-color: #f9f9f9; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); margin: 0 auto;">
                    <!-- 五行分析描述 -->
                </div>
                
                <!-- 对比说明 -->
                <div class="comparison-note" style="margin-top: 15px; padding: 15px; background: linear-gradient(90deg, #e8f5e8 0%, #c8e6c9 100%); border-radius: 8px; border-left: 4px solid #4caf50;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <i class="fas fa-info-circle" style="color: #2e7d32; margin-right: 8px;"></i>
                        <strong style="color: #1b5e20;">分析说明</strong>
                    </div>
                    <p style="margin: 0; color: #2e7d32; font-size: 0.9rem; line-height: 1.5;">左侧显示您的原命局五行分布状态，右侧显示加入当前大运和流年后的五行力量变化。通过对比可以了解当前运势对您五行平衡的影响程度，以及哪些五行得到加强或削弱。</p>
                </div>
            </div>

            <!-- Combined Strength Analysis -->
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-balance-scale"></i>
                    <h2>身强身弱分析对比</h2>
                    <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: var(--text-secondary); font-weight: normal;">原命局与当前运势的力量对比分析</p>
                </div>
                
                <!-- 左右布局容器 -->
                <div class="strength-comparison-container" style="display: flex; gap: 15px; min-height: 320px;">
                    
                    <!-- 左侧：原命局分析 -->
                    <div class="original-strength-section" style="flex: 1; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; padding: 15px; border: 1px solid #dee2e6; position: relative; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.06);">
                        <!-- 装饰性背景元素 -->
                        <div style="position: absolute; top: -20px; right: -20px; width: 80px; height: 80px; background: linear-gradient(45deg, #6c757d, #adb5bd); border-radius: 50%; opacity: 0.1;"></div>
                        
                        <div class="section-header" style="display: flex; align-items: center; margin-bottom: 20px; padding-bottom: 12px; border-bottom: 2px solid #6c757d;">
                            <i class="fas fa-yin-yang" style="color: #6c757d; font-size: 1.3rem; margin-right: 10px;"></i>
                            <h3 style="margin: 0; color: #495057; font-weight: 600; font-size: 1.1rem;">原命局分析</h3>
                        </div>
                        
                        <div class="strength-analysis-frame" style="display: flex; flex-direction: column; gap: 12px;">
                            <div class="chart-container" style="height: 200px !important; background: white; border-radius: 8px; padding: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.08);">
                                <canvas id="strength-chart"></canvas>
                            </div>
                            <div class="chart-description" id="strength-description" style="background: white; padding: 12px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); border-left: 3px solid #6c757d;">
                                <!-- 身强身弱分析描述 -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- 右侧：当前分析 -->
                    <div class="current-strength-section" style="flex: 1; background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-radius: 12px; padding: 15px; border: 1px solid #2196f3; position: relative; overflow: hidden; box-shadow: 0 2px 8px rgba(33,150,243,0.12);">
                        <!-- 装饰性背景元素 -->
                        <div style="position: absolute; top: -20px; right: -20px; width: 80px; height: 80px; background: linear-gradient(45deg, #2196f3, #64b5f6); border-radius: 50%; opacity: 0.15;"></div>
                        
                        <div class="section-header" style="display: flex; align-items: center; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #2196f3;">
                            <i class="fas fa-clock" style="color: #2196f3; font-size: 1.3rem; margin-right: 10px;"></i>
                            <h3 style="margin: 0; color: #1976d2; font-weight: 600; font-size: 1.1rem;">当前运势分析</h3>
                        </div>
                        
                        <div class="current-strength-analysis-frame" style="display: flex; flex-direction: column; gap: 12px;">
                            <div class="current-chart-container" style="height: 200px !important; background: white; border-radius: 8px; padding: 10px; box-shadow: 0 2px 6px rgba(33,150,243,0.12);">
                                <canvas id="current-strength-chart"></canvas>
                            </div>
                            <div class="chart-description" id="current-strength-description" style="background: white; padding: 12px; border-radius: 8px; box-shadow: 0 2px 6px rgba(33,150,243,0.12); border-left: 3px solid #2196f3;">
                                <!-- 当前身强身弱分析描述 -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 对比说明 -->
                <div class="comparison-note" style="margin-top: 15px; padding: 12px; background: linear-gradient(90deg, #fff3e0 0%, #ffe0b2 100%); border-radius: 6px; border-left: 3px solid #ff9800;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <i class="fas fa-info-circle" style="color: #f57c00; margin-right: 8px;"></i>
                        <strong style="color: #ef6c00;">分析说明</strong>
                    </div>
                    <p style="margin: 0; color: #bf360c; font-size: 0.9rem; line-height: 1.5;">左侧显示您的原命局身强身弱状态，右侧显示加入当前大运和流年后的身强身弱变化。通过对比可以了解当前运势对您命局力量的影响程度。</p>
                    
                    <!-- 简化的12种身强身弱状态说明 -->
                    <div style="margin-top: 10px; padding: 8px; background-color: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
                        <div style="display: flex; align-items: center; margin-bottom: 8px;">
                            <i class="fas fa-graduation-cap" style="color: #6c757d; margin-right: 8px;"></i>
                            <strong style="color: #495057; font-size: 0.9rem;">身强身弱状态说明</strong>
                        </div>
                        <div style="font-size: 0.85rem; color: #6c757d; line-height: 1.4;">
                            <span style="color: #dc3545;">极弱(≤8%)</span> → 
                            <span style="color: #fd7e14;">很弱(8-15%)</span> → 
                            <span style="color: #ffc107;">较弱(15-25%)</span> → 
                            <span style="color: #20c997;">稍弱(25-35%)</span> → 
                            <span style="color: #17a2b8;">微弱(35-42%)</span> → 
                            <span style="color: #6f42c1;">中和偏弱(42-48%)</span> → 
                            <span style="color: #28a745; font-weight: bold;">真正中和(48-52%)</span> → 
                            <span style="color: #007bff;">中和偏强(52-58%)</span> → 
                            <span style="color: #6610f2;">微强(58-65%)</span> → 
                            <span style="color: #e83e8c;">稍强(65-75%)</span> → 
                            <span style="color: #fd7e14;">较强(75-85%)</span> → 
                            <span style="color: #dc3545;">极强(>85%)</span>
                            <br><small style="color: #868e96; margin-top: 5px; display: block;">括号内为生扶日主的力量比例，中和状态最佳，过强过弱都需要调节</small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Luck Starting Time -->
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-hourglass-start"></i>
                    <h2>起运时间</h2>
                </div>
                <div id="luck-timing">
                    <!-- 起运时间分析 -->
                </div>
            </div>

            <!-- 详批八字按钮和介绍 -->
            <div class="card" style="background: linear-gradient(135deg, #fffbf0, #fff8e1); border: 2px solid #f0c674;">
                <div class="card-header">
                    <i class="fas fa-unlock"></i>
                    <h2>详批八字（1-30元每次，按命主财富等级收费）</h2>
                </div>
                <p style="font-weight: bold;">专业八字详批，深度解析您的一生运势！ 本系统基于传统命理精髓，结合现代算法，为您提供全面精准的八字分析，包括：命格等级评分（格局层次）、财富等级评分（财源特质）、命理全解（五行平衡、用神忌神）、十年大运走势、流年吉凶提示、流月运势波动，以及专项分析您的性格潜能、事业财富机遇、婚姻感情匹配度和子女缘份，助您把握人生关键节点。</p>
                <p style="font-weight: bold; color: #d4a574; margin-top: 15px; padding: 10px; background: rgba(212, 165, 116, 0.1); border-radius: 8px; border-left: 4px solid #d4a574;">📿 <strong>传统道家收费规矩</strong>：自古以来，道家看八字遵循"命好者多收，命薄者少收"的传统。一介平民仅需1元，集荣华富贵于一身者需付30元，依据财富等级收费。此乃天道公平，命运厚重者当多施舍，命运清薄者当少负担。多付者积福，少付者亦得助，皆为善缘。</p>
                <div class="btn-center">
                    <button class="btn btn-primary" id="detailed-analysis-btn">立即详批</button>
                </div>
            </div>

            <!-- 隐藏内容 -->
            <div id="paid-content" style="display: none; background: linear-gradient(135deg, #fffbf0, #fff8e1); border-radius: 12px; padding: 20px; border: 2px solid #f0c674; margin-bottom: 30px;">

            <!-- Fate Level Analysis -->
            <div class="analysis-grid">
                <div class="analysis-card">
                    <h3 id="fate-level-title"><i class="fas fa-star"></i> 命格等级</h3>
                    <div id="fate-level-content">
                        <!-- 命格等级分析 -->
                    </div>
                </div>
                
                <div class="analysis-card">
                    <h3 id="wealth-level-title"><i class="fas fa-coins"></i> 财富等级</h3>
                    <div id="wealth-level-content">
                        <!-- 财富等级分析 -->
                    </div>
                </div>
            </div>


            <!-- Bazi Q&A Section -->
            <div class="bazi-qa-container">
                <div class="bazi-qa-header">
                    <h3><i class="fas fa-question-circle"></i> 八字问答</h3>
                    <p class="bazi-qa-subtitle">基于您的八字信息，询问任何八字相关问题</p>
                </div>
                <div class="bazi-qa-input-section">
                    <div class="bazi-qa-input-wrapper">
                        <input type="text" id="bazi-qa-input" placeholder="请输入您的八字相关问题，例如：我的命格等级的得分计算逻辑是什么？今年的事业运势如何？今年身体方面需要注意什么？" />
                        <button class="bazi-qa-submit" id="bazi-qa-submit">
                            <i class="fas fa-paper-plane"></i> 提问
                        </button>
                    </div>
                </div>
                <div id="bazi-qa-response" class="bazi-qa-response" style="display: none;">
                    <!-- 回答内容将在这里显示 -->
                </div>
                <div id="bazi-qa-loading" class="bazi-qa-loading" style="display: none;">
                    <div class="loading beautiful-spinner"></div>
                    <span>命理大师思考中，请耐心等待...</span>
                </div>
            </div>

            <!-- Analysis Buttons Section -->
            <div class="analysis-buttons-container">
                <div class="analysis-btn" data-analysis="full-analysis">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-magic"></i> 命理全解</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">全面解析八字命理，包含性格、事业、财运、婚姻等多方面</div>
                </div>
                <div class="analysis-content" id="full-analysis-content" data-analysis="full-analysis"></div>
                
                <div class="analysis-btn" data-analysis="annual-fortune">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-calendar-alt"></i> 流年分析</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">分析当前流年对命局的影响和运势变化</div>
                </div>
                <div class="analysis-content" id="annual-fortune-content" data-analysis="annual-fortune"></div>
                
                <div class="analysis-btn" data-analysis="monthly-fortune">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-calendar-day"></i> 流月分析</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">预测当前年份每月的运势起伏</div>
                </div>
                <div class="analysis-content" id="monthly-fortune-content" data-analysis="monthly-fortune"></div>
                
                <div class="analysis-btn" data-analysis="decade-fortune">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-hourglass-half"></i> 十年大运分析</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">分析一生中各阶段大运走势</div>
                </div>
                <div class="analysis-content" id="decade-fortune-content" data-analysis="decade-fortune"></div>
                
                <div class="analysis-btn" data-analysis="personality">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-brain"></i> 性格分析</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">根据八字分析性格特征和优缺点</div>
                </div>
                <div class="analysis-content" id="personality-content" data-analysis="personality"></div>
                
                <div class="analysis-btn" data-analysis="career-wealth">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-briefcase"></i> 事业财富</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">分析适合的职业方向和财富格局</div>
                </div>
                <div class="analysis-content" id="career-wealth-content" data-analysis="career-wealth"></div>
                
                <div class="analysis-btn" data-analysis="marriage">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-heart"></i> 婚姻分析</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">分析婚姻状况和配偶特征</div>
                </div>
                <div class="analysis-content" id="marriage-content" data-analysis="marriage"></div>
                
                <div class="analysis-btn" data-analysis="children">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-baby"></i> 子女分析</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">分析子女缘分和教育方向</div>
                </div>
                <div class="analysis-content" id="children-content" data-analysis="children"></div>
                
                <div class="analysis-btn" data-analysis="health">
                    <div class="analysis-btn-header">
                        <div class="analysis-btn-title" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="text-align: left;"><i class="fas fa-heartbeat"></i> 健康分析</div>
                            <i class="fas fa-caret-down" style="color: #3498db; font-size: 150%; margin-left: auto;"></i>
                        </div>
                        <div class="loading" style="display: none;"></div>
                    </div>
                    <div class="analysis-btn-desc">根据五行平衡分析健康状况</div>
                </div>
                <div class="analysis-content" id="health-content" data-analysis="health"></div>
            </div>


            </div> <!-- 关闭 paid-content -->
            
            <div class="btn-center">
                <button class="btn btn-primary" id="recalculate-btn" onclick="location.reload()">
                    <i class="fas fa-redo"></i> 重新测算
                </button>
            </div>
        </section>
    </div>

    <!-- Scripts -->
    <script src="js/lunar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // 全局变量
        let currentBaziData = null;
        let elementsChart = null;
        let strengthChart = null;
        let currentStrengthChart = null;
        let recentRecords = []; // 最近测算记录
        const MAX_RECENT_RECORDS = 8; // 最大记录数

        // DOM元素
        const inputSection = document.getElementById('input-section');
        const resultSection = document.getElementById('result-section');
        const calculateBtn = document.getElementById('calculate-btn');
        const recalculateBtn = document.getElementById('recalculate-btn');
        const birthTimeInput = document.getElementById('birth-time');

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();

            setupAnalysisButtons();
            loadRecentRecords();
            displayRecentRecords();
        });

        // 设置事件监听器
        function setupEventListeners() {
            calculateBtn.addEventListener('click', handleCalculate);
            recalculateBtn.addEventListener('click', handleRecalculate);
            setupBaziQA();
        }

        // 加载最近记录
        function loadRecentRecords() {
            try {
                const stored = localStorage.getItem('baziRecentRecords');
                if (stored) {
                    recentRecords = JSON.parse(stored);
                }
            } catch (error) {
                console.error('加载最近记录失败:', error);
                recentRecords = [];
            }
        }

        // 保存最近记录
        function saveRecentRecords() {
            try {
                localStorage.setItem('baziRecentRecords', JSON.stringify(recentRecords));
            } catch (error) {
                console.error('保存最近记录失败:', error);
            }
        }

        // 添加新记录
        function addRecentRecord(data) {
            const record = {
                id: Date.now().toString(),
                name: data.name,
                gender: data.gender,
                birthDate: data.birthDate,
                birthTime: data.birthTime,
                baziData: data.baziData,
                timestamp: new Date().toISOString()
            };

            // 检查是否已存在相同记录
            const existingIndex = recentRecords.findIndex(r => 
                r.name === record.name && 
                r.birthDate === record.birthDate && 
                r.birthTime === record.birthTime
            );

            if (existingIndex !== -1) {
                // 更新现有记录的时间戳
                recentRecords[existingIndex].timestamp = record.timestamp;
                // 移动到最前面
                const updatedRecord = recentRecords.splice(existingIndex, 1)[0];
                recentRecords.unshift(updatedRecord);
            } else {
                // 添加新记录到最前面
                recentRecords.unshift(record);
                // 保持最大记录数
                if (recentRecords.length > MAX_RECENT_RECORDS) {
                    recentRecords = recentRecords.slice(0, MAX_RECENT_RECORDS);
                }
            }

            saveRecentRecords();
            displayRecentRecords();
        }

        // 删除记录
        function deleteRecentRecord(id) {
            recentRecords = recentRecords.filter(record => record.id !== id);
            saveRecentRecords();
            displayRecentRecords();
        }

        // 显示最近记录
        function displayRecentRecords() {
            const container = document.getElementById('recent-records-container');
            const section = document.getElementById('recent-records-section');
            
            if (!container || !section) return;

            if (recentRecords.length === 0) {
                container.innerHTML = `
                    <div class="no-recent-records">
                        <i class="fas fa-history"></i>
                        <p>暂无最近测算记录</p>
                    </div>
                `;
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            container.innerHTML = recentRecords.map(record => {
                const date = new Date(record.timestamp);
                const formattedDate = date.toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                const genderClass = record.gender === '男' ? 'male' : 'female';
                const genderIcon = record.gender === '男' ? 'fas fa-mars' : 'fas fa-venus';

                return `
                    <div class="recent-record-item" data-id="${record.id}">
                        <div class="recent-record-header">
                            <div class="recent-record-name">
                                <i class="fas fa-user"></i>
                                ${record.name}
                            </div>
                            <div class="recent-record-gender ${genderClass}">
                                <i class="${genderIcon}"></i> ${record.gender}
                            </div>
                        </div>
                        <div class="recent-record-info">
                            <div class="recent-record-datetime">
                                <i class="fas fa-clock"></i>
                                ${formattedDate}
                            </div>
                        </div>
                        <div class="recent-record-actions">
                            <button class="recent-record-btn primary" onclick="loadRecentRecord('${record.id}')">
                                <i class="fas fa-calculator"></i> 重新测算
                            </button>
                            <button class="recent-record-btn danger" onclick="deleteRecentRecord('${record.id}')">
                                <i class="fas fa-trash"></i> 删除
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 加载最近记录进行测算
        function loadRecentRecord(id) {
            const record = recentRecords.find(r => r.id === id);
            if (!record) return;

            // 填充表单
            document.getElementById('name').value = record.name;
            document.getElementById('gender').value = record.gender;
            document.getElementById('birth-date').value = record.birthDate;
            document.getElementById('birth-time').value = record.birthTime;

            // 检查结果区域是否已经显示
            const resultSection = document.getElementById('result-section');
            const isResultVisible = resultSection && resultSection.classList.contains('show');

            if (isResultVisible) {
                // 如果结果区域已经显示，直接滚动到结果区域并重新计算
                resultSection.scrollIntoView({ 
                    behavior: 'smooth',
                    block: 'start'
                });
                // 自动触发计算
                setTimeout(() => {
                    handleCalculate();
                }, 500);
            } else {
                // 如果结果区域未显示，滚动到输入区域
                document.getElementById('input-section').scrollIntoView({ 
                    behavior: 'smooth',
                    block: 'start'
                });
                // 自动触发计算
                setTimeout(() => {
                    handleCalculate();
                }, 500);
            }
        }
        
        // 设置八字问答功能
        function setupBaziQA() {
            const qaInput = document.getElementById('bazi-qa-input');
            const qaSubmit = document.getElementById('bazi-qa-submit');
            const qaResponse = document.getElementById('bazi-qa-response');
            const qaLoading = document.getElementById('bazi-qa-loading');
            
            if (qaSubmit) {
                qaSubmit.addEventListener('click', handleBaziQA);
            }
            
            if (qaInput) {
                qaInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        handleBaziQA();
                    }
                });
            }
        }
        
        // 处理八字问答
        async function handleBaziQA() {
            const qaInput = document.getElementById('bazi-qa-input');
            const qaResponse = document.getElementById('bazi-qa-response');
            const qaLoading = document.getElementById('bazi-qa-loading');
            const qaSubmit = document.getElementById('bazi-qa-submit');
            
            const question = qaInput.value.trim();
            if (!question) {
                alert('请输入您的问题');
                return;
            }
            
            // 检查是否已计算八字
            if (!window.currentBaziData) {
                alert('请先计算八字信息');
                return;
            }
            
            // 显示加载状态
            qaLoading.style.display = 'flex';
            qaResponse.style.display = 'none';
            qaSubmit.disabled = true;
            
            try {
                const response = await callBaziQAAPI(question, window.currentBaziData);
                
                // 显示回答
                qaResponse.innerHTML = response;
                qaResponse.style.display = 'block';
                qaLoading.style.display = 'none';
                
                // 清空输入框
                qaInput.value = '';
                
            } catch (error) {
                console.error('八字问答API调用失败:', error);
                qaResponse.innerHTML = '<p style="color: #e74c3c;">抱歉，问答服务暂时不可用，请稍后再试。</p>';
                qaResponse.style.display = 'block';
                qaLoading.style.display = 'none';
            } finally {
                qaSubmit.disabled = false;
            }
        }



        // 设置标签页系统


        // 设置分析按钮
        function setupAnalysisButtons() {
            const analysisBtns = document.querySelectorAll('.analysis-btn');
            
            analysisBtns.forEach(btn => {
                btn.addEventListener('click', async function() {
                    const analysisType = this.dataset.analysis;
                    const contentElement = document.getElementById(analysisType + '-content');
                    const loadingElement = this.querySelector('.loading');
                    
                    if (contentElement.classList.contains('show')) {
                        // 如果已经显示，则隐藏
                        contentElement.classList.remove('show');
                    } else {
                        // 检查是否有八字数据
                        if (!currentBaziData) {
                            alert('请先进行八字测算');
                            return;
                        }
                        
                        // 显示加载状态
                        loadingElement.innerHTML = '<span style="display: flex; align-items: center; justify-content: center; width: 100%; margin: 0;"><i class="fas fa-spinner fa-spin" style="color: #3498db; font-size: 2.5em;"></i></span>';
                        loadingElement.style.display = 'flex';
                        loadingElement.style.position = 'absolute';
                        loadingElement.style.top = '0';
                        loadingElement.style.left = '0';
                        loadingElement.style.width = '100%';
                        loadingElement.style.height = '100%';
                        loadingElement.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
                        loadingElement.style.borderRadius = '12px';
                        loadingElement.style.zIndex = '10';
                        // 移除 this.classList.add('loading'); 以避免潜在的旋转效果
                        
                        try {
                            // 使用本地已获取的八字信息、身强身弱信息和起运时间信息
                            // 通过DeepSeek API获取专业命理分析
                            const analysisContent = await getBaziAnalysisFromDeepSeek(analysisType, currentBaziData);
                            
                            // 隐藏加载状态
                            loadingElement.style.display = 'none';
                            this.classList.remove('loading');
                            
                            // 显示分析内容
                            contentElement.innerHTML = marked.parse(analysisContent);
contentElement.classList.add('show');
                            contentElement.classList.add('show');
                            console.log('成功获取API分析内容:', analysisType);
                        } catch (error) {
                            console.error('获取分析内容失败:', error);
                            
                            // 隐藏加载状态
                            loadingElement.style.display = 'none';
                            this.classList.remove('loading');
                            
                            // 显示错误提示和备用内容
                            const errorMessage = `<div class="api-error-message">API调用失败: ${error.message || '未知错误'}，使用备用内容</div>`;
                            contentElement.innerHTML = errorMessage + marked.parse(getAnalysisContent(analysisType));
                            contentElement.classList.add('show');
                        }
                    }
                });
            });
        }

        // 处理计算按钮点击
        async function handleCalculate() {
            if (!validateForm()) {
                return;
            }
            
            // 显示加载状态
            calculateBtn.innerHTML = '<div class="loading"></div> <span>计算中...</span>';
            calculateBtn.disabled = true;
            
            // 显示全局加载遮罩
            showLoading('正在进行八字测算，请稍候...');
            
            try {
                // 获取表单数据
                const formData = getFormData();
                
                // 计算八字
                const baziData = await calculateBazi(formData);
                currentBaziData = baziData;
                window.currentBaziData = baziData;
                
                // 显示结果
                displayResults(baziData);
                
                // 添加到最近记录
                addRecentRecord({
                    name: formData.name,
                    gender: formData.gender,
                    birthDate: formData.birthDate,
                    birthTime: formData.birthTime,
                    baziData: {
                        year: baziData.year,
                        month: baziData.month,
                        day: baziData.day,
                        hour: baziData.hour
                    }
                });
                
                // 切换到结果页面
                inputSection.style.display = 'none';
                resultSection.classList.add('show');
                
            } catch (error) {
                console.error('计算失败:', error);
                alert('计算失败，请检查输入信息后重试');
            } finally {
                calculateBtn.innerHTML = '<i class="fas fa-calculator"></i> 开始八字测算';
                calculateBtn.disabled = false;
                
                // 隐藏全局加载遮罩
                hideLoading();
            }
        }

        // 显示加载状态
        function showLoading(message = '正在处理，请稍候...') {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingMessage = document.getElementById('loadingMessage');
            
            if (loadingMessage) {
                loadingMessage.textContent = message;
            }
            
            loadingOverlay.style.display = 'flex';
        }
        
        // 隐藏加载状态
        function hideLoading() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.display = 'none';
        }
        
        // 处理重新计算
        function handleRecalculate() {
            inputSection.style.display = 'block';
            resultSection.classList.remove('show');
            
            // 清空API反馈内容的缓存
            const cacheKeys = [
                'full-analysis', 'annual-fortune', 'monthly-fortune', 'decade-fortune',
                'personality', 'career', 'wealth', 'marriage', 
                'health', 'luck', 'children', 'disaster'
            ];
            cacheKeys.forEach(analysisType => {
                // 清空localStorage中的缓存
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.includes(analysisType)) {
                        localStorage.removeItem(key);
                    }
                });
                
                // 清空页面显示内容
                const contentElement = document.getElementById(analysisType + '-content');
                if (contentElement) {
                    contentElement.innerHTML = '';
                    contentElement.classList.remove('show');
                }
            });

            // 新增: 重置财富等级与命格等级缓存及页面显示
            wealthScoreValue = 0;
            fateScoreValue = 0;
            wealthScoreDetails = {};
            fateScoreDetails = {};
            const wealthScoreEl = document.getElementById('wealth-score');
            if (wealthScoreEl) wealthScoreEl.textContent = '';
            const fateScoreEl = document.getElementById('fate-score');
            if (fateScoreEl) fateScoreEl.textContent = '';
            
            // 重置当前八字数据
            currentBaziData = null;
            window.currentBaziData = null;
            
            // 重置表单
            document.getElementById('name').value = '';
            document.getElementById('gender').value = '';
            document.getElementById('birth-date').value = '';
            document.getElementById('birth-time').value = '';
        }

        // 验证表单
        function validateForm() {
            const name = document.getElementById('name').value.trim();
            const gender = document.getElementById('gender').value;
            const birthDate = document.getElementById('birth-date').value;
            const birthTime = document.getElementById('birth-time').value;
            
            if (!name) {
                alert('请输入姓名');
                return false;
            }
            
            if (!gender) {
                alert('请选择性别');
                return false;
            }
            
            if (!birthDate) {
                alert('请选择出生日期');
                return false;
            }
            
            if (!birthTime) {
                alert('请输入出生时间');
                return false;
            }
            
            // 验证时间格式
            const timePattern = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;
            if (!timePattern.test(birthTime)) {
                alert('出生时间格式不正确，请使用24小时制（如：08:30、15:45）');
                return false;
            }
            
            return true;
        }

        // 获取表单数据
        function getFormData() {
            return {
                name: document.getElementById('name').value.trim(),
                gender: document.getElementById('gender').value,
                birthDate: document.getElementById('birth-date').value,
                birthTime: document.getElementById('birth-time').value
            };
        }

        // 计算八字
        async function calculateBazi(formData) {
            const { birthDate, birthTime } = formData;
            const [hour, minute] = birthTime.split(':').map(Number);
            
            // 验证时间格式
            if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
                throw new Error('出生时间格式不正确，请使用24小时制（如：08:30、15:45）');
            }
            
            const date = new Date(birthDate + 'T00:00:00');
            date.setHours(hour, minute, 0, 0);
            
            // 使用lunar.js计算八字
            const solar = Solar.fromDate(date);
            const lunar = solar.getLunar();
            const eightChar = lunar.getEightChar();
            
            // 将eightChar保存到window对象，供其他函数使用
            window.eightChar = eightChar;
            
            // 获取四柱信息
            const yearPillar = eightChar.getYear();
            const monthPillar = eightChar.getMonth();
            const dayPillar = eightChar.getDay();
            const hourPillar = eightChar.getTime();
            
            // 确保四柱是字符串
            const yearStr = typeof yearPillar === 'string' ? yearPillar : String(yearPillar);
            const monthStr = typeof monthPillar === 'string' ? monthPillar : String(monthPillar);
            const dayStr = typeof dayPillar === 'string' ? dayPillar : String(dayPillar);
            const hourStr = typeof hourPillar === 'string' ? hourPillar : String(hourPillar);
            
            // 计算藏干
            const hiddenStems = {
                year: yearStr.length > 1 ? getHiddenStems(yearStr.charAt(1)) : [],
                month: monthStr.length > 1 ? getHiddenStems(monthStr.charAt(1)) : [],
                day: dayStr.length > 1 ? getHiddenStems(dayStr.charAt(1)) : [],
                hour: hourStr.length > 1 ? getHiddenStems(hourStr.charAt(1)) : []
            };
            
            // 计算五行分布
            const elements = calculateElements(yearStr, monthStr, dayStr, hourStr, hiddenStems);
            
            // 计算身强身弱
            // 计算起运时间，传入原始阳历日期
            const luckTiming = calculateLuckTiming(formData.gender, lunar, date);
            
            // 定义四柱对象
            const pillars = {
                year: yearStr,
                month: monthStr,
                day: dayStr,
                hour: hourStr
            };
            
            // 将四柱信息保存到window对象，供其他函数使用
            window.currentPillars = pillars;
            
            // 提取天干和地支，供土性变化分析使用
            const allStems = [];
            const allBranches = [];
            if (yearStr.length > 0) allStems.push(yearStr.charAt(0));
            if (monthStr.length > 0) allStems.push(monthStr.charAt(0));
            if (dayStr.length > 0) allStems.push(dayStr.charAt(0));
            if (hourStr.length > 0) allStems.push(hourStr.charAt(0));
            
            if (yearStr.length > 1) allBranches.push(yearStr.charAt(1));
            if (monthStr.length > 1) allBranches.push(monthStr.charAt(1));
            if (dayStr.length > 1) allBranches.push(dayStr.charAt(1));
            if (hourStr.length > 1) allBranches.push(hourStr.charAt(1));
            
            window.allStems = allStems;
            window.allBranches = allBranches;
            console.log('设置八字天干:', window.allStems);
            console.log('设置八字地支:', window.allBranches);
            
            // 计算身强身弱（传递天干和地支参数）
            const strengthAnalysis = calculateStrength(dayStr, elements, monthStr, allBranches, allStems);
            
            // 在计算命格等级前，提前写入当前强弱分析到全局，供从格判断使用
            if (!window.currentBaziData) window.currentBaziData = {};
            window.currentBaziData.strengthAnalysis = strengthAnalysis;
            window.currentBaziData.pillars = pillars;
            window.currentBaziData.luckTiming = luckTiming;
            
            // 提前计算当前大运信息，避免下游重复计算
            const currentDayunInfo = getCurrentDayun();
            window.currentBaziData.currentDayun = currentDayunInfo;
            
            // 计算命格等级
            const fateLevel = calculateFateLevel(pillars);
            
            // 计算财富等级
            const wealthLevel = calculateWealthLevel(pillars);
            
            // 计算当前流年信息供财富计算使用
            const currentDate = new Date();
            const currentSolar = Solar.fromDate(currentDate);
            const currentLunar = currentSolar.getLunar();
            const currentYearGanZhi = currentLunar.getYearInGanZhi();
            // 写入全局缓存，避免重复计算
            if (!window.currentBaziData) window.currentBaziData = {};
            window.currentBaziData.currentYearGanZhi = currentYearGanZhi;
            
            return {
                name: formData.name,
                gender: formData.gender,
                birthDate: formData.birthDate,
                birthTime: formData.birthTime,
                solar: solar,
                lunar: lunar,
                pillars: {
                    year: yearStr,
                    month: monthStr,
                    day: dayStr,
                    hour: hourStr
                },
                hiddenStems: hiddenStems,
                elements: elements,
                strengthAnalysis: strengthAnalysis,
                luckTiming: luckTiming,
                currentDayun: currentDayunInfo,  // 新增：当前大运信息
                fateLevel: fateLevel,
                wealthLevel: wealthLevel,
                currentYearGanZhi: currentYearGanZhi,  // 新增：当前流年干支
                // API调用所需的格式化数据
                formattedBirthDate: `${lunar.getYear()}年${lunar.getMonth()}月${lunar.getDay()}日`,
                formattedBirthTime: `${formData.birthTime}时`,
                baziString: `${yearPillar} ${monthPillar} ${dayPillar} ${hourPillar}`
            };
        }

        // 获取地支藏干
        function getHiddenStems(branch) {
            const hiddenStemsMap = {
                '子': ['癸'],
                '丑': ['己', '癸', '辛'],
                '寅': ['甲', '丙', '戊'],
                '卯': ['乙'],
                '辰': ['戊', '乙', '癸'],
                '巳': ['丙', '庚', '戊'],
                '午': ['丁', '己'],
                '未': ['己', '丁', '乙'],
                '申': ['庚', '壬', '戊'],
                '酉': ['辛'],
                '戌': ['戊', '辛', '丁'],
                '亥': ['壬', '甲']
            };
            return hiddenStemsMap[branch] || [];
        }

        // 计算五行分布
        function calculateElements(year, month, day, hour, hiddenStems) {
            const elementMap = {
                '甲': 'wood', '乙': 'wood',
                '丙': 'fire', '丁': 'fire',
                '戊': 'earth', '己': 'earth',
                '庚': 'metal', '辛': 'metal',
                '壬': 'water', '癸': 'water',
                '寅': 'wood', '卯': 'wood',
                '巳': 'fire', '午': 'fire',
                '辰': 'earth', '戌': 'earth', '丑': 'earth', '未': 'earth',
                '申': 'metal', '酉': 'metal',
                '子': 'water', '亥': 'water'
            };
            
            const elements = { wood: 0, fire: 0, earth: 0, metal: 0, water: 0 };
            
            // 确保四柱是字符串
            const pillars = [
                typeof year === 'string' ? year : String(year),
                typeof month === 'string' ? month : String(month),
                typeof day === 'string' ? day : String(day),
                typeof hour === 'string' ? hour : String(hour)
            ];
            
            // 按照传统八字理论调整权重分配
            // 月令占33%，其他柱位按传统权重分配
            const pillarWeights = {
                stem: [1.0, 2.0, 1.2, 0.8], // 年月日时天干权重，月干加强
                branch: [0.8, 3.0, 1.0, 0.6] // 年月日时地支权重，月支大幅加强（月令）
            };
            
            pillars.forEach((pillar, index) => {
                if (pillar && pillar.length >= 2) {
                    const stem = pillar.charAt(0);
                    const branch = pillar.charAt(1);
                    
                    if (elementMap[stem]) {
                        elements[elementMap[stem]] += pillarWeights.stem[index];
                    }
                    if (elementMap[branch]) {
                        elements[elementMap[branch]] += pillarWeights.branch[index];
                    }
                }
            });
            
            // 计算藏干，月令藏干权重加强
            const hiddenStemWeights = [0.3, 1.5, 0.4, 0.2]; // 年月日时藏干权重，月令藏干加强
            Object.entries(hiddenStems).forEach(([pillar, stems], index) => {
                stems.forEach((stem, stemIndex) => {
                    if (elementMap[stem]) {
                        let weight = hiddenStemWeights[index];
                        // 月令主气权重最高，中气次之，余气最低
                        if (index === 1) { // 月令
                            if (stemIndex === 0) weight *= 1.0; // 主气
                            else if (stemIndex === 1) weight *= 0.6; // 中气
                            else weight *= 0.3; // 余气
                        }
                        elements[elementMap[stem]] += weight;
                    }
                });
            });
            
            // 确保月令五行占33%的比例
            console.log('=== 月令占比修复调试 ===');
            console.log('pillars参数:', pillars);
            console.log('pillars[1]:', pillars[1]);
            console.log('月支字符:', pillars[1] ? pillars[1].charAt(1) : 'undefined');
            const monthBranchElement = elementMap[pillars[1].charAt(1)];
            console.log('monthBranchElement:', monthBranchElement);
            console.log('elementMap:', elementMap);
            if (monthBranchElement) {
                const currentTotal = Object.values(elements).reduce((sum, val) => sum + val, 0);
                const currentMonthRatio = elements[monthBranchElement] / currentTotal;
                
                console.log(`月令调整前 - 月支: ${pillars[1].charAt(1)}, 五行: ${monthBranchElement}, 当前占比: ${(currentMonthRatio * 100).toFixed(1)}%`);
                console.log('调整前五行分布:', JSON.parse(JSON.stringify(elements)));
                
                // 强制调整月令占比到33%
                console.log('强制调整月令占比到33%...');
                
                // 计算其他五行的总和（排除月令五行）
                let otherElementsTotal = 0;
                const otherElements = {};
                Object.keys(elements).forEach(element => {
                    if (element !== monthBranchElement) {
                        otherElements[element] = elements[element];
                        otherElementsTotal += elements[element];
                    }
                });
                
                // 如果其他五行总和为0，给每个非月令五行分配少量权重
                if (otherElementsTotal === 0) {
                    Object.keys(elements).forEach(element => {
                        if (element !== monthBranchElement) {
                            otherElements[element] = 0.1;
                            otherElementsTotal += 0.1;
                        }
                    });
                }
                
                // 重新分配：月令33%，其他67%
                const targetTotal = otherElementsTotal / 0.67;
                const monthElementValue = targetTotal * 0.33;
                
                // 更新月令五行
                elements[monthBranchElement] = monthElementValue;
                
                // 按比例调整其他五行
                Object.keys(otherElements).forEach(element => {
                    elements[element] = (otherElements[element] / otherElementsTotal) * (targetTotal * 0.67);
                });
                
                console.log('月令占比调整完成');
                console.log('调整后五行分布:', JSON.parse(JSON.stringify(elements)));
            }
            
            // 计算总分并验证月令权重
            const total = Object.values(elements).reduce((sum, val) => sum + val, 0);
            const monthElementTotal = elements[monthBranchElement];
            const monthPercentage = ((monthElementTotal / total) * 100).toFixed(1);
            
            // 转换为中文五行名称（页面显示需要）
            const chineseElements = {
                '木': elements.wood,
                '火': elements.fire,
                '土': elements.earth,
                '金': elements.metal,
                '水': elements.water
            };
            
            // 打印调试信息
            console.log('=== 五行分布计算结果 ===');
            console.log('英文五行分布:', elements);
            console.log('中文五行分布:', chineseElements);
            console.log(`总分: ${total.toFixed(2)}`);
            console.log(`月令五行(${pillars[1].charAt(1)}-${monthBranchElement}): ${monthElementTotal.toFixed(2)}, 占比: ${monthPercentage}%`);
            console.log('=========================');
            
            // 调试返回值
            console.log('=== calculateElements 返回值调试 ===');
            console.log('返回的elements对象:', elements);
            Object.entries(elements).forEach(([key, value]) => {
                console.log(`${key}: ${value} (类型: ${typeof value})`);
            });
            console.log('=====================================');
            
            return elements; // 返回英文五行名称，保持与其他函数的兼容性
        }

        // 测试函数 - 可在控制台调用
        window.testMonthElementRatio = function() {
            console.log('测试月令占比修复效果...');
            const testPillars = ['丙戌', '庚寅', '己丑', '丁卯'];
            const testHiddenStems = {
                year: getHiddenStems('戌'),
                month: getHiddenStems('寅'),
                day: getHiddenStems('丑'),
                hour: getHiddenStems('卯')
            };
            const result = calculateElements(testPillars[0], testPillars[1], testPillars[2], testPillars[3], testHiddenStems);
            console.log('测试完成，请查看上方输出结果');
            return result;
        };
        
        // 测试图表显示的函数
        window.testChartDisplay = function() {
            console.log('=== 测试图表显示 ===');
            const testPillars = ['丙戌', '庚寅', '己丑', '丁卯'];
            const testHiddenStems = {
                year: getHiddenStems('戌'),
                month: getHiddenStems('寅'),
                day: getHiddenStems('丑'),
                hour: getHiddenStems('卯')
            };
            
            // 计算五行分布
            const elements = calculateElements(testPillars[0], testPillars[1], testPillars[2], testPillars[3], testHiddenStems);
            console.log('calculateElements 返回的数据:', elements);
            
            // 直接调用图表显示函数
            console.log('直接调用 displayOriginalElementsChart...');
            displayOriginalElementsChart(elements);
            
            console.log('=== 测试完成 ===');
            return elements;
        };
        
        // 调试当前baziData的函数
        window.debugCurrentBaziData = function() {
            console.log('=== 调试当前baziData ===');
            if (window.currentBaziData && window.currentBaziData.elements) {
                console.log('当前baziData.elements:', window.currentBaziData.elements);
                const total = Object.values(window.currentBaziData.elements).reduce((sum, val) => sum + val, 0);
                console.log('总和:', total.toFixed(2));
                
                // 计算各五行占比
                Object.entries(window.currentBaziData.elements).forEach(([element, value]) => {
                    const percentage = ((value / total) * 100).toFixed(1);
                    console.log(`${element}: ${value.toFixed(2)} (${percentage}%)`);
                });
                
                // 检查数据类型
                console.log('数据类型检查:');
                Object.entries(window.currentBaziData.elements).forEach(([element, value]) => {
                    console.log(`${element}: ${value} (类型: ${typeof value})`);
                });
                
                // 重新显示图表
                console.log('重新显示图表...');
                displayOriginalElementsChart(window.currentBaziData.elements);
            } else {
                console.log('没有找到currentBaziData或elements数据');
            }
            console.log('=== 调试完成 ===');
        };
        
        // 调试图表数据的函数
        window.debugChartData = function() {
            console.log('=== 调试图表数据 ===');
            if (window.originalElementsChart && window.originalElementsChart.data) {
                const chartData = window.originalElementsChart.data.datasets[0].data;
                console.log('图表中的数据:', chartData);
                const chartTotal = chartData.reduce((sum, val) => sum + val, 0);
                console.log('图表数据总和:', chartTotal.toFixed(2));
                
                // 计算图表中各五行占比
                const labels = window.originalElementsChart.data.labels;
                chartData.forEach((value, index) => {
                    const percentage = ((value / chartTotal) * 100).toFixed(1);
                    console.log(`${labels[index]}: ${value.toFixed(2)} (${percentage}%)`);
                });
            } else {
                console.log('没有找到图表数据');
            }
            console.log('=== 调试完成 ===');
        };
        
        // 强制刷新图表的函数
        window.forceRefreshChart = function() {
            console.log('=== 强制刷新图表 ===');
            if (window.currentBaziData && window.currentBaziData.elements) {
                console.log('使用当前baziData.elements刷新图表:', window.currentBaziData.elements);
                
                // 销毁现有图表
                if (window.originalElementsChart) {
                    window.originalElementsChart.destroy();
                }
                
                // 重新创建图表
                displayOriginalElementsChart(window.currentBaziData.elements);
                
                console.log('图表已强制刷新');
            } else {
                console.log('没有可用的baziData.elements数据');
            }
            console.log('=== 刷新完成 ===');
        };

        // 五行关系判断工具函数
        function is_generating(e1, e2) {
            // e1是否能生e2
            return (e1 === '木' && e2 === '火') || (e1 === '火' && e2 === '土') ||
                   (e1 === '土' && e2 === '金') || (e1 === '金' && e2 === '水') ||
                   (e1 === '水' && e2 === '木');
        }
        
        function is_restricting(e1, e2) {
            // e1是否能克e2
            return (e1 === '木' && e2 === '土') || (e1 === '土' && e2 === '水') ||
                   (e1 === '水' && e2 === '火') || (e1 === '火' && e2 === '金') ||
                   (e1 === '金' && e2 === '木');
        }
        
        function is_outputting(e1, e2) {
            // e1是否能泄e2（e2生e1）
            return is_generating(e2, e1);
        }

        // 计算身强身弱
        function calculateStrength(dayStem, elements, monthBranch, passedBranches = [], passedStems = []) {
            // 确保输入是字符串
            dayStem = typeof dayStem === 'string' ? dayStem : String(dayStem);
            monthBranch = typeof monthBranch === 'string' ? monthBranch : String(monthBranch);
            
            // 获取第一个字符作为天干
            dayStem = dayStem.charAt(0);
            // 获取第二个字符作为地支
            monthBranch = monthBranch.length > 1 ? monthBranch.charAt(1) : monthBranch;
            
            const stemElementMap = {
                '甲': 'wood', '乙': 'wood',
                '丙': 'fire', '丁': 'fire',
                '戊': 'earth', '己': 'earth',
                '庚': 'metal', '辛': 'metal',
                '壬': 'water', '癸': 'water'
            };
            
            const dayElement = stemElementMap[dayStem];
            
            // 获取八字中的所有地支
            let allBranches = [];
            try {
                // 从四柱中获取地支
                const pillars = window.currentPillars || {};
                console.log('当前四柱信息:', pillars);
                
                if (pillars.year && pillars.year.length > 1) allBranches.push(pillars.year.charAt(1));
                if (pillars.month && pillars.month.length > 1) allBranches.push(pillars.month.charAt(1));
                if (pillars.day && pillars.day.length > 1) allBranches.push(pillars.day.charAt(1));
                if (pillars.hour && pillars.hour.length > 1) allBranches.push(pillars.hour.charAt(1));
                
                // 如果无法从currentPillars获取，尝试从eightChar获取
                if (allBranches.length === 0) {
                    console.log('尝试从eightChar获取地支');
                    const eightChar = window.eightChar || {};
                    if (eightChar.getYear && typeof eightChar.getYear === 'function') {
                        const year = eightChar.getYear();
                        if (year && year.length > 1) allBranches.push(year.charAt(1));
                    }
                    if (eightChar.getMonth && typeof eightChar.getMonth === 'function') {
                        const month = eightChar.getMonth();
                        if (month && month.length > 1) allBranches.push(month.charAt(1));
                    }
                    if (eightChar.getDay && typeof eightChar.getDay === 'function') {
                        const day = eightChar.getDay();
                        if (day && day.length > 1) allBranches.push(day.charAt(1));
                    }
                    if (eightChar.getTime && typeof eightChar.getTime === 'function') {
                        const time = eightChar.getTime();
                        if (time && time.length > 1) allBranches.push(time.charAt(1));
                    }
                }
            } catch (e) {
                console.error('获取八字地支失败:', e);
            }
            
            // 如果无法从页面获取，则使用传入的月支
            if (allBranches.length === 0 && monthBranch) {
                console.log('使用传入的月支:', monthBranch);
                allBranches.push(monthBranch);
            }
            
            // 打印调试信息
            console.log('八字地支:', allBranches);
            
            // 将地支数组保存到window对象，供其他函数使用
            window.allBranches = allBranches;
            
            // 检查合化情况
            const combined = checkCombinations(dayStem, monthBranch, passedBranches);

            // 保存日主天干到combined对象，供getMonthStrength使用
            combined.dayStem = dayStem;
            
            // 计算月令得分 (权重40%)
            let monthScore = getMonthStrength(dayElement, monthBranch, combined);
            
            console.log(`月令得分计算 - 日主:${dayStem}(${dayElement}), 月支:${monthBranch}, 得分:${monthScore}`);
            
            // 检查土性变化对月令得分的影响（原命局分析）
            if (typeof EarthTransformationCalculator !== 'undefined') {
                const earthCalculator = new EarthTransformationCalculator();
                const earthResult = earthCalculator.analyzeEarthTransformation(passedStems, passedBranches);
                if (earthResult.hasTransformation) {
                    const monthBranchTransformation = earthResult.transformations.find(t => t.branch === monthBranch);
                    if (monthBranchTransformation && monthBranchTransformation.originalElement === 'earth') {
                        const originalScore = monthScore;
                        
                        if (monthBranchTransformation.newElement === 'water') {
                            // 湿土转化为水性
                            if (dayElement === 'earth') {
                                monthScore = -10; // 土日主失去生扶变为克制
                                console.log(`土性变化：${monthBranch}湿土转水性，土日主月令得分调整：${originalScore} → ${monthScore}`);
                            } else if (dayElement === 'fire') {
                                monthScore = -10; // 火日主被克
                                console.log(`土性变化：${monthBranch}湿土转水性，火日主月令得分调整：${originalScore} → ${monthScore}`);
                            } else if (dayElement === 'metal') {
                                monthScore = 20; // 金日主得生
                                console.log(`土性变化：${monthBranch}湿土转水性，金日主月令得分调整：${originalScore} → ${monthScore}`);
                            }
                        } else if (monthBranchTransformation.newElement === 'fire') {
                            // 燥土转化为火性
                            if (dayElement === 'wood') {
                                monthScore = -10; // 木日主被克
                                console.log(`土性变化：${monthBranch}燥土转火性，木日主月令得分调整：${originalScore} → ${monthScore}`);
                            } else if (dayElement === 'earth') {
                                monthScore = 20; // 土日主得生
                                console.log(`土性变化：${monthBranch}燥土转火性，土日主月令得分调整：${originalScore} → ${monthScore}`);
                            } else if (dayElement === 'metal') {
                                monthScore = -10; // 金日主被克
                                console.log(`土性变化：${monthBranch}燥土转火性，金日主月令得分调整：${originalScore} → ${monthScore}`);
                            }
                        } else if (monthBranchTransformation.transformationType === 'weakened') {
                            // 土性减弱
                            if (dayElement === 'earth') {
                                monthScore = Math.round(monthScore * 0.5); // 土日主生扶减半
                                console.log(`土性变化：${monthBranch}土性减弱，土日主月令得分调整：${originalScore} → ${monthScore}`);
                            } else if (dayElement === 'fire') {
                                monthScore = Math.round(monthScore * 0.7); // 火日主泄身减弱
                                console.log(`土性变化：${monthBranch}土性减弱，火日主月令得分调整：${originalScore} → ${monthScore}`);
                            } else if (dayElement === 'metal') {
                                monthScore = Math.round(monthScore * 0.7); // 金日主得生减弱
                                console.log(`土性变化：${monthBranch}土性减弱，金日主月令得分调整：${originalScore} → ${monthScore}`);
                            }
                        }
                    }
                }
            }
            
            // 使用增强版五行计算（包含土性变化和三合局影响）
            let enhancedResult = null;
            if (typeof EarthTransformationCalculator !== 'undefined') {
                const earthCalculator = new EarthTransformationCalculator();
                
                // 获取所有天干地支
                let allStems = [];
                let allBranches = [];
                
                try {
                    const pillars = window.currentPillars || {};
                    if (pillars.year && pillars.year.length > 1) {
                        allStems.push(pillars.year.charAt(0));
                        allBranches.push(pillars.year.charAt(1));
                    }
                    if (pillars.month && pillars.month.length > 1) {
                        allStems.push(pillars.month.charAt(0));
                        allBranches.push(pillars.month.charAt(1));
                    }
                    if (pillars.day && pillars.day.length > 1) {
                        allStems.push(pillars.day.charAt(0));
                        allBranches.push(pillars.day.charAt(1));
                    }
                    if (pillars.hour && pillars.hour.length > 1) {
                        allStems.push(pillars.hour.charAt(0));
                        allBranches.push(pillars.hour.charAt(1));
                    }
                } catch (e) {
                    console.error('获取八字信息失败:', e);
                    // 使用传入的参数作为备选
                    if (passedStems && passedStems.length > 0) allStems = passedStems;
                    if (passedBranches && passedBranches.length > 0) allBranches = passedBranches;
                }
                
                // 定义精细化地支藏干映射
                const BRANCH_ELEMENTS = {
                    '子': {main: 'water', hidden: ['癸']},
                    '丑': {main: 'earth', hidden: ['己', '癸', '辛']},
                    '寅': {main: 'wood', hidden: ['甲', '丙', '戊']},
                    '卯': {main: 'wood', hidden: ['乙']},
                    '辰': {main: 'earth', hidden: ['戊', '乙', '癸']},
                    '巳': {main: 'fire', hidden: ['丙', '庚', '戊']},
                    '午': {main: 'fire', hidden: ['丁', '己']},
                    '未': {main: 'earth', hidden: ['己', '丁', '乙']},
                    '申': {main: 'metal', hidden: ['庚', '壬', '戊']},
                    '酉': {main: 'metal', hidden: ['辛']},
                    '戌': {main: 'earth', hidden: ['戊', '辛', '丁']},
                    '亥': {main: 'water', hidden: ['壬', '甲']}
                };
                
                // 精细化计算藏干权重
                const refinedElements = { ...elements };
                allBranches.forEach((branch, branchIndex) => {
                    const branchInfo = BRANCH_ELEMENTS[branch];
                    if (branchInfo && branchInfo.hidden) {
                        branchInfo.hidden.forEach((hiddenStem, stemIndex) => {
                            const element = stemElementMap[hiddenStem];
                            if (element) {
                                // 藏干权重递减：主气0.6，次气0.4，余气0.2
                                const baseWeight = stemIndex === 0 ? 0.6 : (stemIndex === 1 ? 0.4 : 0.2);
                                // 日支权重稍高
                                const positionWeight = branchIndex === 2 ? 1.2 : 1.0;
                                const finalWeight = baseWeight * positionWeight;
                                refinedElements[element] += finalWeight;
                                console.log(`精细化藏干：${branch}藏${hiddenStem}(${element}) +${finalWeight.toFixed(2)}`);
                            }
                        });
                    }
                });
                
                // 使用增强版五行计算
                enhancedResult = earthCalculator.calculateEnhancedElements(allStems, allBranches, BRANCH_ELEMENTS);
                
                // 更新五行分布为增强版计算结果
                Object.keys(enhancedResult.elements).forEach(element => {
                    elements[element] = enhancedResult.elements[element];
                });
                
                console.log('=== calculateStrength中的增强版五行计算结果 ===');
                console.log('土性变化分析:', enhancedResult.earthTransformation);
                console.log('三合局分析:', enhancedResult.tripleAnalysis);
                console.log('调整信息:', enhancedResult.adjustments);
                console.log('最终五行分布:', elements);
            }
            
            // 计算生扶力量（生我、助我）
            const supportElements = getSupportElements(dayElement);
            let supportStrength = 0;
            supportElements.forEach(element => {
                supportStrength += elements[element];
            });
            
            // 计算克泄力量（克我、泄我、耗我）
            const weakenElements = getWeakenElements(dayElement);
            let weakenStrength = 0;
            weakenElements.forEach(element => {
                weakenStrength += elements[element];
            });
            
            console.log(`初始计算 - 生扶力量:${supportStrength}, 克泄力量:${weakenStrength}`);
            
            // 将月令得分转换为力量点数并加入计算
            if (monthScore > 0) {
                // 正分加入生扶力量
                supportStrength += monthScore / 10; // 月令得分除以10转换为力量点数
                console.log(`月令得分${monthScore}分转换为生扶力量: +${monthScore / 10}`);
            } else if (monthScore < 0) {
                // 负分加入克泄力量
                weakenStrength += Math.abs(monthScore) / 10;
                console.log(`月令得分${monthScore}分转换为克泄力量: +${Math.abs(monthScore) / 10}`);
            }
            
            console.log(`加入月令得分后 - 生扶力量:${supportStrength}, 克泄力量:${weakenStrength}`);
            
            // 统一处理所有合化的加减分
            let combinationSupportStrength = 0; // 合化增强的力量
            let combinationWeakenStrength = 0;  // 合化削弱的力量
            const combinationTypes = ['tianGanWuHe', 'diZhiLiuHe', 'diZhiSanHe', 'diZhiSanHui'];
            combinationTypes.forEach(type => {
                if (!combined[type]) return; // 如果该类型不存在，跳过
                combined[type].forEach(comb => {
                    const heElement = comb.element;
                    // 专业命理评分规则 - 按照传统命理重要性排序
                    const SCORE_RULES = {
                        'diZhiSanHui': 8,  // 三会局8分（能量最强）
                        'diZhiSanHe': 6,   // 三合局6分（全三合）
                        'diZhiLiuHe': 3,   // 六合局3分
                        'tianGanWuHe': 2   // 天干合2分（需通根验证）
                    };
                    let multiplier = SCORE_RULES[type];
                    
                    // 半三合能量减弱：只有2个地支的三合局能量减半
                    if (type === 'diZhiSanHe' && comb.count === 2) {
                        multiplier = 3; // 半三合3分，比全三合6分减半
                        console.log(`半三合${comb.type}能量减弱，分数调整为${multiplier}分`);
                    }

                    // 天干合化专业规则检查
                    if(type === 'tianGanWuHe') {
                        // 检查是否为绊合（只合不化）
                        if (comb.onlyBind) {
                            // 绊合：双方力量减弱但性质不变，减少原有力量
                            const bindReduction = 1; // 绊合减少1分力量
                            
                            // 从原有五行力量中扣除
                            const stem1Element = stemElementMap[comb.gan1];
                            const stem2Element = stemElementMap[comb.gan2];
                            
                            if (getSupportElements(dayElement).includes(stem1Element)) {
                                supportStrength -= bindReduction * 0.5;
                                console.log(`天干绊合 ${comb.gan1}${comb.gan2} 减弱生扶力量 ${bindReduction * 0.5}`);
                            } else if (getWeakenElements(dayElement).includes(stem1Element)) {
                                weakenStrength -= bindReduction * 0.5;
                                console.log(`天干绊合 ${comb.gan1}${comb.gan2} 减弱克泄力量 ${bindReduction * 0.5}`);
                            }
                            
                            if (getSupportElements(dayElement).includes(stem2Element)) {
                                supportStrength -= bindReduction * 0.5;
                            } else if (getWeakenElements(dayElement).includes(stem2Element)) {
                                weakenStrength -= bindReduction * 0.5;
                            }
                            
                            console.log(`天干${comb.gan1}${comb.gan2}绊合：${comb.bindReason}，双方力量减弱`);
                            return; // 绊合不产生新的五行力量
                        }
                        
                        // 合化成功：按新的五行性质计算
                        console.log(`天干${comb.gan1}${comb.gan2}合化${heElement}成功：${comb.supportType}`);
                    }

                    // 地支合化天干透出检查 - 如果天干透出合化后的五行，能量加倍
                    if((type === 'diZhiLiuHe' || type === 'diZhiSanHe' || type === 'diZhiSanHui') && comb.hasTransparent) {
                        multiplier *= 1.5; // 透出时能量增加50%
                        console.log(`${type} 天干透出${heElement}，能量增强至 ${multiplier}`);
                    }

                    if (getSupportElements(dayElement).includes(heElement)) {
                        supportStrength += multiplier;
                        combinationSupportStrength += multiplier;
                        console.log(`${type} ${comb.gan1 || comb.zhi1 || comb.type || comb.branches} 合化${heElement} 生助日主，增加生扶 ${multiplier}`);
                    } else if (getWeakenElements(dayElement).includes(heElement)) {
                        weakenStrength += multiplier;
                        combinationWeakenStrength += multiplier;
                        console.log(`${type} ${comb.gan1 || comb.zhi1 || comb.type || comb.branches} 合化${heElement} 克泄日主，增加克泄 ${multiplier}`);
                    } else {
                        console.log(`${type} ${comb.gan1 || comb.zhi1 || comb.type || comb.branches} 合化${heElement} 中性影响`);
                    }
                });
            });
            
            // 计算合化的净影响
            const netCombinationEffect = combinationSupportStrength - combinationWeakenStrength;
            combined.deduction = netCombinationEffect;
            
            // 设置整体effect
            if (netCombinationEffect > 0) {
                combined.effect = 'strengthen';
            } else if (netCombinationEffect < 0) {
                combined.effect = 'weaken';
            } else {
                combined.effect = 'neutral';
            }
            
            // 确保合化信息显示在界面上
            window.combinedInfo = combined;
            
            // 移除通用effect调整，已在具体合化中处理
            
            // 三合加减已在统一处理中完成，保留特别处理
            if (combined.hasOwnProperty('sanhe')) {
                if (combined.sanhe.type === '巳酉丑' && dayStem === '己') {
                    weakenStrength += 3;
                    console.log('巳酉丑三合金对己土日主的特殊影响，额外增加克泄力量 3');
                }
            }
            
            // 计算总分
            const totalScore = monthScore + supportStrength - weakenStrength;
            
            // 判断身强身弱
            const strengthRatio = supportStrength / (supportStrength + weakenStrength);
            
            // 打印调试信息
            console.log(`身强身弱计算 - 日主:${dayStem}(${dayElement}), 生扶力量:${supportStrength}, 克泄力量:${weakenStrength}, 比例:${(strengthRatio * 100).toFixed(2)}%, 月令得分:${monthScore}`);
            
            let type, description;
            
            // 判断是否从格（传入三合局分析信息）
            const tripleAnalysis = enhancedResult ? enhancedResult.tripleAnalysis : null;
            const isFollowing = checkFollowingPattern(dayElement, monthBranch, strengthRatio, supportStrength, weakenStrength, monthScore, tripleAnalysis);
            
            // 使用EarthTransformationCalculator的analyzeCongGe方法进行更精确的从格判断
            let finalIsFollowing = isFollowing;
            const earthCalculator = new EarthTransformationCalculator();
            console.log(`earthCalculator存在:`, !!earthCalculator);
            console.log(`enhancedResult存在:`, !!enhancedResult);
            console.log(`enhancedResult内容:`, enhancedResult);
            
            if (earthCalculator && enhancedResult) {
                const totalStrength = supportStrength + weakenStrength;
                const supportRatio = totalStrength > 0 ? supportStrength / totalStrength : 0;
                console.log(`从格判断调试 - 生扶力量:${supportStrength}, 克泄力量:${weakenStrength}, 总力量:${totalStrength}, 支持比例:${(supportRatio * 100).toFixed(2)}%`);
                
                const congGeResult = earthCalculator.analyzeCongGe(supportRatio, enhancedResult);
                console.log(`analyzeCongGe结果:`, congGeResult);
                
                // 如果analyzeCongGe判断为从格且置信度较高，优先使用其结果
                if (congGeResult.isCongGe && congGeResult.confidence > 0.1) {
                    finalIsFollowing = {
                        isFollowing: true,
                        type: congGeResult.type,
                        description: `EarthTransformationCalculator判断：${congGeResult.reason}，置信度：${(congGeResult.confidence * 100).toFixed(1)}%`
                    };
                    console.log(`原命局从格判断优化：使用EarthTransformationCalculator结果 - ${congGeResult.type}，置信度：${(congGeResult.confidence * 100).toFixed(1)}%`);
                } else {
                    console.log(`analyzeCongGe未生效 - isCongGe:${congGeResult.isCongGe}, confidence:${(congGeResult.confidence * 100).toFixed(1)}%`);
                }
            }
            
            // 使用12级身强身弱分类系统
            console.log(`最终从格判断状态:`, finalIsFollowing);
            const strengthPercentage = strengthRatio * 100; // 转换为百分比
            console.log(`传入calculateStrengthLevel的参数 - strengthRatio: ${strengthRatio}, strengthPercentage: ${strengthPercentage}`);
            const strengthLevel = calculateStrengthLevel(strengthPercentage, supportStrength, weakenStrength, monthScore, finalIsFollowing, dayElement, monthBranch);
            type = strengthLevel.type;
            description = strengthLevel.description;
            console.log(`最终身强身弱判断结果: ${type}，基于strengthPercentage: ${strengthPercentage}%`);
            
            // 特殊情况：只有在极端情况下才强制判断为身弱（条件更严格）
            if (!finalIsFollowing.isFollowing && monthScore < -20 && supportStrength < weakenStrength * 0.5 && strengthPercentage > 15) {
                type = '身弱';
                description = '日主在月令严重失势，生扶力量极度不足，判断为身弱，喜用印比。';
                console.log(`特殊修正：月令得分${monthScore}，生扶${supportStrength}<克泄${weakenStrength}*0.5，强制判断为身弱`);
            }
            
            return {
                type: type,
                ratio: strengthRatio,
                supportStrength: supportStrength,
                weakenStrength: weakenStrength,
                description: description,
                monthScore: monthScore,
                totalScore: totalScore,
                combined: combined
            };
        }
        
        // 12级身强身弱分类函数
        function calculateStrengthLevel(strengthRatio, supportStrength, weakenStrength, monthScore, isFollowing, dayElement, monthBranch, isCurrent = false) {
            const prefix = isCurrent ? '加入当前大运和流年后，' : '';
            
            // 如果是从格，直接返回从格类型
            if (isFollowing.isFollowing) {
                return {
                    level: isFollowing.type === '从强' ? 12 : 1,
                    type: isFollowing.type,
                    description: prefix + isFollowing.description
                };
            }
            
            // 计算综合强度指标
            const totalStrength = supportStrength + weakenStrength;
            // 注意：第一个参数现在已经是百分比值，不需要再乘以100
            const strengthPercentage = strengthRatio; // strengthRatio现在实际上是strengthPercentage
            
            // 考虑绝对力量值
            const hasStrongSupport = supportStrength >= 15;
            const hasWeakSupport = supportStrength <= 5;
            const hasStrongWeaken = weakenStrength >= 15;
            
            let level, type, description;
            
            // 12级分类判断（基于原始力量比例）
            if (strengthPercentage <= 8 && hasWeakSupport) {
                level = 1;
                type = '极弱（从弱）';
                description = prefix + '日主无根无气，全局克泄耗，应顺从克泄耗的力量，忌生扶。';
            } else if (strengthPercentage <= 15) {
                level = 2;
                type = '很弱';
                description = prefix + '仅得微根或一气相助，力量微弱，急需印比生扶。';
            } else if (strengthPercentage <= 25) {
                level = 3;
                type = '较弱';
                description = prefix + '得一根或一助但被制，力量不足，喜印比忌财官。';
            } else if (strengthPercentage <= 35) {
                level = 4;
                type = '稍弱';
                description = prefix + '得令但失势，或得势但失令，力量稍显不足，宜生扶。';
            } else if (strengthPercentage <= 42) {
                level = 5;
                type = '微弱';
                description = prefix + '基本平衡但略偏弱，需要适度生扶，忌过度克泄。';
            } else if (strengthPercentage <= 48) {
                level = 6;
                type = '中和偏弱';
                description = prefix + '接近平衡但稍弱，运势较为平稳，喜印比助身。';
            } else if (strengthPercentage >= 52 && strengthPercentage <= 58) {
                level = 7;
                type = '真正中和';
                description = prefix + '五行流通平衡，极为罕见的中和之命，顺其自然最佳。';
            } else if (strengthPercentage <= 62) {
                level = 8;
                type = '中和偏强';
                description = prefix + '接近平衡但稍强，运势平稳，可适度用财官。';
            } else if (strengthPercentage <= 68) {
                level = 9;
                type = '微强';
                description = prefix + '基本平衡但略偏强，可承担一定财官，忌过度生扶。';
            } else if (strengthPercentage <= 75) {
                level = 10;
                type = '稍强';
                description = prefix + '得令或得势明显，力量较强，喜财官食伤泄秀。';
            } else if (strengthPercentage <= 85) {
                level = 11;
                type = '较强';
                description = prefix + '得令得势，根气足，力量强旺，宜用财官制约。';
            } else {
                level = 12;
                type = '极强（专旺）';
                description = prefix + '全局同一五行主导，专旺格局，顺其旺势，忌逆其性。';
            }
            
            // 特殊调整：考虑月令失势的情况
            if (monthScore < -15 && level > 4) {
                level = Math.max(1, level - 2);
                type = getTypeByLevel(level);
                description = prefix + '月令严重失势，' + getDescriptionByLevel(level, prefix);
            }
            
            // 特殊调整：考虑生扶力量绝对值
            if (hasWeakSupport && level > 3) {
                level = Math.min(3, level);
                type = getTypeByLevel(level);
                description = prefix + '生扶力量绝对不足，' + getDescriptionByLevel(level, prefix);
            }
            
            return {
                level: level,
                type: type,
                description: description,
                adjustedPercentage: strengthPercentage
            };
        }
        
        // 根据等级获取类型
        function getTypeByLevel(level) {
            const types = {
                1: '极弱（从弱）',
                2: '很弱',
                3: '较弱',
                4: '稍弱',
                5: '微弱',
                6: '中和偏弱',
                7: '真正中和',
                8: '中和偏强',
                9: '微强',
                10: '稍强',
                11: '较强',
                12: '极强（专旺）'
            };
            return types[level] || '未知';
        }
        
        // 根据等级获取描述
        function getDescriptionByLevel(level, prefix = '') {
            const descriptions = {
                1: '日主无根无气，全局克泄耗，应顺从克泄耗的力量，忌生扶。',
                2: '仅得微根或一气相助，力量微弱，急需印比生扶。',
                3: '得一根或一助但被制，力量不足，喜印比忌财官。',
                4: '得令但失势，或得势但失令，力量稍显不足，宜生扶。',
                5: '基本平衡但略偏弱，需要适度生扶，忌过度克泄。',
                6: '接近平衡但稍弱，运势较为平稳，喜印比助身。',
                7: '五行流通平衡，极为罕见的中和之命，顺其自然最佳。',
                8: '接近平衡但稍强，运势平稳，可适度用财官。',
                9: '基本平衡但略偏强，可承担一定财官，忌过度生扶。',
                10: '得令或得势明显，力量较强，喜财官食伤泄秀。',
                11: '得令得势，根气足，力量强旺，宜用财官制约。',
                12: '全局同一五行主导，专旺格局，顺其旺势，忌逆其性。'
            };
            return descriptions[level] || '力量状态未知。';
        }

        // 全局地支藏干映射（供合化判断共用）
        const BRANCH_ELEMENTS = {
            '子': {main: 'water', hidden: ['癸']},
            '丑': {main: 'earth', hidden: ['己', '癸', '辛']},
            '寅': {main: 'wood', hidden: ['甲', '丙', '戊']},
            '卯': {main: 'wood', hidden: ['乙']},
            '辰': {main: 'earth', hidden: ['戊', '乙', '癸']},
            '巳': {main: 'fire', hidden: ['丙', '庚', '戊']},
            '午': {main: 'fire', hidden: ['丁', '己']},
            '未': {main: 'earth', hidden: ['己', '丁', '乙']},
            '申': {main: 'metal', hidden: ['庚', '壬', '戊']},
            '酉': {main: 'metal', hidden: ['辛']},
            '戌': {main: 'earth', hidden: ['戊', '辛', '丁']},
            '亥': {main: 'water', hidden: ['壬', '甲']}
        };

        // 检查合化情况
        function checkCombinations(dayStem, monthBranch, branches) {
            const combined = {
                tianGanWuHe: [],
                diZhiLiuHe: [],
                diZhiSanHe: [],
                deduction: 0 // 合化扣分
            };
            
            const stemElementMap = {
                '甲': 'wood', '乙': 'wood',
                '丙': 'fire', '丁': 'fire',
                '戊': 'earth', '己': 'earth',
                '庚': 'metal', '辛': 'metal',
                '壬': 'water', '癸': 'water'
            };
            
            // 天干五合规则
            const tianGanHeHua = {
                '甲己': 'earth',
                '乙庚': 'metal',
                '丙辛': 'water',
                '丁壬': 'wood',
                '戊癸': 'fire'
            };
            
            // 地支六合规则
            const diZhiLiuHe = {
                '子丑': 'earth',
                '寅亥': 'wood',
                '卯戌': 'fire',
                '辰酉': 'metal',
                '巳申': 'water',
                '午未': 'earth'
            };
            
            // 地支三合规则
            const diZhiSanHe = [
                {branches: ['申', '子', '辰'], element: 'water'}, // 三合水局
                {branches: ['亥', '卯', '未'], element: 'wood'},  // 三合木局
                {branches: ['寅', '午', '戌'], element: 'fire'},  // 三合火局
                {branches: ['巳', '酉', '丑'], element: 'metal'}  // 三合金局
            ];
            
            // 获取八字四柱
            let allStems = [];
            let allBranches = [];
            
            try {
                const pillars = window.currentPillars || {};
                if (pillars.year) {
                    allStems.push(pillars.year.charAt(0));
                    allBranches.push(pillars.year.charAt(1));
                }
                if (pillars.month) {
                    allStems.push(pillars.month.charAt(0));
                    allBranches.push(pillars.month.charAt(1));
                }
                if (pillars.day) {
                    allStems.push(pillars.day.charAt(0));
                    allBranches.push(pillars.day.charAt(1));
                }
                if (pillars.hour) {
                    allStems.push(pillars.hour.charAt(0));
                    allBranches.push(pillars.hour.charAt(1));
                }
            } catch (e) {
                console.error('获取八字信息失败:', e);
            }
            
            // 检查天干是否透出指定五行的辅助函数
            function checkTransparentElement(element, stems) {
                const elementToStems = {
                    'wood': ['甲', '乙'],
                    'fire': ['丙', '丁'],
                    'earth': ['戊', '己'],
                    'metal': ['庚', '辛'],
                    'water': ['壬', '癸']
                };
                
                const targetStems = elementToStems[element] || [];
                return stems.some(stem => targetStems.includes(stem));
            }
            
            // 检查地支是否支持天干合化的专业函数
            function checkHehuaSupport(hehuaElement, allBranches, monthBranch) {
                // 定义各五行对应的强根地支
                const elementStrongRoots = {
                    'earth': ['辰', '戌', '丑', '未'], // 土的强根
                    'metal': ['申', '酉', '戌', '丑'], // 金的强根
                    'water': ['亥', '子', '丑', '辰'], // 水的强根
                    'wood': ['寅', '卯', '辰', '未'], // 木的强根
                    'fire': ['巳', '午', '未', '戌']  // 火的强根
                };
                
                // 定义月令旺衰影响
                const monthElementMap = {
                    '子': 'water', '丑': 'earth', '寅': 'wood', '卯': 'wood',
                    '辰': 'earth', '巳': 'fire', '午': 'fire', '未': 'earth',
                    '申': 'metal', '酉': 'metal', '戌': 'earth', '亥': 'water'
                };
                
                const strongRoots = elementStrongRoots[hehuaElement] || [];
                const monthElement = monthElementMap[monthBranch];
                
                // 检查地支中是否有强根支撑
                const hasStrongRoot = allBranches.some(branch => strongRoots.includes(branch));
                
                // 检查月令是否有利于合化
                const monthSupport = monthElement === hehuaElement;
                const monthOppose = getOpposingElement(hehuaElement) === monthElement;
                
                // 合化成功的条件判断
                if (hasStrongRoot && monthSupport) {
                    return {
                        canHehua: true,
                        type: '地支强根+月令旺',
                        details: `地支有${strongRoots.filter(root => allBranches.includes(root)).join('、')}强根，月令${monthBranch}助旺${getElementChinese(hehuaElement)}`
                    };
                } else if (hasStrongRoot && !monthOppose) {
                    return {
                        canHehua: true,
                        type: '地支强根支撑',
                        details: `地支有${strongRoots.filter(root => allBranches.includes(root)).join('、')}强根支撑${getElementChinese(hehuaElement)}`
                    };
                } else if (monthSupport && allBranches.filter(branch => strongRoots.includes(branch)).length >= 2) {
                    return {
                        canHehua: true,
                        type: '月令旺+多重根',
                        details: `月令${monthBranch}旺${getElementChinese(hehuaElement)}，地支多重根气支撑`
                    };
                } else {
                    let reason = '';
                    if (!hasStrongRoot) {
                        reason += `地支无${getElementChinese(hehuaElement)}强根`;
                    }
                    if (monthOppose) {
                        reason += (reason ? '，' : '') + `月令${monthBranch}克制${getElementChinese(hehuaElement)}`;
                    }
                    if (!monthSupport && !hasStrongRoot) {
                        reason = `地支无强根且月令不助`;
                    }
                    
                    return {
                        canHehua: false,
                        reason: reason || '条件不足'
                    };
                }
            }
            
            // 将函数暴露到全局作用域，供其他函数调用
            window.checkHehuaSupport = checkHehuaSupport;
            
            // 获取五行中文名称
            function getElementChinese(element) {
                const elementNames = {
                    'wood': '木', 'fire': '火', 'earth': '土', 'metal': '金', 'water': '水'
                };
                return elementNames[element] || element;
            }
            
            // 获取相克的五行
            function getOpposingElement(element) {
                const opposingMap = {
                    'wood': 'metal',  // 金克木
                    'fire': 'water',  // 水克火
                    'earth': 'wood',  // 木克土
                    'metal': 'fire',  // 火克金
                    'water': 'earth'  // 土克水
                };
                return opposingMap[element];
            }
            
            // 检查争合和妒合情况
            const hehuaConflicts = new Map(); // 记录每个天干的合化对象
            const stemCounts = {}; // 统计每个天干出现次数
            const processedPairs = new Set(); // 记录已处理的合化对，避免重复计算
            
            // 统计天干出现次数（用于检查妒合）
            allStems.forEach(stem => {
                stemCounts[stem] = (stemCounts[stem] || 0) + 1;
            });
            
            console.log('天干统计:', stemCounts);
            console.log('天干序列:', allStems);
            
            // 检查相邻天干五合（本命局专用：必须相邻且地支有根）
            for (let i = 0; i < allStems.length - 1; i++) {
                const stem1 = allStems[i];
                const stem2 = allStems[i + 1];
                const pair1 = stem1 + stem2;
                const pair2 = stem2 + stem1;
                const pairKey = [stem1, stem2].sort().join(''); // 标准化的配对键
                
                if (tianGanHeHua[pair1] || tianGanHeHua[pair2]) {
                    const hehuaElement = tianGanHeHua[pair1] || tianGanHeHua[pair2];
                    
                    // 检查争合和妒合
                    let hasConflict = false;
                    let conflictType = '';
                    
                    // 检查争合：一天干与相邻两天干相合
                    if (hehuaConflicts.has(stem1)) {
                        hasConflict = true;
                        conflictType = `争合：${stem1}同时与${hehuaConflicts.get(stem1)}和${stem2}相合`;
                    }
                    if (hehuaConflicts.has(stem2)) {
                        hasConflict = true;
                        conflictType = `争合：${stem2}同时与${hehuaConflicts.get(stem2)}和${stem1}相合`;
                    }
                    
                    // 检查妒合：两相同天干争合一天干
                    if (stemCounts[stem1] > 1 || stemCounts[stem2] > 1) {
                        hasConflict = true;
                        const repeatStem = stemCounts[stem1] > 1 ? stem1 : stem2;
                        conflictType = `妒合：${repeatStem}重复出现${stemCounts[repeatStem]}次争合`;
                        console.log(`发现妒合：${repeatStem}重复${stemCounts[repeatStem]}次`);
                    }
                    
                    // 如果已经处理过这个配对，跳过（避免重复计算争合）
                    if (processedPairs.has(pairKey)) {
                        console.log(`跳过重复配对：${stem1}${stem2}`);
                        continue;
                    }
                    processedPairs.add(pairKey);
                    
                    // 记录合化关系
                    hehuaConflicts.set(stem1, stem2);
                    hehuaConflicts.set(stem2, stem1);
                    
                    // 本命局天干五合：使用统一的通根检查逻辑（与checkCurrentCombinations保持一致）
                    const branch1 = allBranches[i];
                    const branch2 = allBranches[i + 1];
                    
                    // 使用checkHehuaSupport进行统一的通根和季节支持检查
                    const rootInfo = checkHehuaSupport(hehuaElement, [branch1, branch2], monthBranch);
                    const hasRoot = rootInfo.canHehua;
                    const rootDetails = rootInfo.details || rootInfo.reason || '';
                    
                    // 本命局要求更严格：必须有地支通根且季节支持，且无争合妒合
                    let finalCanHehua = hasRoot && !hasConflict;
                    let finalReason = '';
                    
                    if (hasConflict) {
                        finalReason = conflictType + '，合化失败';
                        console.log(`合化失败：${stem1}${stem2} - ${conflictType}`);
                    } else if (!hasRoot) {
                        finalReason = `地支无通根：${rootDetails}`;
                        console.log(`天干五合无通根：${stem1}${stem2} - ${rootDetails}`);
                    }
                    
                    if (finalCanHehua) {
                        combined.tianGanWuHe.push({
                            gan1: stem1,
                            gan2: stem2,
                            element: hehuaElement,
                            positions: [i, i + 1],
                            isAdjacent: true,
                            hasRoot: hasRoot,
                            rootDetails: rootDetails,
                            strengthType: rootInfo.type,
                            supportDetails: rootInfo.details,
                            hasConflict: hasConflict,
                            conflictType: hasConflict ? conflictType : null,
                            type: '本命局合化'
                        });
                        console.log(`本命局天干五合成功: ${stem1}${stem2} 合化为${hehuaElement}（相邻+通根：${rootDetails}）`);
                    } else {
                        // 只合不化，作为绊合处理
                        combined.tianGanWuHe.push({
                            gan1: stem1,
                            gan2: stem2,
                            element: hehuaElement,
                            positions: [i, i + 1],
                            isAdjacent: true,
                            onlyBind: true,
                            bindReason: finalReason,
                            hasConflict: hasConflict,
                            conflictType: hasConflict ? conflictType : null,
                            type: '本命局绊合'
                        });
                        console.log(`本命局天干绊合: ${stem1}${stem2} 只合不化（${finalReason}）`);
                    }
                }
            }
            
            // 检查相邻地支六合（修复版：添加严格的相邻性和透出检查）
            console.log('检查地支六合，地支数组:', allBranches);
            
            // 定义地支的顺序位置（用于检查真正的相邻性）
            const branchOrder = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
            
            // 检查是否为真正相邻的地支（在十二地支顺序中相邻）
            function isAdjacentBranches(branch1, branch2) {
                const index1 = branchOrder.indexOf(branch1);
                const index2 = branchOrder.indexOf(branch2);
                if (index1 === -1 || index2 === -1) return false;
                
                // 检查是否相邻（包括子亥相邻的情况）
                const diff = Math.abs(index1 - index2);
                return diff === 1 || diff === 11; // 相邻或者子亥相邻
            }
            
            for (let i = 0; i < allBranches.length - 1; i++) {
                const branch1 = allBranches[i];
                const branch2 = allBranches[i+1];
                const pair1 = branch1 + branch2;
                const pair2 = branch2 + branch1;
                console.log(`检查地支对: ${branch1}${branch2} (${pair1}) 和 ${branch2}${branch1} (${pair2})`);
                
                if (diZhiLiuHe[pair1] || diZhiLiuHe[pair2]) {
                    const hehuaElement = diZhiLiuHe[pair1] || diZhiLiuHe[pair2];
                    
                    // 严格检查：必须在八字中相邻且在地支顺序中也相邻
                    const isPositionAdjacent = true; // 在八字中已经是相邻位置
                    const isBranchAdjacent = isAdjacentBranches(branch1, branch2);
                    
                    if (!isBranchAdjacent) {
                        console.log(`❌ 地支六合失败: ${branch1}${branch2} - 地支不相邻，不能合化`);
                        continue;
                    }
                    
                    // 检查天干是否透出合化后的五行（六合成功的必要条件）
                    const hasTransparent = checkTransparentElement(hehuaElement, allStems);
                    
                    if (!hasTransparent) {
                        console.log(`❌ 地支六合失败: ${branch1}${branch2} 合${getElementChinese(hehuaElement)} - 天干没有${getElementChinese(hehuaElement)}透出`);
                        // 记录为绊合而非合化
                        combined.diZhiLiuHe.push({
                            zhi1: branch1,
                            zhi2: branch2,
                            element: hehuaElement,
                            positions: [i, i+1],
                            hasTransparent: false,
                            onlyBind: true,
                            bindReason: `天干没有${getElementChinese(hehuaElement)}透出`
                        });
                        continue;
                    }
                    
                    // 六合成功
                    combined.diZhiLiuHe.push({
                        zhi1: branch1,
                        zhi2: branch2,
                        element: hehuaElement,
                        positions: [i, i+1],
                        hasTransparent: hasTransparent,
                        isAdjacent: true
                    });
                    
                    // 如果月支（位置1）参与六合，更新月令元素
                    if (i === 1 || i+1 === 1) {
                        combined.monthElement = hehuaElement;
                        console.log(`月支参与六合: ${branch1}${branch2} 合化为${getElementChinese(hehuaElement)}，月令元素更新为${hehuaElement}`);
                    }
                    
                    console.log(`✅ 地支六合成功: ${branch1}${branch2} 合化为${getElementChinese(hehuaElement)}（相邻+天干透出）`);
                }
            }
            
            // 保存地支数组供三合检测使用
            window.allBranches = allBranches;
            
            const elementMap = {
                'wood': '木',
                'fire': '火',
                'earth': '土',
                'metal': '金',
                'water': '水'
            };
            
            // 检查地支三合（修复版：与checkCurrentCombinations保持一致的严格验证）
            if (allBranches && allBranches.length >= 2) {
                console.log('检查三合局（修复版），地支:', allBranches);
                
                // 使用与checkCurrentCombinations相同的验证逻辑
                diZhiSanHe.forEach(sanhe => {
                    const matches = [];
                    const requiredBranches = sanhe.branches;
                    
                    // 严格检查：首先验证所有必需的地支是否都存在
                    const existingBranches = [];
                    requiredBranches.forEach(branch => {
                        const indices = allBranches.map((b, i) => b === branch ? i : -1).filter(i => i !== -1);
                        if (indices.length > 0) {
                            matches.push({branch, indices});
                            existingBranches.push(branch);
                        }
                    });
                    
                    // 验证半三合的有效性
                    const isValidPartialCombination = (existing) => {
                        if (existing.length < 2) return false;
                        if (existing.length >= 3) return true; // 全三合
                        
                        // 对于半三合，必须确保存在的地支确实属于同一个三合局
                        const validPartialCombos = {
                            '申子辰': [['申', '子'], ['子', '辰'], ['申', '辰']],
                            '亥卯未': [['亥', '卯'], ['卯', '未']], // 移除亥未组合
                            '寅午戌': [['寅', '午'], ['午', '戌'], ['寅', '戌']],
                            '巳酉丑': [['巳', '酉'], ['酉', '丑'], ['巳', '丑']]
                        };
                        
                        const comboKey = requiredBranches.join('');
                        const validCombos = validPartialCombos[comboKey] || [];
                        
                        const currentCombo = existing.sort();
                        return validCombos.some(validCombo => {
                            const sortedValid = validCombo.sort();
                            return currentCombo.length === sortedValid.length && 
                                   currentCombo.every((branch, index) => branch === sortedValid[index]);
                        });
                    };
                    
                    console.log(`检查三合局 ${requiredBranches.join('')}:`, {
                        required: requiredBranches,
                        found: matches.map(m => m.branch),
                        allBranches: allBranches,
                        foundCount: matches.length
                    });
                    
                    // 严格要求：使用新的验证逻辑检查三合局的有效性
                    const hasValidBranchCombination = matches.length === 3 || 
                        (matches.length === 2 && isValidPartialCombination(existingBranches));
                    
                    if (hasValidBranchCombination && matches.length >= 2) {
                        // 严格的相邻性检查：确保地支在八字中真正相邻
                        let isValidAdjacency = false;
                        let sanheStartIndex = -1;
                        
                        if (matches.length === 3) {
                            // 全三合：必须有连续的三个位置，且三个地支都存在
                            const allPositions = [];
                            matches.forEach(match => {
                                allPositions.push(...match.indices);
                            });
                            allPositions.sort((a, b) => a - b);
                            
                            // 检查是否有连续的三个位置
                            for (let i = 0; i <= allPositions.length - 3; i++) {
                                if (allPositions[i+1] === allPositions[i] + 1 && 
                                    allPositions[i+2] === allPositions[i] + 2) {
                                    // 进一步验证：确保这三个位置对应的地支确实是三合局的三个成员
                                    const branchesAtPositions = [
                                        allBranches[allPositions[i]],
                                        allBranches[allPositions[i+1]], 
                                        allBranches[allPositions[i+2]]
                                    ];
                                    const hasAllRequired = requiredBranches.every(branch => 
                                        branchesAtPositions.includes(branch)
                                    );
                                    if (hasAllRequired) {
                                        isValidAdjacency = true;
                                        sanheStartIndex = allPositions[i];
                                        break;
                                    }
                                }
                            }
                            
                            console.log(`全三合检查 ${requiredBranches.join('')}: 位置${allPositions}, 连续性=${isValidAdjacency}`);
                        } else if (matches.length === 2) {
                            // 半三合：必须两个地支相邻，且确实是三合局的成员
                            const positions = [];
                            matches.forEach(match => {
                                positions.push(...match.indices);
                            });
                            
                            // 检查任意两个位置是否相邻
                            for (let i = 0; i < positions.length; i++) {
                                for (let j = i + 1; j < positions.length; j++) {
                                    if (Math.abs(positions[i] - positions[j]) === 1) {
                                        // 进一步验证：确保这两个位置的地支确实是三合局的成员
                                        const branch1 = allBranches[positions[i]];
                                        const branch2 = allBranches[positions[j]];
                                        if (requiredBranches.includes(branch1) && requiredBranches.includes(branch2)) {
                                            isValidAdjacency = true;
                                            sanheStartIndex = Math.min(positions[i], positions[j]);
                                            break;
                                        }
                                    }
                                }
                                if (isValidAdjacency) break;
                            }
                            
                            console.log(`半三合检查 ${requiredBranches.join('')}: 位置${positions}, 相邻性=${isValidAdjacency}`);
                        }
                        
                        // 只有通过严格验证的三合局才被认定为有效
                        if (isValidAdjacency) {
                            // 检查天干是否透出合化后的五行
                            const hasTransparent = checkTransparentElement(sanhe.element, allStems);
                            const bestMatch = {
                                type: sanhe.branches.join(''),
                                element: sanhe.element,
                                count: matches.length,
                                branches: matches.map(m => m.branch).join(''),
                                isFullSanhe: matches.length === 3,
                                hasTransparent: hasTransparent,
                                startIndex: sanheStartIndex,
                                isValid: true,
                                positions: matches.flatMap(m => m.indices)
                            };
                            combined.diZhiSanHe.push(bestMatch);
                            console.log(`✅ 发现有效三合局: ${bestMatch.branches} ${matches.length === 3 ? '全' : '半'}三合${sanhe.element}局${hasTransparent ? '（天干透出）' : ''}`);
                        } else {
                            console.log(`❌ 无效三合局: ${requiredBranches.join('')} - 地支不相邻或不完整，不能合化`);
                        }
                    } else {
                        console.log(`❌ 无效三合局: ${requiredBranches.join('')} - 缺少必要地支 (需要${matches.length}/3个)`);
                    }
                });
                
                // 选择最佳的三合局（如果有多个）
                let bestMatch = null;
                let sanheStartIndex = -1;
                if (combined.diZhiSanHe.length > 0) {
                    // 优先选择全三合，其次选择半三合
                    bestMatch = combined.diZhiSanHe.find(match => match.isFullSanhe) || combined.diZhiSanHe[0];
                    sanheStartIndex = bestMatch.startIndex;
                }
                
                if (bestMatch && sanheStartIndex >= 0) {
                    combined.sanhe = bestMatch;
                    
                    // 三合局优先级处理：移除与三合局地支重叠的六合
                    const sanhePositions = [sanheStartIndex, sanheStartIndex+1, sanheStartIndex+2]; // 三合局的位置
                    combined.diZhiLiuHe = combined.diZhiLiuHe.filter(liuhe => {
                        // 检查六合的位置是否与三合局重叠
                        const hasOverlap = liuhe.positions.some(pos => sanhePositions.includes(pos));
                        if (hasOverlap) {
                            console.log(`三合局优先：移除与三合局重叠的六合 ${liuhe.zhi1}${liuhe.zhi2}`);
                            return false;
                        }
                        return true;
                    });
                }
            }
            
            // 检查地支三会局（修复版：添加严格的存在性和相邻性验证）
            const diZhiSanHui = [
                {branches: ['寅', '卯', '辰'], element: 'wood'},  // 东方三会木局
                {branches: ['巳', '午', '未'], element: 'fire'},  // 南方三会火局
                {branches: ['申', '酉', '戌'], element: 'metal'}, // 西方三会金局
                {branches: ['亥', '子', '丑'], element: 'water'}  // 北方三会水局
            ];
            
            combined.diZhiSanHui = [];
            if (allBranches && allBranches.length >= 3) {
                console.log('检查三会局（修复版），地支:', allBranches);
                
                diZhiSanHui.forEach(sanhui => {
                    const matches = [];
                    const requiredBranches = sanhui.branches;
                    
                    // 严格检查：首先验证所有必需的地支是否都存在
                    requiredBranches.forEach(branch => {
                        const indices = allBranches.map((b, i) => b === branch ? i : -1).filter(i => i !== -1);
                        if (indices.length > 0) {
                            matches.push({branch, indices});
                        }
                    });
                    
                    console.log(`检查三会局 ${requiredBranches.join('')}:`, {
                        required: requiredBranches,
                        found: matches.map(m => m.branch),
                        allBranches: allBranches,
                        foundCount: matches.length
                    });
                    
                    // 严格要求：必须有全部3个地支才能构成三会局
                    if (matches.length === 3) {
                        // 严格的相邻性检查：确保地支在八字中真正相邻
                        let isValidAdjacency = false;
                        
                        // 全三会：必须有连续的三个位置，且三个地支都存在
                        const allPositions = [];
                        matches.forEach(match => {
                            allPositions.push(...match.indices);
                        });
                        allPositions.sort((a, b) => a - b);
                        
                        // 检查是否有连续的三个位置
                        for (let start = 0; start <= allPositions.length - 3; start++) {
                            const consecutivePositions = [allPositions[start], allPositions[start + 1], allPositions[start + 2]];
                            if (consecutivePositions[1] === consecutivePositions[0] + 1 && 
                                consecutivePositions[2] === consecutivePositions[1] + 1) {
                                
                                // 验证这三个连续位置确实包含所需的三个地支
                                const actualBranches = consecutivePositions.map(pos => allBranches[pos]);
                                const hasAllRequired = requiredBranches.every(branch => actualBranches.includes(branch));
                                
                                if (hasAllRequired) {
                                    isValidAdjacency = true;
                                    console.log(`✅ 三会局相邻性验证通过: 位置${consecutivePositions}, 地支${actualBranches.join('')}`);
                                    break;
                                }
                            }
                        }
                        
                        console.log(`三会局检查 ${requiredBranches.join('')}: 位置${allPositions}, 相邻性=${isValidAdjacency}`);
                        
                        // 只有通过严格验证的三会局才被认定为有效
                        if (isValidAdjacency) {
                            // 检查天干是否透出合化后的五行
                            const hasTransparent = checkTransparentElement(sanhui.element, allStems);
                            const sanhuiMatch = {
                                type: sanhui.branches.join(''),
                                element: sanhui.element,
                                count: 3,
                                branches: matches.map(m => m.branch).join(''),
                                isFullSanHui: true,
                                hasTransparent: hasTransparent,
                                isValid: true,
                                positions: allPositions
                            };
                            combined.diZhiSanHui.push(sanhuiMatch);
                            console.log(`✅ 发现有效三会局: ${sanhuiMatch.branches} 会化为${sanhui.element}${hasTransparent ? '（天干透出）' : ''}`);
                        } else {
                            console.log(`❌ 无效三会局: ${requiredBranches.join('')} - 地支不相邻，不能会化`);
                        }
                    } else {
                        console.log(`❌ 无效三会局: ${requiredBranches.join('')} - 缺少必要地支 (需要${matches.length}/3个)`);
                    }
                });
            }
            
            // 移除半三合和特别检查，只全连续三合
            
            // 简化的合化判断
            const dayElement = stemElementMap[dayStem];
            
            // 判断合化是否有利于日主
            if (dayElement && !combined.effect) {
                // 检查所有合化的影响
                let hasStrengthening = false;
                let hasWeakening = false;
                
                // 检查天干五合
                combined.tianGanWuHe.forEach(comb => {
                    if (comb.onlyBind) {
                        // 绊合对日主的影响较小，主要是减弱双方力量
                        console.log(`天干五合 ${comb.gan1}${comb.gan2} 绊合（${comb.bindReason}），双方力量减弱`);
                    } else {
                        // 合化成功按新的五行性质判断
                        if (getSupportElements(dayElement).includes(comb.element)) {
                            hasStrengthening = true;
                            console.log(`天干五合 ${comb.gan1}${comb.gan2} 合化${comb.element}成功（${comb.supportType}）生助日主`);
                        } else if (getWeakenElements(dayElement).includes(comb.element)) {
                            hasWeakening = true;
                            console.log(`天干五合 ${comb.gan1}${comb.gan2} 合化${comb.element}成功（${comb.supportType}）克泄日主`);
                        }
                    }
                });
                
                // 检查地支六合
                combined.diZhiLiuHe.forEach(comb => {
                    if (getSupportElements(dayElement).includes(comb.element)) {
                        hasStrengthening = true;
                        console.log(`地支六合 ${comb.zhi1}${comb.zhi2} 合化${comb.element} 生助日主`);
                    } else if (getWeakenElements(dayElement).includes(comb.element)) {
                        hasWeakening = true;
                        console.log(`地支六合 ${comb.zhi1}${comb.zhi2} 合化${comb.element} 克泄日主`);
                    }
                });
                
                // 检查地支三合
                combined.diZhiSanHe.forEach(comb => {
                    if (getSupportElements(dayElement).includes(comb.element)) {
                        hasStrengthening = true;
                        console.log(`地支三合 ${comb.type || comb.branches} 合化${comb.element} 生助日主`);
                    } else if (getWeakenElements(dayElement).includes(comb.element)) {
                        hasWeakening = true;
                        console.log(`地支三合 ${comb.type || comb.branches} 合化${comb.element} 克泄日主`);
                    }
                });
                
                // 设置最终影响
                if (hasStrengthening && !hasWeakening) {
                    combined.effect = 'strengthen';
                    console.log('合化总体对日主影响: 增强');
                } else if (hasWeakening && !hasStrengthening) {
                    combined.effect = 'weaken';
                    console.log('合化总体对日主影响: 削弱');
                } else if (hasStrengthening && hasWeakening) {
                    combined.effect = 'mixed';
                    console.log('合化总体对日主影响: 混合');
                } else {
                    combined.effect = 'neutral';
                    console.log('合化总体对日主影响: 中性');
                }
            }
            
            return combined;
        }
        
        // 获取月令强度
        function getMonthStrength(dayElement, monthBranch, combined) {
            console.log(`getMonthStrength调试 - dayElement: ${dayElement}, monthBranch: ${monthBranch}`);
            
            const branchElementMap = {
                '子': 'water', '丑': 'earth',
                '寅': 'wood', '卯': 'wood',
                '辰': 'earth', '巳': 'fire',
                '午': 'fire', '未': 'earth',
                '申': 'metal', '酉': 'metal',
                '戌': 'earth', '亥': 'water'
            };
            
            // 地支藏干映射
            const BRANCH_ELEMENTS = {
                '子': {main: 'water', hidden: ['癸']},
                '丑': {main: 'earth', hidden: ['己', '癸', '辛']},
                '寅': {main: 'wood', hidden: ['甲', '丙', '戊']},
                '卯': {main: 'wood', hidden: ['乙']},
                '辰': {main: 'earth', hidden: ['戊', '乙', '癸']},
                '巳': {main: 'fire', hidden: ['丙', '庚', '戊']},
                '午': {main: 'fire', hidden: ['丁', '己']},
                '未': {main: 'earth', hidden: ['己', '丁', '乙']},
                '申': {main: 'metal', hidden: ['庚', '壬', '戊']},
                '酉': {main: 'metal', hidden: ['辛']},
                '戌': {main: 'earth', hidden: ['戊', '辛', '丁']},
                '亥': {main: 'water', hidden: ['壬', '甲']}
            };
            
            // 如果月支被合化，使用合化后的元素
            let monthElement = combined.hasOwnProperty('monthElement') ? 
                combined.monthElement : branchElementMap[monthBranch];
            
            console.log(`月令元素初始值: ${monthElement}`);
            
            // 注意：三合局不应该改变月令的基本五行属性
            // 三合局的影响在合化计算中单独处理
            // 月令得分应该基于月支本身的五行
            
            console.log(`最终月令元素: ${monthElement}`);
            
            if (!monthElement) return 0; // 如果无法确定月令元素，返回0
            
            // 获取生扶和克泄元素列表
            const supportElements = getSupportElements(dayElement);
            const weakenElements = getWeakenElements(dayElement);
            
            // 特别处理巳酉丑三合金对己土日主的影响
            // 检查combined.sanhe或combined.diZhiSanHe中的巳酉丑三合
            let hasSiYouChouSanhe = false;
            
            // 检查combined.sanhe
            if (combined.hasOwnProperty('sanhe') && 
                combined.sanhe.type === '巳酉丑' && 
                dayElement === 'earth') {
                hasSiYouChouSanhe = true;
            }
            
            // 检查combined.diZhiSanHe数组
            if (combined.hasOwnProperty('diZhiSanHe') && Array.isArray(combined.diZhiSanHe)) {
                for (const sanhe of combined.diZhiSanHe) {
                    if ((sanhe.type === '巳酉丑' || sanhe.branches === '巳酉丑') && 
                        sanhe.element === 'metal' && 
                        dayElement === 'earth') {
                        hasSiYouChouSanhe = true;
                        console.log('在diZhiSanHe中发现巳酉丑三合金局:', sanhe);
                        break;
                    }
                }
            }
            
            if (hasSiYouChouSanhe) {
                console.log('特别处理：巳酉丑三合金对己土日主的影响，月令得分 -30');
                return -30; // 三合金对土的克制更强
            }
            
            let score = 0;
            
            // 基础月令得分
            if (monthElement === dayElement) {
                score = 40;  // 得令
                console.log(`月令得分：${score} (得令，月令五行与日主相同)`);
                
                // 特殊加分：如果月支参与六合且合化元素与日主相同，额外加分
                if (combined.hasOwnProperty('monthElement') && combined.monthElement === dayElement) {
                    score += 20; // 六合增强，额外加20分
                    console.log(`六合增强：月支参与六合合化${combined.monthElement}，与日主${dayElement}相同，额外加分20，总分：${score}`);
                }
            } else if (supportElements.includes(monthElement)) {
                score = 20;  // 得生
                console.log(`月令得分：${score} (得生，月令五行生扶日主)`);
                
                // 特殊加分：如果月支参与六合且合化元素生扶日主，额外加分
                if (combined.hasOwnProperty('monthElement') && supportElements.includes(combined.monthElement)) {
                    score += 15; // 六合生扶，额外加15分
                    console.log(`六合生扶：月支参与六合合化${combined.monthElement}，生扶日主${dayElement}，额外加分15，总分：${score}`);
                }
            } else if (weakenElements.includes(monthElement)) {
                score = -20; // 被克
                console.log(`月令得分：${score} (被克，月令五行克泄日主)`);
            } else {
                score = 0;   // 不得令
                console.log(`月令得分：${score} (不得令，月令五行与日主无关)`);
            }
            
            // 特殊处理：子丑合土对土日主的增强
            if (dayElement === 'earth' && monthBranch === '丑') {
                // 检查是否存在子丑合土
                let hasZiChouHeTu = false;
                if (combined.hasOwnProperty('diZhiLiuHe') && Array.isArray(combined.diZhiLiuHe)) {
                    for (const liuhe of combined.diZhiLiuHe) {
                        if (((liuhe.zhi1 === '子' && liuhe.zhi2 === '丑') || 
                             (liuhe.zhi1 === '丑' && liuhe.zhi2 === '子')) && 
                            liuhe.element === 'earth') {
                            hasZiChouHeTu = true;
                            console.log('发现子丑合土:', liuhe);
                            break;
                        }
                    }
                }
                
                if (hasZiChouHeTu) {
                    // 子丑合土增强丑土的力量，给予额外加分
                    const ziChouBonus = 10;
                    score += ziChouBonus;
                    console.log(`子丑合土增强：丑月土日主得到子丑合土增强，额外加分${ziChouBonus}，调整后得分：${score}`);
                }
            }
            
            // 精细化调整：考虑季节深度和节气影响
            const seasonalAdjustment = calculateSeasonalAdjustment(monthBranch, dayElement);
            score += seasonalAdjustment;
            console.log(`季节深度调整：${seasonalAdjustment}，调整后月令得分：${score}`);
            
            // 考虑地支藏干的影响
            const branchInfo = BRANCH_ELEMENTS[monthBranch];
            if (branchInfo && branchInfo.hidden) {
                let hiddenAdjustment = 0;
                branchInfo.hidden.forEach((hiddenStem, index) => {
                    const stemElementMap = {
                        '甲': 'wood', '乙': 'wood', '丙': 'fire', '丁': 'fire',
                        '戊': 'earth', '己': 'earth', '庚': 'metal', '辛': 'metal',
                        '壬': 'water', '癸': 'water'
                    };
                    const hiddenElement = stemElementMap[hiddenStem];
                    if (hiddenElement === dayElement) {
                        // 藏干同类加分：主气+8，次气+5，余气+3
                        const hiddenBonus = index === 0 ? 8 : (index === 1 ? 5 : 3);
                        hiddenAdjustment += hiddenBonus;
                        console.log(`藏干同类加分：${monthBranch}藏${hiddenStem}(${hiddenElement}) +${hiddenBonus}`);
                    } else if (supportElements.includes(hiddenElement)) {
                        // 藏干生扶加分：主气+4，次气+2，余气+1
                        const hiddenBonus = index === 0 ? 4 : (index === 1 ? 2 : 1);
                        hiddenAdjustment += hiddenBonus;
                        console.log(`藏干生扶加分：${monthBranch}藏${hiddenStem}(${hiddenElement}) +${hiddenBonus}`);
                    } else if (weakenElements.includes(hiddenElement)) {
                        // 藏干克泄减分：主气-3，次气-2，余气-1
                        const hiddenPenalty = index === 0 ? -3 : (index === 1 ? -2 : -1);
                        hiddenAdjustment += hiddenPenalty;
                        console.log(`藏干克泄减分：${monthBranch}藏${hiddenStem}(${hiddenElement}) ${hiddenPenalty}`);
                    }
                });
                score += hiddenAdjustment;
                console.log(`藏干调整总计：${hiddenAdjustment}，最终月令得分：${score}`);
            }
            
            // 考虑特殊情况：戊己土日主在子月、辰月、戌月的特殊表现
            if ((dayElement === 'earth') && (['子', '辰', '戌'].includes(monthBranch))) {
                // 戊土在子月、辰月、戌月偏强
                if (combined.dayStem === '戊') {
                    score += 10;
                    console.log(`特殊情况：戊土在${monthBranch}月偏强，月令得分调整为 ${score}`);
                }
            }
            
            return score;
        }
        
        // 获取地支主气
        function getBranchMainQi(branch) {
            const branchMainQi = {
                '子': '癸', '丑': '己', '寅': '甲', '卯': '乙',
                '辰': '戊', '巳': '丙', '午': '丁', '未': '己',
                '申': '庚', '酉': '辛', '戌': '戊', '亥': '壬'
            };
            return branchMainQi[branch] || '';
        }
        
        // 检查是否有羊刃
        function hasYangBlade(pillars) {
            const dayStem = pillars.day.charAt(0);
            const yangBladeMap = {
                '甲': '卯', '乙': '寅', '丙': '午', '丁': '巳',
                '戊': '午', '己': '巳', '庚': '酉', '辛': '申',
                '壬': '子', '癸': '亥'
            };
            
            const bladeBranch = yangBladeMap[dayStem];
            if (!bladeBranch) return false;
            
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), 
                            pillars.day.charAt(1), pillars.hour.charAt(1)];
            return branches.includes(bladeBranch);
        }
        
        // 检查财官印流通模式
        function checkWealthOfficialSealFlow(pillars) {
            const dayStem = pillars.day.charAt(0);
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), 
                          pillars.day.charAt(0), pillars.hour.charAt(0)];
            
            let wealthPos = -1, officialPos = -1, sealPos = -1;
            
            // 找到财官印的位置
            for (let i = 0; i < stems.length; i++) {
                const tenGod = getTenGod(dayStem, stems[i]);
                if (tenGod === '正财' || tenGod === '偏财') {
                    wealthPos = i;
                } else if (tenGod === '正官' || tenGod === '七杀') {
                    officialPos = i;
                } else if (tenGod === '正印' || tenGod === '偏印') {
                    sealPos = i;
                }
            }
            
            // 检查是否形成完整流通：财→官→印
            const isComplete = wealthPos !== -1 && officialPos !== -1 && sealPos !== -1 &&
                              wealthPos < officialPos && officialPos < sealPos;
            
            // 检查部分流通
            const partialFlow = (wealthPos !== -1 && officialPos !== -1 && wealthPos < officialPos) ||
                               (officialPos !== -1 && sealPos !== -1 && officialPos < sealPos);
            
            return { isComplete, partialFlow };
        }
        
        // 检查直接流通关系
        function checkDirectFlow(pillars, fromType, toType) {
            const dayStem = pillars.day.charAt(0);
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), 
                          pillars.day.charAt(0), pillars.hour.charAt(0)];
            
            let fromPos = -1, toPos = -1;
            
            for (let i = 0; i < stems.length; i++) {
                const tenGod = getTenGod(dayStem, stems[i]);
                if ((fromType === '财' && (tenGod === '正财' || tenGod === '偏财')) ||
                    (fromType === '官' && (tenGod === '正官' || tenGod === '七杀')) ||
                    (fromType === '印' && (tenGod === '正印' || tenGod === '偏印'))) {
                    fromPos = i;
                }
                if ((toType === '财' && (tenGod === '正财' || tenGod === '偏财')) ||
                    (toType === '官' && (tenGod === '正官' || tenGod === '七杀')) ||
                    (toType === '印' && (tenGod === '正印' || tenGod === '偏印'))) {
                    toPos = i;
                }
            }
            
            return fromPos !== -1 && toPos !== -1 && fromPos < toPos;
        }
        
        // 检查化气格
        function checkHuaQiPattern(pillars) {
            const dayStem = pillars.day.charAt(0);
            const monthStem = pillars.month.charAt(0);
            
            // 化气组合
            const huaQiPairs = {
                '甲己': '土', '乙庚': '金', '丙辛': '水', '丁壬': '木', '戊癸': '火'
            };
            
            const pair = dayStem + monthStem;
            const reversePair = monthStem + dayStem;
            
            if (huaQiPairs[pair] || huaQiPairs[reversePair]) {
                // 需要化神透干或化神当令
                const huaElement = huaQiPairs[pair] || huaQiPairs[reversePair];
                const monthBranch = pillars.month.charAt(1);
                
                // 简化检查：月令是否为化神当令
                const seasonMap = {
                    '土': ['辰', '戌', '丑', '未'],
                    '金': ['申', '酉'],
                    '水': ['亥', '子'],
                    '木': ['寅', '卯'],
                    '火': ['巳', '午']
                };
                
                return seasonMap[huaElement] && seasonMap[huaElement].includes(monthBranch);
            }
            
            return false;
        }
        
        // 检查专旺格
        function checkZhuanWangPattern(pillars) {
            const dayStem = pillars.day.charAt(0);
            const dayElement = getElementMap()[dayStem];
            
            // 统计同类五行数量
            let sameElementCount = 0;
            const allStems = [pillars.year.charAt(0), pillars.month.charAt(0), 
                             pillars.day.charAt(0), pillars.hour.charAt(0)];
            const allBranches = [pillars.year.charAt(1), pillars.month.charAt(1), 
                               pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 统计天干同类
            for (const stem of allStems) {
                if (getElementMap()[stem] === dayElement) {
                    sameElementCount++;
                }
            }
            
            // 统计地支同类（简化）
            for (const branch of allBranches) {
                if (getElementMap()[branch] === dayElement) {
                    sameElementCount++;
                }
            }
            
            // 专旺格要求同类五行占绝大多数
            return sameElementCount >= 6;
        }
        
        // 检查五行特殊格局
        function checkElementPattern(pillars) {
            const allBranches = [pillars.year.charAt(1), pillars.month.charAt(1), 
                               pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 润下格（水局）
            const waterBranches = ['亥', '子', '丑'];
            const waterCount = allBranches.filter(b => waterBranches.includes(b)).length;
            if (waterCount >= 3) {
                return { isValid: true, score: 6, type: '润下格' };
            }
            
            // 炎上格（火局）
            const fireBranches = ['寅', '卯', '巳', '午'];
            const fireCount = allBranches.filter(b => fireBranches.includes(b)).length;
            if (fireCount >= 3) {
                return { isValid: true, score: 6, type: '炎上格' };
            }
            
            // 从革格（金局）
            const metalBranches = ['申', '酉', '戌'];
            const metalCount = allBranches.filter(b => metalBranches.includes(b)).length;
            if (metalCount >= 3) {
                return { isValid: true, score: 6, type: '从革格' };
            }
            
            // 曲直格（木局）
            const woodBranches = ['寅', '卯', '辰'];
            const woodCount = allBranches.filter(b => woodBranches.includes(b)).length;
            if (woodCount >= 3) {
                return { isValid: true, score: 6, type: '曲直格' };
            }
            
            return { isValid: false, score: 0, type: '' };
        }
        
        // 检查是否从格
        function checkFollowingPattern(dayElement, monthBranch, strengthRatio, supportStrength, weakenStrength, monthScore, tripleAnalysis) {
            // 特殊情况：三合局导致的从弱格（针对巳酉丑三合金局等情况）
            if (tripleAnalysis && tripleAnalysis.hasTriple) {
                const tripleInfo = tripleAnalysis.tripleInfo;
                if (tripleInfo.type === '巳酉丑' && dayElement === 'earth') {
                    // 己土日主遇巳酉丑三合金局，巳火生扶力量被大幅削弱
                    if (strengthRatio <= 0.15 && supportStrength <= 5) {
                        console.log(`三合金局从弱格: 巳酉丑合金削弱巳火生扶，比例${(strengthRatio * 100).toFixed(2)}% <= 15%, 生扶力量${supportStrength} <= 5`);
                        return {
                            isFollowing: true,
                            type: '从弱',
                            description: '巳酉丑三合金局成立，巳火生扶力量被大幅削弱，日主失去主要生扶来源，宜从弱论命，喜用财官。'
                        };
                    }
                }
                // 其他三合局的特殊判断可以在此添加
            }
            
            // 从弱格判断：力量比例≤8% 且 生扶力量很少 (严格标准)
            if (strengthRatio <= 0.08 && supportStrength <= 5) {
                console.log(`从弱格判断: 比例${(strengthRatio * 100).toFixed(2)}% <= 8%, 生扶力量${supportStrength} <= 5`);
                return {
                    isFollowing: true,
                    type: '从弱',
                    description: '日主极弱，生扶力量不足，命局以克泄日主的五行为用神，顺势而为，喜用财官。'
                };
            }
            
            // 极弱直判从弱：生扶≤2 或 力量比例≤5% (极严格标准)
            if (supportStrength <= 2 || strengthRatio <= 0.05) {
                console.log(`从弱格判断(极弱): 生扶力量${supportStrength} <= 2 或 比例${(strengthRatio * 100).toFixed(2)}% <= 5%`);
                return {
                    isFollowing: true,
                    type: '从弱',
                    description: '日主极弱，生扶力量几乎为零（或远低于克泄），命局以克泄日主的五行为用神，顺势而为，喜用财官。'
                };
            }
            const branchElementMap = {
                '子': 'water', '丑': 'earth',
                '寅': 'wood', '卯': 'wood',
                '辰': 'earth', '巳': 'fire',
                '午': 'fire', '未': 'earth',
                '申': 'metal', '酉': 'metal',
                '戌': 'earth', '亥': 'water'
            };
            
            const monthElement = branchElementMap[monthBranch];
            if (!monthElement) return { isFollowing: false };
            
            // 获取生扶和克泄元素列表
            const supportElements = getSupportElements(dayElement);
            const weakenElements = getWeakenElements(dayElement);
            
            // 传统从弱格判断：比例≤8% 且 月令克泄日主 且 生扶力量≤5 (更严格标准)
            if (strengthRatio <= 0.08 && weakenElements.includes(monthElement) && supportStrength <= 5) {
                console.log(`传统从弱格判断: 比例${(strengthRatio * 100).toFixed(2)}% <= 8%, 月令克泄日主, 生扶力量${supportStrength} <= 5`);
                return {
                    isFollowing: true,
                    type: '从弱',
                    description: '日主偏弱，但命局以克泄日主的五行为用神，顺势而为，喜用财官。'
                };
            }
            
            // 兜底从弱格判断：生扶≤3 且 克泄≥20 (严格标准)
            if (supportStrength <= 3 && weakenStrength >= 20) {
                console.log(`从弱格判断(兜底): 生扶力量${supportStrength} <= 3, 克泄力量${weakenStrength} >= 20`);
                return {
                    isFollowing: true,
                    type: '从弱',
                    description: '日主极弱，生扶力量不足，命局以克泄日主的五行为用神，顺势而为，喜用财官。'
                };
            }
            
            // 添加调试信息：记录所有从弱格判断条件的检查结果
            console.log(`从弱格判断总结: 力量比例${(strengthRatio * 100).toFixed(2)}%, 生扶力量${supportStrength}, 克泄力量${weakenStrength}, 月令得分${monthScore}`);
            console.log(`条件1(≤8%且生扶≤5): ${strengthRatio <= 0.08 && supportStrength <= 5}`);
            console.log(`条件2(生扶≤2或≤5%): ${supportStrength <= 2 || strengthRatio <= 0.05}`);
            console.log(`条件3(≤8%且月令克泄且生扶≤5): ${strengthRatio <= 0.08 && weakenElements.includes(monthElement) && supportStrength <= 5}`);
            console.log(`条件4(生扶≤3且克泄≥20): ${supportStrength <= 3 && weakenStrength >= 20}`);
            
            // 从强格：身强而用生扶 (严格标准)
            if (strengthRatio >= 0.95 && supportElements.includes(monthElement) && supportStrength >= 25 && weakenStrength <= 2) {
                console.log(`从强格判断: 比例${(strengthRatio * 100).toFixed(2)}% >= 95%, 月令生扶日主, 生扶力量${supportStrength} >= 25, 克泄力量${weakenStrength} <= 2`);
                return {
                    isFollowing: true,
                    type: '从强',
                    description: '日主极强，克泄力量微弱，命局以生扶日主的五行为用神，顺势而为，喜用印比。'
                };
            }
            
            return { isFollowing: false };
        }

        // 获取生扶五行
        function getSupportElements(element) {
            const supportMap = {
                'wood': ['water', 'wood'],
                'fire': ['wood', 'fire'],
                'earth': ['fire', 'earth'],
                'metal': ['earth', 'metal'],
                'water': ['metal', 'water']
            };
            return supportMap[element] || [];
        }

        // 获取克泄五行
        function getWeakenElements(element) {
            const weakenMap = {
                'wood': ['metal', 'fire', 'earth'],
                'fire': ['water', 'earth', 'metal'],
                'earth': ['wood', 'metal', 'water'],
                'metal': ['fire', 'water', 'wood'],
                'water': ['earth', 'wood', 'fire']
            };
            return weakenMap[element] || [];
        }

        // 计算季节深度调整
        function calculateSeasonalAdjustment(monthBranch, dayElement) {
            // 季节深度映射：每个月份在其季节中的强度
            const seasonalDepth = {
                // 春季：木旺
                '寅': { season: 'spring', depth: 0.7, element: 'wood' },  // 初春，木气渐旺
                '卯': { season: 'spring', depth: 1.0, element: 'wood' },  // 仲春，木气最旺
                '辰': { season: 'spring', depth: 0.6, element: 'earth' }, // 季春，土气渐强
                
                // 夏季：火旺
                '巳': { season: 'summer', depth: 0.7, element: 'fire' },  // 初夏，火气渐旺
                '午': { season: 'summer', depth: 1.0, element: 'fire' },  // 仲夏，火气最旺
                '未': { season: 'summer', depth: 0.6, element: 'earth' }, // 季夏，土气渐强
                
                // 秋季：金旺
                '申': { season: 'autumn', depth: 0.7, element: 'metal' }, // 初秋，金气渐旺
                '酉': { season: 'autumn', depth: 1.0, element: 'metal' }, // 仲秋，金气最旺
                '戌': { season: 'autumn', depth: 0.6, element: 'earth' }, // 季秋，土气渐强
                
                // 冬季：水旺
                '亥': { season: 'winter', depth: 0.7, element: 'water' },  // 初冬，水气渐旺
                '子': { season: 'winter', depth: 1.0, element: 'water' },  // 仲冬，水气最旺
                '丑': { season: 'winter', depth: 0.6, element: 'earth' }   // 季冬，土气渐强
            };
            
            const monthInfo = seasonalDepth[monthBranch];
            if (!monthInfo) return 0;
            
            let adjustment = 0;
            
            // 当令五行的季节深度调整
            if (monthInfo.element === dayElement) {
                // 日主与当令五行相同，根据季节深度调整
                adjustment = Math.round((monthInfo.depth - 0.8) * 15); // 基准0.8，最大±3分
                console.log(`季节深度调整：${monthBranch}月${monthInfo.element}气深度${monthInfo.depth}，日主同类调整${adjustment}`);
            } else {
                // 考虑五行生克关系的季节影响
                const supportElements = getSupportElements(dayElement);
                const weakenElements = getWeakenElements(dayElement);
                
                if (supportElements.includes(monthInfo.element)) {
                    // 当令五行生扶日主
                    adjustment = Math.round(monthInfo.depth * 8); // 最大8分
                    console.log(`季节深度调整：${monthBranch}月${monthInfo.element}气深度${monthInfo.depth}，生扶日主调整${adjustment}`);
                } else if (weakenElements.includes(monthInfo.element)) {
                    // 当令五行克泄日主
                    adjustment = -Math.round(monthInfo.depth * 6); // 最大-6分
                    console.log(`季节深度调整：${monthBranch}月${monthInfo.element}气深度${monthInfo.depth}，克泄日主调整${adjustment}`);
                }
            }
            
            // 特殊调整：四季土月（辰、未、戌、丑）
            if (['辰', '未', '戌', '丑'].includes(monthBranch)) {
                if (dayElement === 'earth') {
                    adjustment += 3; // 土日主在四季土月额外加强
                    console.log(`四季土月特殊调整：土日主在${monthBranch}月额外+3`);
                } else {
                    // 其他日主在四季土月受到土气影响
                    const earthEffect = getSupportElements(dayElement).includes('earth') ? 2 : 
                                      getWeakenElements(dayElement).includes('earth') ? -2 : 0;
                    adjustment += earthEffect;
                    if (earthEffect !== 0) {
                        console.log(`四季土月特殊调整：${dayElement}日主受土气影响${earthEffect}`);
                    }
                }
            }
            
            return adjustment;
        }

        // 根据传统命理规则计算大运序列
        function calculateDayunSequence(monthGanZhi, isForward, startAge) {
            // 六十甲子表
            const jiaZi = [
                '甲子', '乙丑', '丙寅', '丁卯', '戊辰', '己巳', '庚午', '辛未', '壬申', '癸酉',
                '甲戌', '乙亥', '丙子', '丁丑', '戊寅', '己卯', '庚辰', '辛巳', '壬午', '癸未',
                '甲申', '乙酉', '丙戌', '丁亥', '戊子', '己丑', '庚寅', '辛卯', '壬辰', '癸巳',
                '甲午', '乙未', '丙申', '丁酉', '戊戌', '己亥', '庚子', '辛丑', '壬寅', '癸卯',
                '甲辰', '乙巳', '丙午', '丁未', '戊申', '己酉', '庚戌', '辛亥', '壬子', '癸丑',
                '甲寅', '乙卯', '丙辰', '丁巳', '戊午', '己未', '庚申', '辛酉', '壬戌', '癸亥'
            ];
            
            // 找到月柱在六十甲子中的位置
            const monthIndex = jiaZi.indexOf(monthGanZhi);
            if (monthIndex === -1) {
                console.error('无法找到月柱:', monthGanZhi);
                return [];
            }
            
            const dayunList = [];
            
            for (let i = 0; i < 10; i++) {
                let dayunIndex;
                if (isForward) {
                    // 顺排：月柱后一位开始
                    dayunIndex = (monthIndex + i + 1) % 60;
                } else {
                    // 逆排：月柱前一位开始
                    dayunIndex = (monthIndex - i - 1 + 60) % 60;
                }
                
                const dayunGanZhi = jiaZi[dayunIndex];
                const dayunStartAge = startAge + i * 10;
                const dayunEndAge = dayunStartAge + 9;
                
                dayunList.push({
                    ganZhi: dayunGanZhi,
                    startAge: dayunStartAge,
                    endAge: dayunEndAge,
                    index: i + 1
                });
            }
            
            return dayunList;
        }

        // 获取当前大运信息
        function getCurrentDayun() {
            try {
                const today = new Date();
                const currentYear = today.getFullYear();
                
                console.log('getCurrentDayun调试信息:');
                console.log('window.eightChar存在:', !!window.eightChar);
                
                // 从八字信息获取基本信息
                const eightChar = window.eightChar;
                if (eightChar && window.currentBaziData && window.currentBaziData.luckTiming) {
                    // 获取起运信息
                    const luckTiming = window.currentBaziData.luckTiming;
                    const isForward = luckTiming.direction === '顺排';
                    const startAge = luckTiming.age;
                    
                    // 获取月柱干支
                    const monthGanZhi = eightChar.getMonth();
                    
                    console.log('月柱干支:', monthGanZhi);
                    console.log('起运方向:', luckTiming.direction);
                    console.log('起运年龄:', startAge);
                    
                    // 计算大运序列
                    const dayunList = calculateDayunSequence(monthGanZhi, isForward, startAge);
                    
                    // 计算当前年龄（虚岁）
                    const birthYear = eightChar.getLunar().getSolar().getYear();
                    const currentAge = currentYear - birthYear + 1; // 使用虚岁计算
                    
                    console.log('出生年份:', birthYear, '当前年份:', currentYear, '当前年龄:', currentAge);
                    console.log('大运列表长度:', dayunList.length);
                    
                    // 打印所有大运
                    dayunList.forEach((dayun, index) => {
                        console.log(`第${index + 1}步大运: ${dayun.ganZhi}, 起始年龄: ${dayun.startAge}, 结束年龄: ${dayun.endAge}`);
                    });
                    
                    // 查找当前大运
                    for (const dayun of dayunList) {
                        if (currentAge >= dayun.startAge && currentAge <= dayun.endAge) {
                            console.log(`找到当前大运: ${dayun.ganZhi}`);
                            return {
                                ganZhi: dayun.ganZhi,
                                startAge: dayun.startAge,
                                endAge: dayun.endAge,
                                currentAge: currentAge
                            };
                        }
                    }
                    
                    console.log('未找到匹配的大运');
                } else {
                    console.log('缺少必要的八字信息或起运信息');
                }
                
                return {
                    ganZhi: '未知',
                    startAge: 0,
                    endAge: 0,
                    currentAge: 0
                };
            } catch (error) {
                console.error('获取当前大运失败:', error);
                return {
                    ganZhi: '计算错误',
                    startAge: 0,
                    endAge: 0,
                    currentAge: 0
                };
            }
        }

        // 获取指定年份的天干地支
        function getYearGanZhi(year) {
            // 天干地支数组（正确顺序）
            const tianGan = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'];
            const diZhi = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
            
            // 以1984年甲子年为基准计算
            const baseYear = 1984;
            const yearDiff = year - baseYear;
            
            // 计算天干地支索引
            const ganIndex = (yearDiff % 10 + 10) % 10;
            const zhiIndex = (yearDiff % 12 + 12) % 12;
            
            return tianGan[ganIndex] + diZhi[zhiIndex];
        }

        // 十二长生状态表
        function getTwelveStagesTable() {
            return {
                '甲': { 长生: '亥', 沐浴: '子', 冠带: '丑', 临官: '寅', 帝旺: '卯', 衰: '辰', 病: '巳', 死: '午', 墓: '未', 绝: '申', 胎: '酉', 养: '戌' },
                '乙': { 长生: '午', 沐浴: '巳', 冠带: '辰', 临官: '卯', 帝旺: '寅', 衰: '丑', 病: '子', 死: '亥', 墓: '戌', 绝: '酉', 胎: '申', 养: '未' },
                '丙': { 长生: '寅', 沐浴: '卯', 冠带: '辰', 临官: '巳', 帝旺: '午', 衰: '未', 病: '申', 死: '酉', 墓: '戌', 绝: '亥', 胎: '子', 养: '丑' },
                '丁': { 长生: '酉', 沐浴: '申', 冠带: '未', 临官: '午', 帝旺: '巳', 衰: '辰', 病: '卯', 死: '寅', 墓: '丑', 绝: '子', 胎: '亥', 养: '戌' },
                '戊': { 长生: '寅', 沐浴: '卯', 冠带: '辰', 临官: '巳', 帝旺: '午', 衰: '未', 病: '申', 死: '酉', 墓: '戌', 绝: '亥', 胎: '子', 养: '丑' },
                '己': { 长生: '酉', 沐浴: '申', 冠带: '未', 临官: '午', 帝旺: '巳', 衰: '辰', 病: '卯', 死: '寅', 墓: '丑', 绝: '子', 胎: '亥', 养: '戌' },
                '庚': { 长生: '巳', 沐浴: '午', 冠带: '未', 临官: '申', 帝旺: '酉', 衰: '戌', 病: '亥', 死: '子', 墓: '丑', 绝: '寅', 胎: '卯', 养: '辰' },
                '辛': { 长生: '子', 沐浴: '亥', 冠带: '戌', 临官: '酉', 帝旺: '申', 衰: '未', 病: '午', 死: '巳', 墓: '辰', 绝: '卯', 胎: '寅', 养: '丑' },
                '壬': { 长生: '申', 沐浴: '酉', 冠带: '戌', 临官: '亥', 帝旺: '子', 衰: '丑', 病: '寅', 死: '卯', 墓: '辰', 绝: '巳', 胎: '午', 养: '未' },
                '癸': { 长生: '卯', 沐浴: '寅', 冠带: '丑', 临官: '子', 帝旺: '亥', 衰: '戌', 病: '酉', 死: '申', 墓: '未', 绝: '午', 胎: '巳', 养: '辰' }
            };
        }
        
        // 计算十二长生状态
        function calculateTwelveStages(dayStem, luckTiming, currentAge) {
            const stagesTable = getTwelveStagesTable();
            const dayStages = stagesTable[dayStem];
            
            if (!dayStages) {
                console.error('无法找到日主天干对应的十二长生表:', dayStem);
                return [];
            }
            
            // 生成大运列表
            const dayunList = generateDayunList(luckTiming);
            
            // 计算每个大运对应的十二长生状态
            const twelveStages = [];
            
            dayunList.forEach((dayun, index) => {
                const dayunZhi = dayun.ganZhi.charAt(1); // 获取大运地支
                
                // 查找该地支在十二长生中的状态
                let stageName = '未知';
                for (const [stage, zhi] of Object.entries(dayStages)) {
                    if (zhi === dayunZhi) {
                        stageName = stage;
                        break;
                    }
                }
                
                // 计算年龄范围
                const startAge = luckTiming.age + index * 10;
                const endAge = startAge + 9;
                
                // 获取状态描述和颜色
                const stageInfo = getStageInfo(stageName);
                
                twelveStages.push({
                    name: stageName,
                    dayun: dayun.ganZhi,
                    energy: stageInfo.energy,
                    color: stageInfo.color,
                    description: stageInfo.description,
                    ageRange: `${startAge}-${endAge}岁`,
                    isCurrent: currentAge >= startAge && currentAge <= endAge
                });
            });
            
            return twelveStages;
        }
        
        // 获取十二长生状态信息
        function getStageInfo(stageName) {
            const stageInfoMap = {
                '长生': { energy: '初生', color: '#4CAF50', description: '新生力量，充满希望与活力' },
                '沐浴': { energy: '洗礼', color: '#2196F3', description: '清洗净化，重新开始人生' },
                '冠带': { energy: '成长', color: '#FF9800', description: '逐渐成熟，展现才华能力' },
                '临官': { energy: '建功', color: '#9C27B0', description: '建功立业，权威地位显现' },
                '帝旺': { energy: '巅峰', color: '#F44336', description: '达到人生顶峰，威势最强' },
                '衰': { energy: '衰退', color: '#795548', description: '力量开始减弱，需要调整' },
                '病': { energy: '困顿', color: '#607D8B', description: '遇到阻碍困难，需要休养' },
                '死': { energy: '终结', color: '#424242', description: '旧事物结束，准备新的开始' },
                '墓': { energy: '收藏', color: '#9E9E9E', description: '收敛蓄积，等待时机' },
                '绝': { energy: '断绝', color: '#37474F', description: '彻底断绝，重新孕育' },
                '胎': { energy: '孕育', color: '#8BC34A', description: '新生命孕育，潜力萌发' },
                '养': { energy: '蓄养', color: '#CDDC39', description: '积蓄力量，培养根基' },
                '未知': { energy: '未知', color: '#9E9E9E', description: '状态未明，需要进一步分析' }
            };
            
            return stageInfoMap[stageName] || stageInfoMap['未知'];
        }
        
        // 生成大运列表
        function generateDayunList(luckTiming) {
            try {
                // 使用现有的calculateDayunSequence函数
                const eightChar = window.eightChar;
                if (!eightChar) {
                    console.error('无法获取八字信息');
                    return [];
                }
                
                // 获取月柱干支
                const monthGanZhi = eightChar.getMonth();
                const isForward = luckTiming.direction === '顺排';
                const startAge = luckTiming.age;
                
                // 计算大运序列
                const dayunSequence = calculateDayunSequence(monthGanZhi, isForward, startAge);
                
                // 转换为所需格式
                return dayunSequence.map(dayun => ({
                    ganZhi: dayun.ganZhi,
                    startAge: dayun.startAge,
                    endAge: dayun.endAge
                }));
            } catch (error) {
                console.error('生成大运列表失败:', error);
                // 返回默认的大运列表
                return [
                    { ganZhi: '甲子', startAge: 0, endAge: 9 },
                    { ganZhi: '乙丑', startAge: 10, endAge: 19 },
                    { ganZhi: '丙寅', startAge: 20, endAge: 29 },
                    { ganZhi: '丁卯', startAge: 30, endAge: 39 },
                    { ganZhi: '戊辰', startAge: 40, endAge: 49 },
                    { ganZhi: '己巳', startAge: 50, endAge: 59 },
                    { ganZhi: '庚午', startAge: 60, endAge: 69 },
                    { ganZhi: '辛未', startAge: 70, endAge: 79 }
                ];
            }
        }

        // 计算起运时间 - 根据正确的八字起运算法
        function calculateLuckTiming(gender, lunar, originalBirthDate) {
            try {
                // 直接使用原始的阳历出生日期，避免转换误差
                const birthDate = originalBirthDate;
                
                // 获取年柱天干
                const eightChar = lunar.getEightChar();
                const yearPillar = eightChar.getYear();
                const yearStr = typeof yearPillar === 'string' ? yearPillar : String(yearPillar);
                const yearGan = yearStr.charAt(0);
                
                console.log('起运计算调试信息:');
                console.log('性别:', gender);
                console.log('年柱:', yearStr);
                console.log('年干:', yearGan);
                
                // 1. 判断年柱阴阳与顺逆排
                const yangTianGan = ['甲', '丙', '戊', '庚', '壬'];
                const yinTianGan = ['乙', '丁', '己', '辛', '癸'];
                const isMale = gender === 'male';
                
                console.log('是否男性:', isMale);
                console.log('年干是否阳干:', yangTianGan.includes(yearGan));
                console.log('年干是否阴干:', yinTianGan.includes(yearGan));
                
                let direction;
                if ((yangTianGan.includes(yearGan) && isMale) || (yinTianGan.includes(yearGan) && !isMale)) {
                    direction = '顺排'; // 阳年男 or 阴年女
                } else {
                    direction = '逆排'; // 阴年男 or 阳年女
                }
                
                console.log('起运方向:', direction);
                
                // 2. 计算出生日到最近节气的天数差
                const daysDiff = getDaysToJieQi(birthDate, direction, birthDate.getFullYear());
                
                // 3. 起运年龄计算
                const years = Math.floor(daysDiff / 3); // 3天 = 1岁
                const months = Math.round((daysDiff / 3 - years) * 12); // 小数部分转月份
                
                return {
                    age: years,
                    months: months,
                    direction: direction,
                    daysDiff: daysDiff.toFixed(2),
                    description: `${direction}，${years}岁${months}个月起运`
                };
            } catch (error) {
                console.error('起运计算错误:', error);
                // 返回默认值
                return {
                    age: 8,
                    months: 0,
                    direction: '顺排',
                    daysDiff: '24.00',
                    description: '8岁0个月起运（默认值）'
                };
            }
        }
        
        // 计算出生日到最近节气的天数差
        function getDaysToJieQi(birthDate, direction, birthYear) {
            try {
                // 八字换月节气列表（完整版本）
                const monthlyJieQi = [
                    '立春', '惊蛰', '清明', '立夏', '芒种', '小暑',
                    '立秋', '白露', '寒露', '立冬', '大雪', '小寒'
                ];
                
                let targetJieQi = null;
                let minDiff = direction === '顺排' ? Infinity : -Infinity;
                
                // 检查当年和前后一年的节气
                for (let yearOffset = -1; yearOffset <= 1; yearOffset++) {
                    const checkYear = birthYear + yearOffset;
                    
                    for (const jieQiName of monthlyJieQi) {
                        const jieQiSolar = getJieQiTime(checkYear, jieQiName);
                        if (!jieQiSolar) continue;
                        
                        const jieQiDate = new Date(
                            jieQiSolar.getYear(),
                            jieQiSolar.getMonth() - 1,
                            jieQiSolar.getDay(),
                            jieQiSolar.getHour(),
                            jieQiSolar.getMinute(),
                            jieQiSolar.getSecond()
                        );
                        
                        const timeDiff = jieQiDate.getTime() - birthDate.getTime();
                        
                        if (direction === '顺排') {
                            // 找下一个节气（未来最近的）
                            if (timeDiff > 0 && timeDiff < minDiff) {
                                minDiff = timeDiff;
                                targetJieQi = jieQiDate;
                            }
                        } else {
                            // 找上一个节气（过去最近的）
                            if (timeDiff < 0 && timeDiff > minDiff) {
                                minDiff = timeDiff;
                                targetJieQi = jieQiDate;
                            }
                        }
                    }
                }
                
                if (targetJieQi) {
                    const diffMs = Math.abs(targetJieQi.getTime() - birthDate.getTime());
                    const diffDays = diffMs / (1000 * 60 * 60 * 24);
                    
                    console.log('节气计算调试信息:');
                    console.log('出生日期:', birthDate);
                    console.log('目标节气时间:', targetJieQi);
                    console.log('时间差(天):', diffDays.toFixed(2));
                    
                    return diffDays;
                }
                
                // 如果找不到合适的节气，返回默认值
                console.warn('找不到合适的节气，使用默认值');
                return 24;
                
            } catch (error) {
                console.error('获取节气时间错误:', error);
                return 24; // 默认值
            }
        }
        
        // 获取指定年份的节气时间
        function getJieQiTime(year, jieQiName) {
            try {
                const solar = Solar.fromYmd(year, 6, 1);
                const lunar = solar.getLunar();
                const jieQiTable = lunar.getJieQiTable();
                
                return jieQiTable[jieQiName] || null;
            } catch (error) {
                console.error(`获取${year}年${jieQiName}节气时间失败:`, error);
                return null;
            }
        }

        // 计算当前身强身弱（加入大运和流年）
        function calculateCurrentStrength(dayStem, elements, monthBranch, currentYear) {
            try {
                // 初始化土性变化计算器
                const earthCalculator = new EarthTransformationCalculator();
                
                // 获取当前流年干支
                const today = new Date();
                const currentLunar = Lunar.fromDate(today);
                const currentYearGanZhi = currentLunar.getYearInGanZhi();
                const currentYearStem = currentYearGanZhi.charAt(0);
                const currentYearBranch = currentYearGanZhi.charAt(1);
                
                // 获取当前大运信息
                let currentDayunStem = '';
                let currentDayunBranch = '';
                
                try {
                    // 使用getCurrentDayun函数获取当前大运信息，保持一致性
                    const currentDayunInfo = getCurrentDayun();
                    if (currentDayunInfo && currentDayunInfo.ganZhi && currentDayunInfo.ganZhi !== '未知' && currentDayunInfo.ganZhi !== '计算错误') {
                        currentDayunStem = currentDayunInfo.ganZhi.charAt(0);
                        currentDayunBranch = currentDayunInfo.ganZhi.charAt(1);
                    } else {
                        // 如果getCurrentDayun也失败，则不添加大运影响
                        console.log('无法获取当前大运信息，跳过大运影响计算');
                        currentDayunStem = '';
                        currentDayunBranch = '';
                    }
                } catch (e) {
                    console.log('获取大运信息失败:', e);
                    currentDayunStem = '';
                    currentDayunBranch = '';
                }
                
                console.log(`当前流年: ${currentYear}年${currentYearGanZhi}, 当前大运: ${currentDayunStem}${currentDayunBranch}`);
                console.log('原始五行分布:', elements);
                
                // 复制原始五行分布
                const currentElements = { ...elements };
                console.log('复制后的五行分布:', currentElements);
                
                // 获取天干地支对应的五行
                const stemElementMap = {
                    '甲': 'wood', '乙': 'wood',
                    '丙': 'fire', '丁': 'fire',
                    '戊': 'earth', '己': 'earth',
                    '庚': 'metal', '辛': 'metal',
                    '壬': 'water', '癸': 'water'
                };
                
                const branchElementMap = {
                    '子': 'water', '丑': 'earth', '寅': 'wood', '卯': 'wood',
                    '辰': 'earth', '巳': 'fire', '午': 'fire', '未': 'earth',
                    '申': 'metal', '酉': 'metal', '戌': 'earth', '亥': 'water'
                };
                
                // 地支藏干映射
                const BRANCH_ELEMENTS = {
                    '子': {main: 'water', hidden: ['癸']},
                    '丑': {main: 'earth', hidden: ['己', '癸', '辛']},
                    '寅': {main: 'wood', hidden: ['甲', '丙', '戊']},
                    '卯': {main: 'wood', hidden: ['乙']},
                    '辰': {main: 'earth', hidden: ['戊', '乙', '癸']},
                    '巳': {main: 'fire', hidden: ['丙', '庚', '戊']},
                    '午': {main: 'fire', hidden: ['丁', '己']},
                    '未': {main: 'earth', hidden: ['己', '丁', '乙']},
                    '申': {main: 'metal', hidden: ['庚', '壬', '戊']},
                    '酉': {main: 'metal', hidden: ['辛']},
                    '戌': {main: 'earth', hidden: ['戊', '辛', '丁']},
                    '亥': {main: 'water', hidden: ['壬', '甲']}
                };
                
                // 加入流年天干地支的五行力量
                const yearStemElement = stemElementMap[currentYearStem];
                const yearBranchElement = branchElementMap[currentYearBranch];
                
                if (yearStemElement) {
                    currentElements[yearStemElement] += 0.4; // 流年天干权重 (进一步降低到0.4)
                }
                if (yearBranchElement) {
                    currentElements[yearBranchElement] += 0.6; // 流年地支权重 (进一步降低到0.6)
                }
                
                // 加入大运天干地支的五行力量
                const dayunStemElement = stemElementMap[currentDayunStem];
                const dayunBranchElement = branchElementMap[currentDayunBranch];
                
                if (dayunStemElement) {
                    currentElements[dayunStemElement] += 0.3; // 大运天干权重 (进一步降低到0.3)
                }
                if (dayunBranchElement) {
                    currentElements[dayunBranchElement] += 0.5; // 大运地支权重 (进一步降低到0.5)
                }
                
                console.log('加入大运流年后的五行分布:', currentElements);
                console.log(`流年干支: ${currentYearStem}(${yearStemElement}) ${currentYearBranch}(${yearBranchElement})`);
                console.log(`大运干支: ${currentDayunStem}(${dayunStemElement}) ${currentDayunBranch}(${dayunBranchElement})`);
                
                // 获取所有干支用于土性变化分析和合化检查
                const allStems = [];
                const allBranches = [];
                
                // 原八字干支
                try {
                    const pillars = window.currentPillars || {};
                    if (pillars.year) {
                        allStems.push(pillars.year.charAt(0));
                        allBranches.push(pillars.year.charAt(1));
                    }
                    if (pillars.month) {
                        allStems.push(pillars.month.charAt(0));
                        allBranches.push(pillars.month.charAt(1));
                    }
                    if (pillars.day) {
                        allStems.push(pillars.day.charAt(0));
                        allBranches.push(pillars.day.charAt(1));
                    }
                    if (pillars.hour) {
                        allStems.push(pillars.hour.charAt(0));
                        allBranches.push(pillars.hour.charAt(1));
                    }
                } catch (e) {
                    console.error('获取八字信息失败:', e);
                }
                
                // 加入流年和大运干支
                allStems.push(currentYearStem, currentDayunStem);
                allBranches.push(currentYearBranch, currentDayunBranch);
                
                // 精细化计算大运流年藏干权重
                const yearBranchInfo = BRANCH_ELEMENTS[currentYearBranch];
                const dayunBranchInfo = BRANCH_ELEMENTS[currentDayunBranch];
                
                // 流年地支藏干（权重减半）
                if (yearBranchInfo && yearBranchInfo.hidden) {
                    yearBranchInfo.hidden.forEach((hiddenStem, stemIndex) => {
                        const element = stemElementMap[hiddenStem];
                        if (element) {
                            // 流年藏干权重：主气0.3，次气0.2，余气0.1
                            const hiddenWeight = stemIndex === 0 ? 0.3 : (stemIndex === 1 ? 0.2 : 0.1);
                            currentElements[element] += hiddenWeight;
                            console.log(`流年藏干：${currentYearBranch}藏${hiddenStem}(${element}) +${hiddenWeight}`);
                        }
                    });
                }
                
                // 大运地支藏干（权重减半）
                if (dayunBranchInfo && dayunBranchInfo.hidden) {
                    dayunBranchInfo.hidden.forEach((hiddenStem, stemIndex) => {
                        const element = stemElementMap[hiddenStem];
                        if (element) {
                            // 大运藏干权重：主气0.25，次气0.15，余气0.1
                            const hiddenWeight = stemIndex === 0 ? 0.25 : (stemIndex === 1 ? 0.15 : 0.1);
                            currentElements[element] += hiddenWeight;
                            console.log(`大运藏干：${currentDayunBranch}藏${hiddenStem}(${element}) +${hiddenWeight}`);
                        }
                    });
                }
                
                // 分析土性变化和三合局影响（但不完全替换五行分布）
                const earthTransformation = earthCalculator.analyzeEarthTransformation(allStems, allBranches);
                
                // 只应用土性变化的调整，而不是完全替换五行分布
                if (earthTransformation && earthTransformation.hasAnyTransformation && earthTransformation.elementAdjustments) {
                    Object.keys(earthTransformation.elementAdjustments).forEach(element => {
                        const adjustment = earthTransformation.elementAdjustments[element];
                        if (adjustment !== 0) {
                            currentElements[element] = Math.max(0, currentElements[element] + adjustment);
                            console.log(`土性变化调整：${element} ${adjustment > 0 ? '+' : ''}${adjustment.toFixed(2)}`);
                        }
                    });
                }
                
                // 创建增强结果对象以保持兼容性
                const enhancedResult = {
                    elements: currentElements,
                    earthTransformation: earthTransformation || { hasAnyTransformation: false, elementAdjustments: {} },
                    tripleAnalysis: { hasTriple: false }, // 简化三合局分析
                    adjustments: {
                        earthTransformation: earthTransformation && earthTransformation.hasAnyTransformation,
                        totalEarthReduction: (earthTransformation && earthTransformation.elementAdjustments && earthTransformation.elementAdjustments.earth) || 0,
                        totalWaterIncrease: (earthTransformation && earthTransformation.elementAdjustments && earthTransformation.elementAdjustments.water) || 0
                    }
                };
                
                console.log('=== 当前运势增强版五行计算结果 ===');
                console.log('土性变化分析:', enhancedResult.earthTransformation);
                console.log('精细化藏干权重已应用');
                console.log('流年藏干权重：主气0.3，次气0.2，余气0.1');
                console.log('大运藏干权重：主气0.25，次气0.15，余气0.1');
                console.log('三合局分析:', enhancedResult.tripleAnalysis);
                console.log('调整信息:', enhancedResult.adjustments);
                console.log('最终五行分布:', currentElements);
                
                // 如果有土性变化，输出详细说明
                if (enhancedResult.earthTransformation.hasTransformation) {
                    console.log('土性变化说明:', earthCalculator.getTransformationDescription(enhancedResult.earthTransformation.transformations));
                }
                
                // 如果有三合局，输出详细说明
                if (enhancedResult.tripleAnalysis.hasTriple) {
                    const tripleInfo = enhancedResult.tripleAnalysis.tripleInfo;
                    console.log(`三合局影响: ${tripleInfo.type}${tripleInfo.isComplete ? '全' : '半'}三合${tripleInfo.element === 'metal' ? '金' : tripleInfo.element}局`);
                    if (tripleInfo.type === '巳酉丑') {
                        console.log('巳火生扶力量被三合金局削弱');
                    }
                }
                
                // allStems和allBranches已在上面声明和初始化
                
                // 检查合化（流年和大运可以与任意八字干支合化）
                const currentCombined = checkCurrentCombinations(dayStem, allStems, allBranches, currentYearStem, currentYearBranch, currentDayunStem, currentDayunBranch);
                
                // 计算月令得分（考虑土性变化）
                let monthScore = getMonthStrength(stemElementMap[dayStem], monthBranch, currentCombined);
                
                // 应用土性变化对月令得分的影响
                if (enhancedResult.earthTransformation.hasTransformation) {
                    const monthBranchTransformation = enhancedResult.earthTransformation.transformations.find(t => t.branch === monthBranch);
                    if (monthBranchTransformation) {
                        console.log(`=== 月令土性变化影响 ===`);
                        console.log(`月支 ${monthBranch} 发生土性变化:`, monthBranchTransformation);
                        
                        // 如果月令是土，且发生了土性变化
                        if (monthBranchTransformation.originalElement === 'earth') {
                            const originalScore = monthScore;
                            
                            // 根据土性变化的强度调整月令得分
                            if (monthBranchTransformation.newElement === 'water') {
                                // 湿土转化为水性，完全作水看
                                if (stemElementMap[dayStem] === 'earth') {
                                    // 对土日主完全失去生扶，变为克制
                                    monthScore = -10;
                                    console.log(`湿土转水性，对土日主完全失去生扶变为克制：${originalScore} -> ${monthScore}`);
                                } else if (stemElementMap[dayStem] === 'fire') {
                                    // 对火日主变为克制
                                    monthScore = -15;
                                    console.log(`湿土转水性，对火日主变为克制：${originalScore} -> ${monthScore}`);
                                }
                            } else if (monthBranchTransformation.newElement === 'fire') {
                                // 燥土转化为火性
                                if (stemElementMap[dayStem] === 'earth') {
                                    monthScore = Math.round(monthScore * 0.3); // 减少70%
                                    console.log(`燥土转火性，对土日主生扶减少：${originalScore} -> ${monthScore}`);
                                } else if (stemElementMap[dayStem] === 'metal') {
                                    // 对金日主变为克制
                                    monthScore = -15;
                                    console.log(`燥土转火性，对金日主变为克制：${originalScore} -> ${monthScore}`);
                                }
                            } else if (monthBranchTransformation.transformationType === 'weakened') {
                                // 土性减弱但未完全转化
                                monthScore = Math.round(monthScore * 0.5); // 减少50%
                                console.log(`土性减弱，月令得分减半：${originalScore} -> ${monthScore}`);
                            }
                        }
                    }
                }
                
                // 计算生扶和克泄力量
                const dayElement = stemElementMap[dayStem];
                const supportElements = getSupportElements(dayElement);
                const weakenElements = getWeakenElements(dayElement);
                
                console.log(`当前运势计算 - 日主:${dayStem}(${dayElement})`);
                console.log('生扶五行:', supportElements);
                console.log('克泄五行:', weakenElements);
                
                let supportStrength = 0;
                let weakenStrength = 0;
                
                supportElements.forEach(element => {
                    const elementStrength = currentElements[element] || 0;
                    supportStrength += elementStrength;
                    console.log(`生扶五行 ${element}: ${elementStrength}`);
                });
                
                weakenElements.forEach(element => {
                    const elementStrength = currentElements[element] || 0;
                    weakenStrength += elementStrength;
                    console.log(`克泄五行 ${element}: ${elementStrength}`);
                });
                
                console.log(`初始计算（当前运势） - 生扶力量:${supportStrength}, 克泄力量:${weakenStrength}`);                
                
                // 将月令得分转换为力量点数并加入计算
                if (monthScore > 0) {
                    // 正分加入生扶力量
                    supportStrength += monthScore / 10; // 月令得分除以10转换为力量点数
                    console.log(`月令得分${monthScore}分转换为生扶力量: +${monthScore / 10}`);
                } else if (monthScore < 0) {
                    // 负分加入克泄力量
                    weakenStrength += Math.abs(monthScore) / 10;
                    console.log(`月令得分${monthScore}分转换为克泄力量: +${Math.abs(monthScore) / 10}`);
                }
                
                console.log(`加入月令得分后 - 生扶力量:${supportStrength}, 克泄力量:${weakenStrength}`);
                
                // 处理合化影响
                let combinationDeduction = 0;
                const combinationTypes = ['tianGanWuHe', 'diZhiLiuHe', 'diZhiSanHe', 'diZhiSanHui'];
                combinationTypes.forEach(type => {
                    if (currentCombined[type]) {
                        currentCombined[type].forEach(comb => {
                            const heElement = comb.element;
                            // 专业命理评分规则
const SCORE_RULES = {
  'diZhiSanHui': 8,  // 三会局8分（能量最强）
  'diZhiSanHe': 6,   // 三合局6分（全三合）
  'diZhiLiuHe': 3,   // 六合局3分
  'tianGanWuHe': 2   // 天干合需通根验证
};
let multiplier = SCORE_RULES[type];

// 半三合能量减弱：只有2个地支的三合局能量减半
if (type === 'diZhiSanHe' && comb.count === 2) {
  multiplier = 3; // 半三合3分，比全三合6分减半
  console.log(`大运流年半三合${comb.type}能量减弱，分数调整为${multiplier}分`);
}

// 天干合化：依据checkCurrentCombinations的通根判定
if (type === 'tianGanWuHe' && typeof comb.hasRoot !== 'undefined' && !comb.hasRoot) {
  console.log(`忽略天干合化：${comb.gan1}${comb.gan2} 无通根支持`);
  return;
}

// 地支合化天干透出检查 - 如果天干透出合化后的五行，能量加倍
if((type === 'diZhiLiuHe' || type === 'diZhiSanHe' || type === 'diZhiSanHui') && comb.hasTransparent) {
  multiplier *= 1.5; // 透出时能量增加50%
  console.log(`${type} 天干透出${heElement}，能量增强至 ${multiplier}`);
}
                            if (getSupportElements(dayElement).includes(heElement)) {
                                supportStrength += multiplier;
                                combinationDeduction += multiplier;
                            } else if (getWeakenElements(dayElement).includes(heElement)) {
                                weakenStrength += multiplier;
                                combinationDeduction -= multiplier;
                            }
                        });
                    }
                });
                
                currentCombined.deduction = combinationDeduction;
                
                // 处理负数生扶力量的情况
                if (supportStrength < 0) {
                    // 如果生扶力量为负，将其归入克泄力量
                    weakenStrength += Math.abs(supportStrength);
                    supportStrength = 0;
                }
                
                // 判断身强身弱
                const totalStrength = supportStrength + weakenStrength;
                let strengthRatio = totalStrength > 0 ? supportStrength / totalStrength : 0;
                const strengthPercentage = strengthRatio * 100; // 转换为百分比
                
                // 打印调试信息
                console.log(`当前身强身弱计算 - 日主:${dayStem}(${dayElement}), 生扶力量:${supportStrength}, 克泄力量:${weakenStrength}, 比例:${(strengthRatio * 100).toFixed(2)}%, 月令得分:${monthScore}`);
                
                let type, description;
                
                // 判断是否从格（使用与原始函数相同的逻辑，传入三合局分析信息）
                const isFollowing = checkFollowingPattern(dayElement, monthBranch, strengthRatio, supportStrength, weakenStrength, monthScore, enhancedResult.tripleAnalysis);
                
                // 使用EarthTransformationCalculator的analyzeCongGe方法进行更精确的从格判断
                let finalIsFollowing = isFollowing;
                console.log(`当前运势earthCalculator存在:`, !!earthCalculator);
                console.log(`当前运势enhancedResult存在:`, !!enhancedResult);
                console.log(`当前运势enhancedResult内容:`, enhancedResult);
                
                if (earthCalculator) {
                    const supportRatio = totalStrength > 0 ? supportStrength / totalStrength : 0;
                    console.log(`当前运势从格判断调试 - 生扶力量:${supportStrength}, 克泄力量:${weakenStrength}, 总力量:${totalStrength}, 支持比例:${(supportRatio * 100).toFixed(2)}%`);
                    
                    const congGeResult = earthCalculator.analyzeCongGe(supportRatio, enhancedResult);
                    console.log(`当前运势analyzeCongGe结果:`, congGeResult);
                    
                    // 如果analyzeCongGe判断为从格且置信度较高，优先使用其结果
                    if (congGeResult.isCongGe && congGeResult.confidence > 0.1) {
                        finalIsFollowing = {
                            isFollowing: true,
                            type: congGeResult.type,
                            description: `EarthTransformationCalculator判断：${congGeResult.reason}，置信度：${(congGeResult.confidence * 100).toFixed(1)}%`
                        };
                        console.log(`从格判断优化：使用EarthTransformationCalculator结果 - ${congGeResult.type}，置信度：${(congGeResult.confidence * 100).toFixed(1)}%`);
                    } else {
                        console.log(`当前运势analyzeCongGe未生效 - isCongGe:${congGeResult.isCongGe}, confidence:${(congGeResult.confidence * 100).toFixed(1)}%`);
                    }
                }
                
                // 使用12级身强身弱分类系统（当前大运流年）
                console.log(`当前运势最终从格判断状态:`, finalIsFollowing);
                console.log(`传入calculateStrengthLevel的参数 - strengthRatio: ${strengthRatio}, strengthPercentage: ${strengthPercentage}`);
                const currentStrengthLevel = calculateStrengthLevel(strengthPercentage, supportStrength, weakenStrength, monthScore, finalIsFollowing, dayElement, monthBranch, true);
                type = currentStrengthLevel.type;
                description = currentStrengthLevel.description;
                console.log(`当前运势最终身强身弱判断结果: ${type}，基于strengthPercentage: ${strengthPercentage}%`);
                
                // 特殊情况：只有在极端情况下才强制判断为身弱（条件更严格）
                if (monthScore < -20 && supportStrength < weakenStrength * 0.5 && strengthPercentage > 15) {
                    // 只有在不是从格的情况下才强制判断为身弱
                    if (!finalIsFollowing || !finalIsFollowing.isFollowing) {
                        type = '身弱';
                        description = '加入当前大运和流年后，日主在月令严重失势，生扶力量极度不足，判断为身弱，喜用印比。';
                        console.log(`特殊修正（大运流年）：月令得分${monthScore}，生扶${supportStrength}<克泄${weakenStrength}*0.5，强制判断为身弱`);
                    } else {
                        console.log(`跳过特殊修正：已判断为从格 - ${finalIsFollowing.type}`);
                    }
                }
                
                // 格局稳定性检查：防止身强身弱变化过大
                try {
                    const originalStrength = calculateStrength(dayStem, elements, monthBranch);
                    if (originalStrength && originalStrength.ratio !== undefined) {
                        const originalRatio = originalStrength.ratio;
                        const currentRatio = strengthRatio;
                        const ratioChange = Math.abs(currentRatio - originalRatio);
                        
                        // 如果变化超过30%，进行调整
                        if (ratioChange > 0.30) {
                            console.log(`格局稳定性检查：原命局比例${(originalRatio * 100).toFixed(2)}%，当前比例${(currentRatio * 100).toFixed(2)}%，变化${(ratioChange * 100).toFixed(2)}%过大`);
                            
                            // 调整当前比例，使其变化不超过25%
                            const maxChange = 0.25;
                            let adjustedRatio;
                            if (currentRatio > originalRatio) {
                                adjustedRatio = originalRatio + maxChange;
                            } else {
                                adjustedRatio = originalRatio - maxChange;
                            }
                            
                            // 确保调整后的比例在合理范围内
                            adjustedRatio = Math.max(0.05, Math.min(0.95, adjustedRatio));
                            
                            // 重新判断身强身弱类型（传入三合局分析信息）
                            const adjustedFollowing = checkFollowingPattern(dayElement, monthBranch, adjustedRatio, supportStrength, weakenStrength, monthScore, enhancedResult.tripleAnalysis);
                            
                            // 使用EarthTransformationCalculator的analyzeCongGe方法进行更精确的从格判断
                            let finalAdjustedFollowing = adjustedFollowing;
                            if (earthCalculator && enhancedResult) {
                                const totalStrength = supportStrength + weakenStrength;
                                const adjustedSupportRatio = totalStrength > 0 ? supportStrength / totalStrength : 0;
                                const congGeResult = earthCalculator.analyzeCongGe(adjustedSupportRatio, enhancedResult);
                                
                                // 如果analyzeCongGe判断为从格且置信度较高，优先使用其结果
                                if (congGeResult.isCongGe && congGeResult.confidence > 0.1) {
                                    finalAdjustedFollowing = {
                                        isFollowing: true,
                                        type: congGeResult.type,
                                        description: `EarthTransformationCalculator判断：${congGeResult.reason}，置信度：${(congGeResult.confidence * 100).toFixed(1)}%`
                                    };
                                    console.log(`格局稳定性调整后从格判断优化：使用EarthTransformationCalculator结果 - ${congGeResult.type}，置信度：${(congGeResult.confidence * 100).toFixed(1)}%`);
                                }
                            }
                            
                            // 使用12级分类系统重新判断
                            const adjustedPercentage = adjustedRatio * 100; // 转换为百分比
                            console.log(`格局稳定性调整后传入calculateStrengthLevel的参数 - adjustedRatio: ${adjustedRatio}, adjustedPercentage: ${adjustedPercentage}`);
                            const adjustedStrengthLevel = calculateStrengthLevel(adjustedPercentage, supportStrength, weakenStrength, monthScore, finalAdjustedFollowing, dayElement, monthBranch, true);
                            type = adjustedStrengthLevel.type;
                            description = '经格局稳定性调整后，' + adjustedStrengthLevel.description.replace('加入当前大运和流年后，', '');
                            
                            console.log(`格局稳定性调整：${(currentRatio * 100).toFixed(2)}% -> ${(adjustedRatio * 100).toFixed(2)}%，类型：${type}，基于adjustedPercentage: ${adjustedPercentage}%`);
                            strengthRatio = adjustedRatio;
                        }
                    }
                } catch (stabilityError) {
                    console.warn('格局稳定性检查失败，使用原始计算结果:', stabilityError);
                }
                
                // 获取当前大运信息用于显示
                const displayDayunInfo = getCurrentDayun();
                const displayDayun = (displayDayunInfo && displayDayunInfo.ganZhi && displayDayunInfo.ganZhi !== '未知' && displayDayunInfo.ganZhi !== '计算错误') 
                    ? displayDayunInfo.ganZhi 
                    : '未知';
                
                return {
                    type: type,
                    ratio: strengthRatio,
                    strengthPercentage: strengthPercentage,
                    supportStrength: supportStrength,
                    weakenStrength: weakenStrength,
                    description: description,
                    monthScore: monthScore,
                    combined: currentCombined,
                    currentYear: currentYear,
                    currentYearGanZhi: currentYearGanZhi,
                    currentDayun: displayDayun,
                    elements: currentElements,
                    earthTransformation: enhancedResult.earthTransformation || { hasTransformation: false, transformations: [] }
                };
                
            } catch (error) {
                console.error('计算当前身强身弱失败:', error);
                return {
                    type: '计算失败',
                    ratio: 0.5,
                    strengthPercentage: 50,
                    supportStrength: 0,
                    weakenStrength: 0,
                    description: '无法计算当前身强身弱，请检查数据。',
                    monthScore: 0,
                    combined: {
                        tianGanWuHe: [],
                        diZhiLiuHe: [],
                        diZhiSanHe: [],
                        effect: null,
                        deduction: 0
                    },
                    currentYear: currentYear,
                    currentYearGanZhi: '',
                    currentDayun: '',
                    elements: elements,
                    earthTransformation: { hasTransformation: false, transformations: [], wetEarthChanges: [], dryEarthChanges: [] }
                };
            }
        }
        
        // 检查当前合化情况（包括流年大运）
        function checkCurrentCombinations(dayStem, allStems, allBranches, yearStem, yearBranch, dayunStem, dayunBranch) {
            const combined = {
                tianGanWuHe: [],
                diZhiLiuHe: [],
                diZhiSanHe: [],
                deduction: 0
            };
            
            // 天干五合规则
            const tianGanHeHua = {
                '甲己': 'earth', '乙庚': 'metal', '丙辛': 'water',
                '丁壬': 'wood', '戊癸': 'fire'
            };
            
            // 地支六合规则
            const diZhiLiuHe = {
                '子丑': 'earth', '寅亥': 'wood', '卯戌': 'fire',
                '辰酉': 'metal', '巳申': 'water', '午未': 'earth'
            };
            
            // 地支三合规则
            const diZhiSanHe = [
                {branches: ['申', '子', '辰'], element: 'water'},
                {branches: ['亥', '卯', '未'], element: 'wood'},
                {branches: ['寅', '午', '戌'], element: 'fire'},
                {branches: ['巳', '酉', '丑'], element: 'metal'}
            ];
            
            // 使用Set来避免重复合化
            const processedTianGan = new Set();
            const processedDiZhi = new Set();
            
            // 检查天干五合（流年/大运：不要求相邻，但必须地支有根）
            for (let i = 0; i < allStems.length; i++) {
                for (let j = i + 1; j < allStems.length; j++) {
                    const stem1 = allStems[i];
                    const stem2 = allStems[j];
                    const pair1 = stem1 + stem2;
                    const pair2 = stem2 + stem1;
                    
                    // 创建唯一标识，按字母顺序排序避免重复
                    const uniqueKey = [stem1, stem2].sort().join('');
                    
                    if ((tianGanHeHua[pair1] || tianGanHeHua[pair2]) && !processedTianGan.has(uniqueKey)) {
                        const hehuaElement = tianGanHeHua[pair1] || tianGanHeHua[pair2];
                        processedTianGan.add(uniqueKey);
                        
                        // 检查是否涉及流年或大运（天干五合新机制）
                        const involvesYearOrDayun = (stem1 === yearStem || stem2 === yearStem || 
                                                    stem1 === dayunStem || stem2 === dayunStem);
                        
                        if (involvesYearOrDayun) {
                            // 流年/大运天干五合：不要求相邻，但必须地支有根
                            let hasRoot = false;
                            let rootDetails = '';
                            
                            // 检查对应位置的地支是否有通根支持
                            const branch1 = allBranches[i];
                            const branch2 = allBranches[j];
                            
                            // 获取月令用于通根检查
                            let currentMonthBranch = '';
                            try {
                                const pillars = window.currentPillars || {};
                                currentMonthBranch = pillars.month ? pillars.month.charAt(1) : '';
                            } catch (e) {
                                console.log('获取月令失败，使用默认值');
                                currentMonthBranch = '';
                            }
                            
                            // 检查合化天干在对应地支中的通根支持
                            const rootInfo = checkHehuaSupport(hehuaElement, [branch1, branch2], currentMonthBranch);
                            hasRoot = rootInfo.canHehua;
                            rootDetails = rootInfo.details || rootInfo.reason || '';
                            
                            if (hasRoot) {
                                combined.tianGanWuHe.push({
                                    gan1: stem1,
                                    gan2: stem2,
                                    element: hehuaElement,
                                    positions: [i, j],
                                    hasRoot: hasRoot,
                                    rootDetails: rootDetails,
                                    isCurrentYear: (stem1 === yearStem || stem2 === yearStem),
                                    isCurrentDayun: (stem1 === dayunStem || stem2 === dayunStem),
                                    type: '流年大运合化',
                                    strengthType: rootInfo.type
                                });
                                console.log(`流年/大运天干五合成功：${stem1}${stem2}合化${hehuaElement}，通根支持：${rootDetails}，强度：${rootInfo.type}`);
                            } else {
                                console.log(`流年/大运天干五合失败：${stem1}${stem2}合化无效，原因：${rootDetails}`);
                            }
                        } else {
                            // 本命局内部天干五合（已在其他地方处理，这里暂不处理）
                            console.log(`本命局内部天干五合：${stem1}${stem2}，由本命局合化逻辑处理`);
                        }
                    }
                }
            }
            
            // 检查地支六合（修复版：添加严格的相邻性和透出检查）
            console.log('当前分析-检查地支六合，地支数组:', allBranches);
            
            // 定义地支的顺序位置（用于检查真正的相邻性）
            const branchOrder = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
            
            // 检查是否为真正相邻的地支（在十二地支顺序中相邻）
            function isAdjacentBranches(branch1, branch2) {
                const index1 = branchOrder.indexOf(branch1);
                const index2 = branchOrder.indexOf(branch2);
                if (index1 === -1 || index2 === -1) return false;
                
                // 检查是否相邻（包括子亥相邻的情况）
                const diff = Math.abs(index1 - index2);
                return diff === 1 || diff === 11; // 相邻或者子亥相邻
            }
            
            // 检查天干是否透出指定五行的辅助函数
            function checkTransparentElement(element, stems) {
                const elementToStems = {
                    'wood': ['甲', '乙'],
                    'fire': ['丙', '丁'],
                    'earth': ['戊', '己'],
                    'metal': ['庚', '辛'],
                    'water': ['壬', '癸']
                };
                
                const targetStems = elementToStems[element] || [];
                return stems.some(stem => targetStems.includes(stem));
            }
            
            // 获取五行中文名称
            function getElementChinese(element) {
                const elementNames = {
                    'wood': '木', 'fire': '火', 'earth': '土', 'metal': '金', 'water': '水'
                };
                return elementNames[element] || element;
            }
            
            for (let i = 0; i < allBranches.length; i++) {
                for (let j = i + 1; j < allBranches.length; j++) {
                    const branch1 = allBranches[i];
                    const branch2 = allBranches[j];
                    const pair1 = branch1 + branch2;
                    const pair2 = branch2 + branch1;
                    console.log(`当前分析-检查地支对: ${branch1}${branch2} (${pair1}) 和 ${branch2}${branch1} (${pair2})`);
                    
                    // 创建唯一标识，按字母顺序排序避免重复
                    const uniqueKey = [branch1, branch2].sort().join('');
                    
                    if ((diZhiLiuHe[pair1] || diZhiLiuHe[pair2]) && !processedDiZhi.has(uniqueKey)) {
                        const hehuaElement = diZhiLiuHe[pair1] || diZhiLiuHe[pair2];
                        processedDiZhi.add(uniqueKey);
                        
                        // 严格检查：必须在八字中相邻且在地支顺序中也相邻
                        const isPositionAdjacent = Math.abs(i - j) === 1; // 在八字中相邻
                        const isBranchAdjacent = isAdjacentBranches(branch1, branch2);
                        
                        if (!isPositionAdjacent) {
                            console.log(`❌ 当前分析-地支六合失败: ${branch1}${branch2} - 在八字中不相邻（位置${i},${j}），不能合化`);
                            continue;
                        }
                        
                        if (!isBranchAdjacent) {
                            console.log(`❌ 当前分析-地支六合失败: ${branch1}${branch2} - 地支不相邻，不能合化`);
                            continue;
                        }
                        
                        // 检查天干是否透出合化后的五行（六合成功的必要条件）
                        const hasTransparent = checkTransparentElement(hehuaElement, allStems);
                        
                        if (!hasTransparent) {
                            console.log(`❌ 当前分析-地支六合失败: ${branch1}${branch2} 合${getElementChinese(hehuaElement)} - 天干没有${getElementChinese(hehuaElement)}透出`);
                            // 记录为绊合而非合化
                            combined.diZhiLiuHe.push({
                                zhi1: branch1,
                                zhi2: branch2,
                                element: hehuaElement,
                                positions: [i, j],
                                isCurrentYear: (branch1 === yearBranch || branch2 === yearBranch),
                                isCurrentDayun: (branch1 === dayunBranch || branch2 === dayunBranch),
                                hasTransparent: false,
                                onlyBind: true,
                                bindReason: `天干没有${getElementChinese(hehuaElement)}透出`
                            });
                            continue;
                        }
                        
                        // 六合成功
                        combined.diZhiLiuHe.push({
                            zhi1: branch1,
                            zhi2: branch2,
                            element: hehuaElement,
                            positions: [i, j],
                            isCurrentYear: (branch1 === yearBranch || branch2 === yearBranch),
                            isCurrentDayun: (branch1 === dayunBranch || branch2 === dayunBranch),
                            hasTransparent: true,
                            isAdjacent: true
                        });
                        
                        // 如果月支（位置1）参与六合，更新月令元素
                        if (i === 1 || j === 1) {
                            combined.monthElement = hehuaElement;
                            console.log(`当前分析-月支参与六合: ${branch1}${branch2} 合化为${getElementChinese(hehuaElement)}，月令元素更新为${hehuaElement}`);
                        }
                        
                        console.log(`✅ 当前分析-地支六合成功: ${branch1}${branch2} 合化为${getElementChinese(hehuaElement)}（相邻+天干透出）`);
                    }
                }
            }
            
            // 检查地支三合（修复版：严格验证存在性和相邻性）
            diZhiSanHe.forEach(sanhe => {
                const matches = [];
                const requiredBranches = sanhe.branches;
                
                // 严格检查：首先验证所有必需的地支是否都存在
                const existingBranches = [];
                requiredBranches.forEach(branch => {
                    const indices = allBranches.map((b, i) => b === branch ? i : -1).filter(i => i !== -1);
                    if (indices.length > 0) {
                        matches.push({branch, indices});
                        existingBranches.push(branch);
                    }
                });
                
                // 关键修复：对于半三合，必须确保存在的地支确实能形成有效的三合组合
                // 不能仅仅因为有2个地支就认为是半三合，必须验证这2个地支是否是三合局的有效组合
                const isValidPartialCombination = (existing) => {
                    if (existing.length < 2) return false;
                    if (existing.length >= 3) return true; // 全三合
                    
                    // 对于半三合，必须确保存在的地支确实属于同一个三合局
                    // 并且不能是错误的组合（比如亥卯未中只有亥未，缺少关键的卯）
                    const validPartialCombos = {
                         '申子辰': [['申', '子'], ['子', '辰'], ['申', '辰']],
                         '亥卯未': [['亥', '卯'], ['卯', '未']], // 移除亥未组合，因为它们不相邻且缺少关键的卯
                         '寅午戌': [['寅', '午'], ['午', '戌'], ['寅', '戌']],
                         '巳酉丑': [['巳', '酉'], ['酉', '丑'], ['巳', '丑']]
                     };
                    
                    const comboKey = requiredBranches.join('');
                    const validCombos = validPartialCombos[comboKey] || [];
                    
                    // 检查当前存在的地支组合是否在有效的半三合列表中
                    const currentCombo = existing.sort();
                    return validCombos.some(validCombo => {
                        const sortedValid = validCombo.sort();
                        return currentCombo.length === sortedValid.length && 
                               currentCombo.every((branch, index) => branch === sortedValid[index]);
                    });
                };
                
                // 特别针对亥卯未三合局的调试
                if (requiredBranches.join('') === '亥卯未') {
                    console.log(`🔍 特别检查亥卯未三合局:`, {
                        required: requiredBranches,
                        allBranches: allBranches,
                        found: matches.map(m => m.branch),
                        foundCount: matches.length,
                        详细匹配: matches
                    });
                }
                
                console.log(`检查三合局 ${requiredBranches.join('')}:`, {
                    required: requiredBranches,
                    found: matches.map(m => m.branch),
                    allBranches: allBranches,
                    foundCount: matches.length
                });
                
                // 严格要求：使用新的验证逻辑检查三合局的有效性
                // 全三合需要3个地支，半三合需要2个地支且必须是有效组合
                const hasValidBranchCombination = matches.length === 3 || 
                    (matches.length === 2 && isValidPartialCombination(existingBranches));
                
                if (hasValidBranchCombination && matches.length >= 2) {
                    // 严格的相邻性检查：确保地支在八字中真正相邻
                    let isValidAdjacency = false;
                    
                    if (matches.length === 3) {
                        // 全三合：必须有连续的三个位置，且三个地支都存在
                        const allPositions = [];
                        matches.forEach(match => {
                            allPositions.push(...match.indices);
                        });
                        allPositions.sort((a, b) => a - b);
                        
                        // 检查是否有连续的三个位置
                        for (let i = 0; i <= allPositions.length - 3; i++) {
                            if (allPositions[i+1] === allPositions[i] + 1 && 
                                allPositions[i+2] === allPositions[i] + 2) {
                                // 进一步验证：确保这三个位置对应的地支确实是三合局的三个成员
                                const branchesAtPositions = [
                                    allBranches[allPositions[i]],
                                    allBranches[allPositions[i+1]], 
                                    allBranches[allPositions[i+2]]
                                ];
                                const hasAllRequired = requiredBranches.every(branch => 
                                    branchesAtPositions.includes(branch)
                                );
                                if (hasAllRequired) {
                                    isValidAdjacency = true;
                                    break;
                                }
                            }
                        }
                        
                        console.log(`全三合检查 ${requiredBranches.join('')}: 位置${allPositions}, 连续性=${isValidAdjacency}`);
                    } else if (matches.length === 2) {
                        // 半三合：必须两个地支相邻，且确实是三合局的成员
                        const positions = [];
                        matches.forEach(match => {
                            positions.push(...match.indices);
                        });
                        
                        // 检查任意两个位置是否相邻
                        for (let i = 0; i < positions.length; i++) {
                            for (let j = i + 1; j < positions.length; j++) {
                                if (Math.abs(positions[i] - positions[j]) === 1) {
                                    // 进一步验证：确保这两个位置的地支确实是三合局的成员
                                    const branch1 = allBranches[positions[i]];
                                    const branch2 = allBranches[positions[j]];
                                    if (requiredBranches.includes(branch1) && requiredBranches.includes(branch2)) {
                                        isValidAdjacency = true;
                                        break;
                                    }
                                }
                            }
                            if (isValidAdjacency) break;
                        }
                        
                        console.log(`半三合检查 ${requiredBranches.join('')}: 位置${positions}, 相邻性=${isValidAdjacency}`);
                    }
                    
                    // 只有通过严格验证的三合局才被认定为有效
                    if (isValidAdjacency) {
                        combined.diZhiSanHe.push({
                            type: sanhe.branches.join(''),
                            element: sanhe.element,
                            count: matches.length,
                            branches: matches.map(m => m.branch).join(''),
                            isCurrentYear: matches.some(m => m.indices.some(idx => allBranches[idx] === yearBranch)),
                            isCurrentDayun: matches.some(m => m.indices.some(idx => allBranches[idx] === dayunBranch)),
                            isValid: true,
                            positions: matches.flatMap(m => m.indices)
                        });
                        console.log(`✅ 有效三合局: ${requiredBranches.join('')}${matches.length === 3 ? '全' : '半'}三合${sanhe.element}局`);
                    } else {
                        console.log(`❌ 无效三合局: ${requiredBranches.join('')} - 地支不相邻或不完整，不能合化`);
                    }
                } else {
                    console.log(`❌ 无效三合局: ${requiredBranches.join('')} - 缺少必要地支 (需要${matches.length}/3个)`);
                }
            });
            
            // 若存在三合，则与其共享任意一个地支的六合不再单独计算（避免重复计入）
            if (combined.diZhiSanHe.length > 0 && combined.diZhiLiuHe.length > 0) {
                const sanHeBranchSet = new Set();
                combined.diZhiSanHe.forEach(h => {
                    const branches = (h.type || '').split('');
                    branches.forEach(b => sanHeBranchSet.add(b));
                });
                combined.diZhiLiuHe = combined.diZhiLiuHe.filter(h => !sanHeBranchSet.has(h.zhi1) && !sanHeBranchSet.has(h.zhi2));
            }
            
            return combined;
        }

        // 显示当前身强身弱分析图表
        function displayCurrentStrengthChart(currentStrengthData) {
            console.log('显示当前身强身弱分析，数据:', currentStrengthData);
            
            const canvas = document.getElementById('current-strength-chart');
            const ctx = canvas.getContext('2d');
            
            // 调试信息：检查数据值
            console.log('当前运势图表数据:', {
                supportStrength: currentStrengthData.supportStrength,
                weakenStrength: currentStrengthData.weakenStrength,
                canvasWidth: canvas.clientWidth,
                canvasHeight: canvas.clientHeight
            });
            
            // 强制重置canvas尺寸
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            if (currentStrengthChart) {
                currentStrengthChart.destroy();
            }
            
            currentStrengthChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['生扶力量', '克泄力量'],
                    datasets: [{
                        label: '力量对比',
                        data: [currentStrengthData.supportStrength, currentStrengthData.weakenStrength],
                        backgroundColor: [
                            '#27ae60', // 生扶 - 绿色
                            '#e74c3c'  // 克泄 - 红色
                        ],
                        borderWidth: 2,
                        borderColor: '#fff',
                        barThickness: 60,
                        maxBarThickness: 80
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const yVal = typeof context.parsed.y === 'number' ? context.parsed.y : parseFloat(context.parsed.y);
                                    return `${context.label}: ${yVal.toFixed(2)}点`;
                                }
                            }
                        },
                        datalabels: {
                            anchor: 'end',
                            align: 'end',
                            formatter: (value) => Number(value).toFixed(2),
                            color: '#333',
                            font: {
                                size: 12,
                                weight: 'bold'
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            title: {
                                display: true,
                                text: '力量值',
                                font: {
                                    size: 12
                                }
                            },
                            ticks: {
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    return Number(value).toFixed(2);
                                }
                            }
                        }
                    }
                }
            });
            
            // 显示当前身强身弱分析描述
            const description = document.getElementById('current-strength-description');
            
            // 根据不同类型设置不同的图标和颜色（12级分类系统）
            let typeIcon, typeColor;
            switch(currentStrengthData.type) {
                case '极弱（从弱）':
                case '从弱':
                    typeIcon = 'fa-arrow-down';
                    typeColor = '#2c3e50';
                    break;
                case '很弱':
                case '较弱':
                    typeIcon = 'fa-snowflake';
                    typeColor = '#3498db';
                    break;
                case '稍弱':
                case '微弱':
                    typeIcon = 'fa-thermometer-quarter';
                    typeColor = '#5dade2';
                    break;
                case '中和偏弱':
                    typeIcon = 'fa-balance-scale';
                    typeColor = '#85c1e9';
                    break;
                case '真正中和':
                    typeIcon = 'fa-yin-yang';
                    typeColor = '#f39c12';
                    break;
                case '中和偏强':
                    typeIcon = 'fa-balance-scale';
                    typeColor = '#f8c471';
                    break;
                case '微强':
                case '稍强':
                    typeIcon = 'fa-thermometer-three-quarters';
                    typeColor = '#f7dc6f';
                    break;
                case '较强':
                    typeIcon = 'fa-fire';
                    typeColor = '#e74c3c';
                    break;
                case '极强（专旺）':
                case '从强':
                    typeIcon = 'fa-arrow-up';
                    typeColor = '#9b59b6';
                    break;
                // 兼容旧版本
                case '身强':
                    typeIcon = 'fa-fire';
                    typeColor = '#e74c3c';
                    break;
                case '身弱':
                    typeIcon = 'fa-snowflake';
                    typeColor = '#3498db';
                    break;
                case '均衡':
                    typeIcon = 'fa-balance-scale';
                    typeColor = '#f39c12';
                    break;
                case '从弱':
                    typeIcon = 'fa-arrow-down';
                    typeColor = '#2ecc71';
                    break;
                default:
                    typeIcon = 'fa-balance-scale';
                    typeColor = '#7f8c8d';
            }
            
            description.innerHTML = `
                <h4><i class="fas fa-clock"></i> 当前身强身弱分析</h4>
                <div style="background-color: #e8f6f3; padding: 12px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #1abc9c;">
                    <p style="margin: 0; font-size: 0.95rem;"><strong>当前流年:</strong> ${currentStrengthData.currentYear}年 ${currentStrengthData.currentYearGanZhi}</p>
                    <p style="margin: 5px 0 0 0; font-size: 0.95rem;"><strong>当前大运:</strong> ${currentStrengthData.currentDayun}</p>
                </div>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <div style="background-color: ${typeColor}; color: white; padding: 5px 10px; border-radius: 5px; margin-right: 10px;">
                        <i class="fas ${typeIcon}"></i> ${currentStrengthData.type}
                    </div>
                    <div>力量比例: ${currentStrengthData.strengthPercentage.toFixed(2)}%</div>
                </div>
                <p><strong>生扶力量:</strong> ${currentStrengthData.supportStrength.toFixed(2)}点</p>
                <p><strong>克泄力量:</strong> ${currentStrengthData.weakenStrength.toFixed(2)}点</p>
                ${currentStrengthData.monthScore ? `<p><strong>月令得分:</strong> ${currentStrengthData.monthScore}点</p>` : ''}
                ${currentStrengthData.combined && currentStrengthData.combined.effect ? `<p><strong>合化影响:</strong> ${currentStrengthData.combined.effect === 'strengthen' ? '增强日主' : '削弱日主'}</p>` : ''}
                ${currentStrengthData.combined && currentStrengthData.combined.deduction ? `<p><strong>合化扣分:</strong> <span style="color: #e74c3c; font-weight: bold;">${currentStrengthData.combined.deduction}点</span></p>` : ''}
                <div class="current-hehua-info">
                ${currentStrengthData.combined && (currentStrengthData.combined.tianGanWuHe.length > 0 || currentStrengthData.combined.diZhiLiuHe.length > 0 || currentStrengthData.combined.diZhiSanHe.length > 0) ? 
                   `<div style="background-color: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid #ffc107; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                       <h5 style="color: #856404; margin-top: 0; font-size: 16px;"><i class="fas fa-link"></i> 当前合化信息</h5>
                       ${currentStrengthData.combined.tianGanWuHe.length > 0 ? 
                           `<div style="margin-bottom: 10px;">
                               <p><strong>天干五合:</strong> ${currentStrengthData.combined.tianGanWuHe.map(h => {
                                   const elementName = h.element === 'wood' ? '木' : h.element === 'fire' ? '火' : h.element === 'earth' ? '土' : h.element === 'metal' ? '金' : '水';
                                   const yearFlag = h.isCurrentYear ? '(流年)' : '';
                                   const dayunFlag = h.isCurrentDayun ? '(大运)' : '';
                                   return `${h.gan1}${h.gan2}合${elementName}${yearFlag}${dayunFlag}`;
                               }).join('、')}</p>
                           </div>` : ''}
                       ${currentStrengthData.combined.diZhiLiuHe.length > 0 ? 
                           `<div style="margin-bottom: 10px;">
                               <p><strong>地支六合:</strong> ${currentStrengthData.combined.diZhiLiuHe.map(h => {
                                   const elementName = h.element === 'wood' ? '木' : h.element === 'fire' ? '火' : h.element === 'earth' ? '土' : h.element === 'metal' ? '金' : '水';
                                   const yearFlag = h.isCurrentYear ? '(流年)' : '';
                                   const dayunFlag = h.isCurrentDayun ? '(大运)' : '';
                                   return `${h.zhi1}${h.zhi2}合${elementName}${yearFlag}${dayunFlag}`;
                               }).join('、')}</p>
                           </div>` : ''}
                       ${currentStrengthData.combined.diZhiSanHe.length > 0 ? 
                           `<div style="margin-bottom: 10px;">
                               <p><strong>地支三合:</strong> ${currentStrengthData.combined.diZhiSanHe.map(h => {
                                   const elementName = h.element === 'wood' ? '木' : h.element === 'fire' ? '火' : h.element === 'earth' ? '土' : h.element === 'metal' ? '金' : '水';
                                   const yearFlag = h.isCurrentYear ? '(流年)' : '';
                                   const dayunFlag = h.isCurrentDayun ? '(大运)' : '';
                                   return `${h.type}三合${elementName}(${h.count === 3 ? '全三合' : '半三合'})${yearFlag}${dayunFlag}`;
                               }).join('、')}</p>
                           </div>` : ''}
                       <p><strong>对日主影响:</strong> <span style="color: ${currentStrengthData.combined.effect === 'strengthen' ? '#27ae60' : currentStrengthData.combined.effect === 'weaken' ? '#e74c3c' : '#7f8c8d'}; font-weight: bold;">${currentStrengthData.combined.effect === 'strengthen' ? '增强日主' : currentStrengthData.combined.effect === 'weaken' ? '削弱日主' : '影响中性'}</span></p>
                       ${currentStrengthData.combined.deduction ? `<p><strong>力量扣减:</strong> <span style="color: #e74c3c; font-weight: bold;">${currentStrengthData.combined.deduction}点</span> (合化影响)</p>` : ''}
                   </div>` : `<div style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; border: 1px dashed #ccc;">
                       <p style="color: #7f8c8d; margin: 0;"><i class="fas fa-info-circle"></i> 未检测到当前合化</p>
                   </div>`}
                </div>
                <p><strong>分析说明:</strong> ${currentStrengthData.description}</p>
                

            `;
            
            // 调整图表容器和描述容器的样式，确保左右并排显示
            const currentStrengthAnalysisFrame = document.querySelector('.current-strength-analysis-frame');
            const currentChartContainer = document.querySelector('.current-chart-container');
            const currentDescriptionContainer = document.getElementById('current-strength-description');
            
            if (currentStrengthAnalysisFrame && currentChartContainer && currentDescriptionContainer) {
                // 确保上下排列显示
                currentStrengthAnalysisFrame.style.display = 'flex';
                currentStrengthAnalysisFrame.style.flexDirection = 'column';
                currentStrengthAnalysisFrame.style.gap = '20px';
                currentStrengthAnalysisFrame.style.flexWrap = 'wrap';
                
                // 设置图表容器样式 - 注释掉以避免覆盖CSS样式
                // currentChartContainer.style.flex = '1';
                // currentChartContainer.style.minWidth = '300px';
                // currentChartContainer.style.minHeight = '350px';
                // currentChartContainer.style.backgroundColor = '#ffffff';
                // currentChartContainer.style.padding = '15px';
                // currentChartContainer.style.borderRadius = '8px';
                // currentChartContainer.style.boxShadow = '0 2px 4px rgba(0,0,0,0.05)';
                
                // 设置描述容器样式
                currentDescriptionContainer.style.flex = '1';
                currentDescriptionContainer.style.minWidth = '300px';
                currentDescriptionContainer.style.padding = '15px';
                currentDescriptionContainer.style.backgroundColor = '#f9f9f9';
                currentDescriptionContainer.style.borderRadius = '8px';
                currentDescriptionContainer.style.boxShadow = '0 2px 4px rgba(0,0,0,0.05)';
            }
        }

        // 全局变量存储分数详情
        let fateScoreDetails = {};
        let wealthScoreDetails = {};
        let fateScoreValue = 0;
        let wealthScoreValue = 0;

        // 计算命格等级 - 高级专业版
        function calculateFateLevel(pillars) {
            const score = calculateFateScore(pillars);
            const levelInfo = getFateLevel(score);
            
            return {
                score: score,
                level: levelInfo.name,
                description: getFateDescription(score),
                details: fateScoreDetails
            };
        }

        // 计算命格分数 - 专业版算法
        function calculateFateScore(pillars) {
            if (fateScoreValue === 0) {
                // 确保输入是字符串
                const dayStr = typeof pillars.day === 'string' ? pillars.day : String(pillars.day);
                const monthStr = typeof pillars.month === 'string' ? pillars.month : String(pillars.month);
                const yearStr = typeof pillars.year === 'string' ? pillars.year : String(pillars.year);
                const hourStr = typeof pillars.hour === 'string' ? pillars.hour : String(pillars.hour);
                
                // 创建安全的pillars对象
                const safePillars = {
                    year: yearStr,
                    month: monthStr,
                    day: dayStr,
                    hour: hourStr
                };
                
                // 核心基础评分（总计70分）- 传统八字命理核心要素
                const seasonScore = Math.round(calculateAdvancedSeasonScore(safePillars) * 0.67); // 20分
                const balanceScore = Math.round(calculateAdvancedBalanceScore(safePillars) * 0.6);  // 15分
                const patternScore = Math.round(calculateAdvancedPatternScore(safePillars) * 0.6);  // 15分
                const godsScore = Math.round(calculateAdvancedGodsScore(safePillars) * 0.5);        // 10分
                const combinationScore = Math.round(calculateAdvancedCombinationScore(safePillars) * 0.67); // 10分
                
                // 辅助修正评分（总计20分）
                const dayMasterStrength = Math.round(calculateDayMasterStrengthScore(safePillars) * 0.6); // 6分
                const usefulGodScore = Math.round(calculateUsefulGodScore(safePillars) * 0.5);       // 6分
                const tabooGodControl = Math.round(calculateTabooGodControlScore(safePillars) * 0.5); // 4分
                const adjustmentScore = Math.round(calculateSeasonalAdjustmentScore(safePillars) * 0.5); // 4分
                
                // 运势与特殊加分（总计10分）
                const luckSupport = Math.round(calculateLuckSupportScore(safePillars) * 0.3);       // 3分
                const dayunCoordination = Math.round(calculateDayunCoordinationScore(safePillars) * 0.25); // 2分
                
                // 根据特殊格局调整贵人助力和格局加分的系数
                const baziData = window.currentBaziData || {};
                const specialPattern = detectSpecialPattern(safePillars, baziData);
                const isHighNoblePattern = specialPattern && (specialPattern.includes('日贵') || specialPattern.includes('魁罡'));
                
                const noblesSupport = Math.round(calculateNoblesSupportScore(safePillars) * (isHighNoblePattern ? 0.8 : 0.33));  // 高贵格局提高贵人助力系数
                const levelBonus = Math.round(calculateLevelBonus(safePillars) * 0.2);              // 3分
                
                // 特殊格局加分（可超出100分上限）- 提高系数以体现格局价值
                const specialPatternBonus = Math.round(calculateSpecialPatternBonus(safePillars) * (isHighNoblePattern ? 0.8 : 0.6)); // 高贵格局最高20分，其他格局最高18分
                
                // 扣分项
                const kongWangPenalty = Math.round(calculateKongWangPenalty(safePillars) * 0.33); // 最高5分扣除
                
                // 基础模块合计（用于“基础合计”展示：季节助力、五行平衡、格局结构、十神影响、组合刑冲、调候用神）
                const baseModulesTotal = seasonScore + balanceScore + patternScore + godsScore + combinationScore + adjustmentScore;
                // 取消固定基础分，保持为0
                const baseScore = 0;
                
                const total = 10 + seasonScore + balanceScore + patternScore + godsScore + combinationScore +
                             dayMasterStrength + usefulGodScore + tabooGodControl + adjustmentScore +
                             luckSupport + dayunCoordination + noblesSupport + levelBonus + specialPatternBonus - kongWangPenalty;
                
                fateScoreDetails = {
                    seasonScore,
                    balanceScore,
                    patternScore,
                    godsScore,
                    combinationScore,
                    adjustmentScore,
                    dayMasterStrength,
                    usefulGodScore,
                    tabooGodControl,
                    kongWangPenalty,
                    luckSupport,
                    dayunCoordination,
                    noblesSupport,
                    specialPatternBonus,
                    levelBonus,
                    // 基础合计展示为核心模块合计
                    baseScore: seasonScore + balanceScore + patternScore + godsScore + combinationScore,
                    total
                };
                
                // 确保分数在合理范围内（10-120分）
                fateScoreValue = Math.max(10, Math.min(120, Math.round(total)));
            }
            return fateScoreValue;
        }

        // 高级季节助力评分 - 连续化评分，考虑月令强弱和通根透干
        function calculateAdvancedSeasonScore(pillars) {
            const dayStem = pillars.day.charAt(0);
            const monthBranch = pillars.month.charAt(1);
            const dayBranch = pillars.day.charAt(1);
            
            // 月令得分基础
            let baseScore = calculateMonthlyStrength(dayStem, monthBranch);
            
            // 通根透干加分
            const rootScore = calculateRootStrength(dayStem, pillars);
            
            // 透干加分
            const transparentScore = calculateTransparentStrength(dayStem, pillars);
            
            // 调候因子
            const seasonalAdjustment = calculateSeasonalAdjustment(dayStem, monthBranch);
            
            const finalScore = (baseScore + rootScore + transparentScore) * seasonalAdjustment;
            
            // 调试输出季节助力详细计算
            console.log('=== HTML季节助力详细计算 ===');
            console.log('日主: ' + dayStem + ', 月支: ' + monthBranch);
            console.log('月令基础分: ' + baseScore);
            console.log('通根加分: ' + rootScore);
            console.log('透干加分: ' + transparentScore);
            console.log('调候因子: ' + seasonalAdjustment);
            console.log('原始总分: ' + (baseScore + rootScore + transparentScore));
            console.log('调候调整后: ' + finalScore);
            console.log('最终限制后: ' + Math.max(0, Math.min(30, finalScore)));
            console.log('========================');
            
            return Math.max(0, Math.min(30, finalScore));
        }

        // 月令强弱评分
        function calculateMonthlyStrength(dayStem, monthBranch) {
            const strengthMap = {
                // 木日主
                '甲': { '寅': 25, '卯': 30, '辰': 20, '巳': 8, '午': 12, '未': 15, '申': 5, '酉': 3, '戌': 12, '亥': 18, '子': 15, '丑': 10 },
                '乙': { '寅': 20, '卯': 25, '辰': 18, '巳': 10, '午': 15, '未': 18, '申': 3, '酉': 5, '戌': 10, '亥': 20, '子': 18, '丑': 12 },
                // 火日主
                '丙': { '寅': 18, '卯': 15, '辰': 10, '巳': 25, '午': 30, '未': 20, '申': 8, '酉': 5, '戌': 15, '亥': 3, '子': 5, '丑': 8 },
                '丁': { '寅': 15, '卯': 12, '辰': 8, '巳': 20, '午': 25, '未': 18, '申': 5, '酉': 8, '戌': 12, '亥': 5, '子': 3, '丑': 10 },
                // 土日主
                '戊': { '寅': 8, '卯': 5, '辰': 25, '巳': 20, '午': 18, '未': 30, '申': 12, '酉': 15, '戌': 25, '亥': 3, '子': 5, '丑': 20 },
                '己': { '寅': 5, '卯': 8, '辰': 20, '巳': 18, '午': 15, '未': 25, '申': 10, '酉': 12, '戌': 20, '亥': 5, '子': 8, '丑': 25 },
                // 金日主
                '庚': { '寅': 3, '卯': 5, '辰': 12, '巳': 8, '午': 5, '未': 10, '申': 25, '酉': 30, '戌': 15, '亥': 8, '子': 10, '丑': 18 },
                '辛': { '寅': 5, '卯': 3, '辰': 10, '巳': 5, '午': 8, '未': 12, '申': 20, '酉': 25, '戌': 12, '亥': 10, '子': 12, '丑': 20 },
                // 水日主
                '壬': { '寅': 10, '卯': 8, '辰': 5, '巳': 3, '午': 5, '未': 8, '申': 15, '酉': 12, '戌': 8, '亥': 25, '子': 30, '丑': 18 },
                '癸': { '寅': 8, '卯': 10, '辰': 8, '巳': 5, '午': 3, '未': 10, '申': 12, '酉': 15, '戌': 5, '亥': 20, '子': 25, '丑': 15 }
            };
            
            return strengthMap[dayStem]?.[monthBranch] || 10;
        }

        // 通根强度计算
        function calculateRootStrength(dayStem, pillars) {
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            const elementMap = getElementMap();
            const dayElement = elementMap[dayStem];
            
            let rootScore = 0;
            
            branches.forEach((branch, index) => {
                const hiddenStems = getHiddenStems(branch);
                const mainStem = hiddenStems[0]; // 主气
                
                // 主气同类加分
                if (elementMap[mainStem] === dayElement) {
                    const weight = index === 2 ? 1.5 : 1.0; // 日支权重更高
                    rootScore += 8 * weight;
                }
                
                // 藏干同类加分
                hiddenStems.slice(1).forEach(stem => {
                    if (elementMap[stem] === dayElement) {
                        const weight = index === 2 ? 1.2 : 0.8;
                        rootScore += 3 * weight;
                    }
                });
            });
            
            return Math.min(15, rootScore);
        }

        // 透干强度计算
        function calculateTransparentStrength(dayStem, pillars) {
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            const elementMap = getElementMap();
            const dayElement = elementMap[dayStem];
            
            let transparentScore = 0;
            
            stems.forEach((stem, index) => {
                if (elementMap[stem] === dayElement) {
                    const weight = index === 1 ? 1.2 : 1.0; // 月干权重稍高
                    transparentScore += 6 * weight;
                }
            });
            
            return Math.min(12, transparentScore);
        }

        // 调候因子计算
        function calculateSeasonalAdjustment(dayStem, monthBranch) {
            // 调候表：不同日主在不同月份的调候因子
            const adjustmentMap = {
                '甲': { '寅': 1.1, '卯': 1.2, '辰': 1.0, '巳': 0.8, '午': 0.7, '未': 0.8, '申': 0.9, '酉': 0.8, '戌': 0.9, '亥': 1.0, '子': 0.9, '丑': 0.9 },
                '乙': { '寅': 1.0, '卯': 1.1, '辰': 1.0, '巳': 0.9, '午': 1.0, '未': 1.0, '申': 0.7, '酉': 0.6, '戌': 0.8, '亥': 1.1, '子': 1.0, '丑': 0.9 },
                '丙': { '寅': 1.0, '卯': 0.9, '辰': 0.8, '巳': 1.2, '午': 1.3, '未': 1.1, '申': 0.8, '酉': 0.7, '戌': 0.9, '亥': 0.6, '子': 0.5, '丑': 0.7 },
                '丁': { '寅': 0.9, '卯': 0.8, '辰': 0.7, '巳': 1.1, '午': 1.2, '未': 1.0, '申': 0.7, '酉': 0.8, '戌': 0.8, '亥': 0.7, '子': 0.6, '丑': 0.8 },
                '戊': { '寅': 0.8, '卯': 0.7, '辰': 1.2, '巳': 1.1, '午': 1.0, '未': 1.3, '申': 0.9, '酉': 1.0, '戌': 1.2, '亥': 0.6, '子': 0.5, '丑': 1.0 },
                '己': { '寅': 0.7, '卯': 0.8, '辰': 1.1, '巳': 1.0, '午': 0.9, '未': 1.2, '申': 0.8, '酉': 0.9, '戌': 1.1, '亥': 0.7, '子': 0.6, '丑': 1.1 },
                '庚': { '寅': 0.6, '卯': 0.5, '辰': 0.8, '巳': 0.9, '午': 0.7, '未': 0.8, '申': 1.3, '酉': 1.4, '戌': 1.0, '亥': 0.8, '子': 0.9, '丑': 1.0 },
                '辛': { '寅': 0.7, '卯': 0.6, '辰': 0.9, '巳': 0.8, '午': 0.8, '未': 0.9, '申': 1.2, '酉': 1.3, '戌': 0.9, '亥': 0.9, '子': 1.0, '丑': 1.1 },
                '壬': { '寅': 0.9, '卯': 0.8, '辰': 0.7, '巳': 0.6, '午': 0.5, '未': 0.7, '申': 1.0, '酉': 0.9, '戌': 0.8, '亥': 1.3, '子': 1.4, '丑': 1.1 },
                '癸': { '寅': 0.8, '卯': 0.9, '辰': 0.8, '巳': 0.7, '午': 0.6, '未': 0.8, '申': 0.9, '酉': 1.0, '戌': 0.7, '亥': 1.2, '子': 1.3, '丑': 1.0 }
            };
            
            return adjustmentMap[dayStem]?.[monthBranch] || 1.0;
        }

        // 高级五行平衡评分 - 基于流通有情、偏枯有救、战克无解的评判标准
        function calculateAdvancedBalanceScore(pillars) {
            const elementMap = getElementMap();
            const elements = { '木': 0, '火': 0, '土': 0, '金': 0, '水': 0 };
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.day.charAt(0), pillars.hour.charAt(0)];
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 1. 天干能量计算（权重：3分）
            stems.forEach((stem, index) => {
                const element = elementMap[stem];
                const weight = index === 2 ? 1.5 : 1.0; // 日干权重更高
                elements[element] += 3 * weight;
            });
            
            // 2. 地支主气能量计算（权重：2分）
            branches.forEach((branch, index) => {
                const hiddenStems = getHiddenStems(branch);
                const mainStem = hiddenStems[0];
                const element = elementMap[mainStem];
                const weight = index === 2 ? 1.3 : 1.0; // 日支权重稍高
                elements[element] += 2 * weight;
            });
            
            // 3. 藏干能量计算（权重递减：1.5, 1, 0.5分）
            branches.forEach((branch, branchIndex) => {
                const hiddenStems = getHiddenStems(branch);
                hiddenStems.slice(1).forEach((stem, stemIndex) => {
                    const element = elementMap[stem];
                    const baseWeight = [1.5, 1, 0.5][stemIndex] || 0.3;
                    const positionWeight = branchIndex === 2 ? 1.2 : 1.0;
                    elements[element] += baseWeight * positionWeight;
                });
            });
            
            // 4. 应用合化效果
            const combinedElements = applyElementCombinationEffects(elements, stems, branches);
            
            // 5. 应用刑冲破害效果
            const finalElements = applyElementConflictEffects(combinedElements, branches);
            
            // 6. 基于新标准计算平衡分数
            return calculateWuxingBalanceByStandards(finalElements, pillars);
        }
        
        // 基于流通有情、偏枯有救、战克无解标准的五行平衡评分
        function calculateWuxingBalanceByStandards(elements, pillars) {
            const values = Object.values(elements);
            const total = values.reduce((sum, val) => sum + val, 0);
            const average = total / 5;
            const maxElement = Math.max(...values);
            const minElement = Math.min(...values);
            
            // 检查流通有情（上等命格标准）
            const flowScore = checkElementFlow(elements, pillars);
            if (flowScore >= 8) {
                return Math.min(25, 20 + flowScore); // 流通有情：20-25分
            }
            
            // 检查偏枯有救（中等命格标准）
            const rescueScore = checkElementRescue(elements, pillars);
            if (rescueScore >= 5) {
                return Math.min(19, 12 + rescueScore); // 偏枯有救：12-19分
            }
            
            // 检查战克无解（下等命格标准）
            const conflictScore = checkElementConflict(elements, pillars);
            if (conflictScore <= 3) {
                return Math.max(1, 5 - conflictScore); // 战克无解：1-5分
            }
            
            // 标准平衡评分（中等偏下）
            const standardDeviation = Math.sqrt(values.reduce((sum, val) => sum + Math.pow(val - average, 2), 0) / 5);
            return Math.max(6, Math.min(15, 15 - standardDeviation * 1.2));
        }
        
        // 检查五行流通有情
        function checkElementFlow(elements, pillars) {
            const elementOrder = ['木', '火', '土', '金', '水'];
            let flowScore = 0;
            
            // 检查相生链条的完整性和力度
            for (let i = 0; i < 5; i++) {
                const current = elementOrder[i];
                const next = elementOrder[(i + 1) % 5];
                
                if (elements[current] > 0 && elements[next] > 0) {
                    // 有相生关系
                    const ratio = Math.min(elements[current], elements[next]) / Math.max(elements[current], elements[next]);
                    if (ratio > 0.6) {
                        flowScore += 2; // 力量相当，流通顺畅
                    } else if (ratio > 0.3) {
                        flowScore += 1; // 有流通但不够顺畅
                    }
                }
            }
            
            // 检查是否有完整的五行循环
            const presentElements = Object.keys(elements).filter(e => elements[e] > 0);
            if (presentElements.length >= 4) {
                flowScore += 2; // 五行齐全加分
            }
            
            // 检查是否有三合、三会等助力流通
            if (hasElementCombination(pillars)) {
                flowScore += 1;
            }
            
            return Math.min(10, flowScore);
        }
        
        // 检查偏枯有救
        function checkElementRescue(elements, pillars) {
            const values = Object.values(elements);
            const maxElement = Math.max(...values);
            const minElement = Math.min(...values);
            const ratio = maxElement / (minElement || 1);
            
            let rescueScore = 0;
            
            // 如果五行分布极不均匀（偏枯）
            if (ratio > 3) {
                // 检查是否有救应
                const strongElements = Object.keys(elements).filter(e => elements[e] >= maxElement * 0.8);
                const weakElements = Object.keys(elements).filter(e => elements[e] <= minElement * 1.5);
                
                // 检查强弱五行之间是否有调节关系
                for (const strong of strongElements) {
                    for (const weak of weakElements) {
                        if (canElementRescue(strong, weak, pillars)) {
                            rescueScore += 2;
                        }
                    }
                }
                
                // 检查是否有通关之神
                const mediatorScore = checkElementMediator(strongElements, weakElements, elements);
                rescueScore += mediatorScore;
            }
            
            return Math.min(8, rescueScore);
        }
        
        // 检查战克无解
        function checkElementConflict(elements, pillars) {
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.day.charAt(0), pillars.hour.charAt(0)];
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            let conflictScore = 10; // 满分开始扣分
            
            // 检查天干相冲相克
            const stemConflicts = checkStemConflicts(stems);
            conflictScore -= stemConflicts * 2;
            
            // 检查地支相冲相刑
            const branchConflicts = checkBranchConflicts(branches);
            conflictScore -= branchConflicts * 1.5;
            
            // 检查五行相克无制化
            const elementClashes = checkElementClashes(elements);
            conflictScore -= elementClashes * 1;
            
            // 检查是否有解救
            const rescueFactors = checkConflictRescue(pillars);
            conflictScore += rescueFactors;
            
            return Math.max(0, Math.min(10, conflictScore));
        }
        
        // 辅助函数：检查是否有五行组合
        function hasElementCombination(pillars) {
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 检查三合局
            const sanHeResult = checkStrictSanHe(branches);
            if (sanHeResult.isValid) return true;
            
            // 检查三会局
            const sanHuiResult = checkStrictSanHui(branches);
            if (sanHuiResult.isValid) return true;
            
            // 检查六合
            return hasLiuHe(branches);
        }
        
        // 检查五行是否能相救
        function canElementRescue(strongElement, weakElement, pillars) {
            // 检查是否有中间五行作为通关
            const elementOrder = ['木', '火', '土', '金', '水'];
            const strongIndex = elementOrder.indexOf(strongElement);
            const weakIndex = elementOrder.indexOf(weakElement);
            
            if (strongIndex === -1 || weakIndex === -1) return false;
            
            // 检查相生关系：强→中→弱
            const mediatorIndex = (strongIndex + 1) % 5;
            const mediatorElement = elementOrder[mediatorIndex];
            
            // 检查命局中是否有通关之神
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.day.charAt(0), pillars.hour.charAt(0)];
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            const elementMap = getElementMap();
            
            // 检查天干中是否有通关元素
            for (const stem of stems) {
                if (elementMap[stem] === mediatorElement) return true;
            }
            
            // 检查地支藏干中是否有通关元素
            for (const branch of branches) {
                const hiddenStems = getHiddenStems(branch);
                for (const hiddenStem of hiddenStems) {
                    if (elementMap[hiddenStem] === mediatorElement) return true;
                }
            }
            
            return false;
        }
        
        // 检查通关之神
        function checkElementMediator(strongElements, weakElements, elements) {
            const elementOrder = ['木', '火', '土', '金', '水'];
            let mediatorScore = 0;
            
            for (const strong of strongElements) {
                for (const weak of weakElements) {
                    const strongIndex = elementOrder.indexOf(strong);
                    const weakIndex = elementOrder.indexOf(weak);
                    
                    if (strongIndex !== -1 && weakIndex !== -1) {
                        // 检查是否有通关元素
                        const mediatorIndex = (strongIndex + 1) % 5;
                        const mediatorElement = elementOrder[mediatorIndex];
                        
                        if (elements[mediatorElement] > 0) {
                            mediatorScore += 1;
                        }
                    }
                }
            }
            
            return Math.min(3, mediatorScore);
        }
        
        // 检查天干冲突
        function checkStemConflicts(stems) {
            const conflictPairs = [
                ['甲', '庚'], ['乙', '辛'], ['丙', '壬'], ['丁', '癸']
            ];
            
            let conflicts = 0;
            const stemSet = new Set(stems);
            
            for (const [a, b] of conflictPairs) {
                if (stemSet.has(a) && stemSet.has(b)) {
                    conflicts++;
                }
            }
            
            return conflicts;
        }
        
        // 检查地支冲突
        function checkBranchConflicts(branches) {
            const conflictPairs = [
                ['子', '午'], ['丑', '未'], ['寅', '申'], ['卯', '酉'], ['辰', '戌'], ['巳', '亥']
            ];
            
            const xingGroups = [
                ['寅', '巳', '申'], ['丑', '戌', '未'], ['子', '卯']
            ];
            
            let conflicts = 0;
            const branchSet = new Set(branches);
            
            // 检查相冲
            for (const [a, b] of conflictPairs) {
                if (branchSet.has(a) && branchSet.has(b)) {
                    conflicts++;
                }
            }
            
            // 检查相刑
            for (const group of xingGroups) {
                const presentCount = group.filter(branch => branchSet.has(branch)).length;
                if (presentCount >= 2) {
                    conflicts += presentCount - 1;
                }
            }
            
            return conflicts;
        }
        
        // 检查五行相克
        function checkElementClashes(elements) {
            const clashPairs = [
                ['木', '土'], ['火', '金'], ['土', '水'], ['金', '木'], ['水', '火']
            ];
            
            let clashes = 0;
            
            for (const [克者, 被克者] of clashPairs) {
                if (elements[克者] > 0 && elements[被克者] > 0) {
                    const ratio = elements[克者] / elements[被克者];
                    if (ratio > 2) {
                        clashes += 2; // 克制过重
                    } else if (ratio > 1) {
                        clashes += 1; // 有克制
                    }
                }
            }
            
            return clashes;
        }
        
        // 检查冲突解救因素
        function checkConflictRescue(pillars) {
            let rescueScore = 0;
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 检查六合解冲
            if (hasLiuHe(branches)) {
                rescueScore += 2;
            }
            
            // 检查三合三会化解
            const sanHeResult = checkStrictSanHe(branches);
            if (sanHeResult.isValid) {
                rescueScore += 1;
            }
            
            const sanHuiResult = checkStrictSanHui(branches);
            if (sanHuiResult.isValid) {
                rescueScore += 1;
            }
            
            return Math.min(4, rescueScore);
        }

        // 元素层面的合化效果（用于平衡分数计算，不影响原始柱对象）
        function applyElementCombinationEffects(elements, stems, branches) {
            const elementMap = getElementMap();
            
            // 使用严格的三合局检测逻辑
            const branchSanHe = checkStrictSanHe(branches);
            if (branchSanHe.isValid) {
                if (branchSanHe.count === 3) {
                    // 三合化一气：对应五行得到额外加成
                    elements[branchSanHe.element] = (elements[branchSanHe.element] || 0) + 3;
                } else if (branchSanHe.count === 2) {
                    elements[branchSanHe.element] = (elements[branchSanHe.element] || 0) + 1.5;
                }
            }
            
            // 使用严格的三会局检测逻辑
            const branchSanHui = checkStrictSanHui(branches);
            if (branchSanHui.isValid && branchSanHui.count === 3) {
                elements[branchSanHui.element] = (elements[branchSanHui.element] || 0) + 2;
            }
            
            // 六合小幅加成
            if (hasLiuHe(branches)) {
                // 六合不定化气，给平均小加成
                Object.keys(elements).forEach(k => elements[k] += 0.3);
            }
            return elements;
        }

        // 元素层面的刑冲破害影响（用于平衡分数计算）
        function applyElementConflictEffects(elements, branches) {
            // 简化版：存在冲（对宫）时，双方元素略降
            const conflictPairs = [['子','午'],['丑','未'],['寅','申'],['卯','酉'],['辰','戌'],['巳','亥']];
            const elementMap = getElementMap();
            const present = new Set(branches);
            conflictPairs.forEach(([a,b]) => {
                if (present.has(a) && present.has(b)) {
                    const ea = elementMap[a];
                    const eb = elementMap[b];
                    if (ea) elements[ea] = Math.max(0, (elements[ea] || 0) - 1);
                    if (eb) elements[eb] = Math.max(0, (elements[eb] || 0) - 1);
                }
            });
            return elements;
        }

        // 高级格局识别评分 - 正格 + 从格 + 破格成败判断
        function calculateAdvancedPatternScore(pillars) {
            let patternScore = 0;
            let patternType = '普通格局';
            
            // 1. 特殊格局识别
            const specialPattern = identifySpecialPattern(pillars);
            if (specialPattern.type !== 'normal') {
                patternScore += specialPattern.score;
                patternType = specialPattern.name;
            }
            
            // 2. 正格评分
            const regularPattern = identifyRegularPattern(pillars);
            patternScore += regularPattern.score;
            
            // 3. 格局成败判断
            const patternIntegrity = evaluatePatternIntegrity(pillars, specialPattern.type);
            patternScore += patternIntegrity.score;
            
            // 4. 用神相神评分
            const yongShenScore = evaluateYongShen(pillars);
            patternScore += yongShenScore;
            
            return Math.min(25, Math.max(5, patternScore));
        }

        // 增强十神配置评分 - 全面考虑吉神得位、凶神制化、财官印流通性
        function calculateAdvancedGodsScore(pillars) {
            const dayStem = pillars.day.charAt(0);
            const dayStrength = estimateDayStrength(pillars);
            let godsScore = 0;
            
            // 统计十神分布
            const tenGodsCount = countTenGods(pillars);
            
            // 1. 吉神得位评分
            godsScore += evaluateAuspiciousGodsPosition(pillars, tenGodsCount, dayStrength);
            
            // 2. 凶神制化评分
            godsScore += evaluateInauspiciousGodsControl(pillars, tenGodsCount, dayStrength);
            
            // 3. 财官印流通性评分
            godsScore += evaluateWealthOfficialSealFlow(pillars, tenGodsCount);
            
            // 4. 特殊格局加分
            godsScore += evaluateSpecialPatterns(pillars, tenGodsCount, dayStrength);
            
            return Math.min(25, Math.max(0, godsScore));
        }
        
        // 评估吉神得位情况
        function evaluateAuspiciousGodsPosition(pillars, tenGodsCount, dayStrength) {
            let score = 0;
            const dayStem = pillars.day.charAt(0);
            
            // 月令吉神得位
            const monthStem = pillars.month.charAt(0);
            const monthBranch = pillars.month.charAt(1);
            const monthTenGod = getTenGod(dayStem, monthStem);
            const monthBranchMainQi = getBranchMainQi(monthBranch);
            const monthBranchTenGod = getTenGod(dayStem, monthBranchMainQi);
            
            // 月令正官正财得位
            if (monthTenGod === '正官' || monthTenGod === '正财') {
                score += 6; // 月干正官正财
                if (dayStrength >= 40 && dayStrength <= 70) {
                    score += 2; // 身强适中，能胜任财官
                }
            }
            if (monthBranchTenGod === '正官' || monthBranchTenGod === '正财') {
                score += 4; // 月支正官正财
            }
            
            // 印星得位（特别是正印）
            if (monthTenGod === '正印') {
                score += 5;
                if (dayStrength <= 40) {
                    score += 2; // 身弱得印星生扶
                }
            }
            
            // 食神得位
            if (monthTenGod === '食神') {
                score += 4;
                if (dayStrength >= 60) {
                    score += 2; // 身强食神泄秀
                }
            }
            
            // 时柱吉神得位
            const hourStem = pillars.hour.charAt(0);
            const hourTenGod = getTenGod(dayStem, hourStem);
            if (hourTenGod === '正财' || hourTenGod === '食神') {
                score += 2; // 时柱财星食神，晚年有靠
            }
            
            return score;
        }
        
        // 评估凶神制化情况
        function evaluateInauspiciousGodsControl(pillars, tenGodsCount, dayStrength) {
            let score = 0;
            
            // 七杀有制
            if (tenGodsCount.七杀 > 0) {
                if (tenGodsCount.食神 > 0) {
                    score += 6; // 食神制杀
                    if (tenGodsCount.七杀 === 1 && tenGodsCount.食神 === 1) {
                        score += 2; // 一杀一制，最为贵格
                    }
                } else if (tenGodsCount.正印 > 0) {
                    score += 4; // 印星化杀
                } else if (tenGodsCount.劫财 > 0 && dayStrength <= 40) {
                    score += 3; // 身弱劫财帮身抗杀
                } else {
                    score -= 3; // 七杀无制，凶
                }
            }
            
            // 伤官有制化
            if (tenGodsCount.伤官 > 0) {
                if (tenGodsCount.正印 > 0) {
                    score += 5; // 伤官佩印
                    if (dayStrength >= 50) {
                        score += 2; // 身强伤官佩印，文贵之格
                    }
                } else if (tenGodsCount.正财 > 0) {
                    score += 3; // 伤官生财
                } else if (tenGodsCount.正官 > 0) {
                    score -= 4; // 伤官见官，为祸百端
                }
            }
            
            // 羊刃有制
            if (hasYangBlade(pillars)) {
                if (tenGodsCount.七杀 > 0) {
                    score += 4; // 羊刃驾杀
                } else if (tenGodsCount.正官 > 0) {
                    score += 2; // 羊刃合官
                } else {
                    score -= 2; // 羊刃无制
                }
            }
            
            return score;
        }
        
        // 评估财官印流通性
        function evaluateWealthOfficialSealFlow(pillars, tenGodsCount) {
            let score = 0;
            const dayStem = pillars.day.charAt(0);
            
            // 财官印三宝流通
            const hasWealth = tenGodsCount.正财 > 0 || tenGodsCount.偏财 > 0;
            const hasOfficial = tenGodsCount.正官 > 0 || tenGodsCount.七杀 > 0;
            const hasSeal = tenGodsCount.正印 > 0 || tenGodsCount.偏印 > 0;
            
            if (hasWealth && hasOfficial && hasSeal) {
                score += 8; // 财官印俱全
                
                // 检查流通顺序
                const flowPattern = checkWealthOfficialSealFlow(pillars);
                if (flowPattern.isComplete) {
                    score += 4; // 完整流通
                } else if (flowPattern.partialFlow) {
                    score += 2; // 部分流通
                }
            }
            
            // 财生官格
            if (hasWealth && hasOfficial && !hasSeal) {
                score += 5;
                if (checkDirectFlow(pillars, '财', '官')) {
                    score += 2; // 财直接生官
                }
            }
            
            // 官印相生
            if (hasOfficial && hasSeal && !hasWealth) {
                score += 4;
                if (checkDirectFlow(pillars, '官', '印')) {
                    score += 2; // 官直接生印
                }
            }
            
            // 印比劫流通（身弱时）
            if (hasSeal && (tenGodsCount.比肩 > 0 || tenGodsCount.劫财 > 0)) {
                if (estimateDayStrength(pillars) <= 40) {
                    score += 3; // 身弱印比相生
                }
            }
            
            return score;
        }
        
        // 评估特殊格局
        function evaluateSpecialPatterns(pillars, tenGodsCount, dayStrength) {
            let score = 0;
            
            // 从格评估
            if (dayStrength <= 20 || dayStrength >= 80) {
                const congPattern = identifySpecialPattern(pillars);
                if (congPattern.type === 'congqiang' || congPattern.type === 'congruo') {
                    score += 6; // 从格成立
                }
            }
            
            // 化气格
            if (checkHuaQiPattern(pillars)) {
                score += 8; // 化气格，极贵
            }
            
            // 专旺格
            if (checkZhuanWangPattern(pillars)) {
                score += 7; // 专旺格
            }
            
            // 润下、炎上、从革等特殊格局
            const elementPattern = checkElementPattern(pillars);
            if (elementPattern.isValid) {
                score += elementPattern.score;
            }
            
            return score;
        }

        // 高级组合评分 - 三合六合三会局的精准评分
        function calculateAdvancedCombinationScore(pillars) {
            let combinationScore = 0;
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 1. 三合局评分 - 使用严格检测
            const sanHeResult = checkStrictSanHe(branches);
            if (sanHeResult.isValid) {
                if (sanHeResult.count === 3) {
                    combinationScore += 12; // 完整三合
                    combinationScore += applyAdvancedCombinationEffects(pillars, sanHeResult);
                } else if (sanHeResult.count === 2) {
                    combinationScore += 6; // 半合
                }
            }
            
            // 2. 六合评分
            const liuHeCount = hasLiuHe(branches) ? 1 : 0;
            if (liuHeCount > 0) {
                combinationScore += 4;
                combinationScore += applyAdvancedCombinationEffects(pillars, {type: 'liuhe'});
            }
            
            // 3. 三会局评分 - 使用严格检测
            const sanHuiResult = checkStrictSanHui(branches);
            if (sanHuiResult.isValid && sanHuiResult.count === 3) {
                combinationScore += 10; // 三会局
            }
            
            // 4. 冲克刑害扣分
            const conflictPenalty = applyAdvancedConflictEffects(pillars);
            combinationScore -= conflictPenalty;
            
            
            // 5. 空亡检查
            const voidPenalty = checkVoidPenalty(pillars);
            combinationScore -= voidPenalty;
            
            return Math.min(15, Math.max(0, combinationScore));
        }

        // 高级组合增益效果
        function applyAdvancedCombinationEffects(pillars, combination) {
            let bonus = 0;
            const dayStem = pillars.day.charAt(0);
            const dayElement = getElementMap()[dayStem];
            const dayStrength = estimateDayStrength(pillars);
            
            if (combination.type === 'sanhe' || combination.type === 'sanhui') {
                const combinedElement = combination.element;
                
                // 合化为用神
                if (isFavorableElement(dayElement, combinedElement, dayStrength)) {
                    bonus += 5;
                }
                
                // 合化为喜神
                if (isSupportiveElement(dayElement, combinedElement)) {
                    bonus += 3;
                }
                
                // 合化为忌神
                if (isUnfavorableElement(dayElement, combinedElement, dayStrength)) {
                    bonus -= 4;
                }
            }
            
            return bonus;
        }

        // 高级冲克扣分效果
        function applyAdvancedConflictEffects(pillars) {
            let penalty = 0;
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 相冲检查
            const chongPairs = [
                ['子', '午'], ['丑', '未'], ['寅', '申'], 
                ['卯', '酉'], ['辰', '戌'], ['巳', '亥']
            ];
            
            for (const pair of chongPairs) {
                if (branches.includes(pair[0]) && branches.includes(pair[1])) {
                    if (pair[0] === pillars.day.charAt(1) || pair[1] === pillars.day.charAt(1)) {
                        penalty += 5; // 日支被冲，严重
                    } else {
                        penalty += 2; // 其他柱被冲
                    }
                }
            }
            
            // 相刑检查
            const xingGroups = [
                ['寅', '巳', '申'], // 无恩之刑
                ['丑', '戌', '未'], // 恃势之刑
                ['子', '卯']       // 无礼之刑
            ];
            
            for (const group of xingGroups) {
                const presentCount = group.filter(branch => branches.includes(branch)).length;
                if (presentCount >= 2) {
                    penalty += presentCount;
                }
            }
            
            return penalty;
        }

        // 元素对应表
        function getElementMap() {
            return {
                '甲': '木', '乙': '木',
                '丙': '火', '丁': '火',
                '戊': '土', '己': '土',
                '庚': '金', '辛': '金',
                '壬': '水', '癸': '水',
                '寅': '木', '卯': '木',
                '午': '火', '巳': '火',
                '辰': '土', '戌': '土', '丑': '土', '未': '土',
                '申': '金', '酉': '金',
                '子': '水', '亥': '水'
            };
        }

        // 特殊格局识别
        function identifySpecialPattern(pillars) {
            const dayStem = pillars.day.charAt(0);
            
            // 检查从格
            if (isCongGe(pillars)) {
                if (isCongQiangGe(dayStem, 
                    [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)],
                    [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)])) {
                    return { type: 'congqiang', name: '从强格', score: 15 };
                }
                if (isCongRuoGe(dayStem,
                    [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)],
                    [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)])) {
                    return { type: 'congruo', name: '从弱格', score: 12 };
                }
            }
            
            // 检查专旺格
            if (isZhuanWangGe(pillars)) {
                return { type: 'zhuanwang', name: '专旺格', score: 18 };
            }
            
            return { type: 'normal', name: '普通格局', score: 8 };
        }

        // 正格识别
        function identifyRegularPattern(pillars) {
            const monthStem = pillars.month.charAt(0);
            const dayStem = pillars.day.charAt(0);
            const tenGod = getTenGod(dayStem, monthStem);
            
            let score = 0;
            switch(tenGod) {
                case '正官':
                    score = 12; // 正官格，富贵双全
                    break;
                case '七杀':
                    score = 10; // 七杀格，威权之命
                    break;
                case '正财':
                    score = 11; // 正财格，财富之命
                    break;
                case '偏财':
                    score = 9;  // 偏财格，投机之财
                    break;
                case '食神':
                    score = 10; // 食神格，福寿之命
                    break;
                case '伤官':
                    score = 8;  // 伤官格，聪明反被聪明误
                    break;
                case '正印':
                    score = 9;  // 正印格，文贵之命
                    break;
                case '偏印':
                    score = 7;  // 偏印格，孤独之命
                    break;
                default:
                    score = 6;  // 比劫建禄格
            }
            
            return { type: tenGod, score: score };
        }

        // 格局成败判断
        function evaluatePatternIntegrity(pillars, patternType) {
            let integrityScore = 0;
            
            // 检查格局是否被破坏
            if (patternType === 'normal') {
                // 正格成败检查
                integrityScore = checkRegularPatternIntegrity(pillars);
            } else {
                // 变格成败检查
                integrityScore = checkSpecialPatternIntegrity(pillars, patternType);
            }
            
            return { score: integrityScore };
        }

        // 用神相神评分
        function evaluateYongShen(pillars) {
            const dayStrength = estimateDayStrength(pillars);
            let yongShenScore = 0;
            
            // 根据身强身弱确定用神（支持12级分类）
            const strengthType = window.currentBaziData?.strengthAnalysis?.type;
            
            if (strengthType) {
                // 使用12级分类系统判断
                if (['极强（专旺）', '较强', '稍强', '微强'].includes(strengthType)) {
                    // 强旺类型用食伤财官
                    yongShenScore += evaluateWeakeningGods(pillars);
                } else if (['极弱（从弱）', '很弱', '较弱', '稍弱', '微弱'].includes(strengthType)) {
                    // 偏弱类型用印比
                    yongShenScore += evaluateStrengtheningGods(pillars);
                } else if (['真正中和', '中和偏弱', '中和偏强'].includes(strengthType)) {
                    // 中和类型用调候
                    yongShenScore += evaluateBalancingGods(pillars);
                } else if (['从强', '从弱'].includes(strengthType)) {
                    // 从格特殊处理
                    if (strengthType === '从强') {
                        yongShenScore += evaluateStrengtheningGods(pillars); // 从强顺其旺势
                    } else {
                        yongShenScore += evaluateWeakeningGods(pillars); // 从弱顺其弱势
                    }
                }
            } else {
                // 兼容旧版本数值判断
                if (dayStrength > 70) {
                    // 身强用食伤财官
                    yongShenScore += evaluateWeakeningGods(pillars);
                } else if (dayStrength < 30) {
                    // 身弱用印比
                    yongShenScore += evaluateStrengtheningGods(pillars);
                } else {
                    // 中和用调候
                    yongShenScore += evaluateBalancingGods(pillars);
                }
            }
            
            return Math.min(8, Math.max(0, yongShenScore));
        }

        // 估算日主强度
        function estimateDayStrength(pillars) {
            // 复用已有的 calculateSimpleDayStrength 函数
            return calculateSimpleDayStrength(pillars);
        }

        // 新增：全局十神计算函数（供格局识别、十神统计、元素标注等模块使用）
        // 使用与 lunar.js 一致的十神映射规则
        function getTenGod(dayStem, target) {
            // 如果传入的是地支，则取其主气天干
            const ganList = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'];
            if (!ganList.includes(target)) {
                const mainQiMap = {
                    '子': '癸', '丑': '己', '寅': '甲', '卯': '乙',
                    '辰': '戊', '巳': '丙', '午': '丁', '未': '己',
                    '申': '庚', '酉': '辛', '戌': '戊', '亥': '壬'
                };
                target = mainQiMap[target];
                if (!target) return '未知';
            }
            
            // 使用标准的十神映射表（与 lunar.js 保持一致）
            const shiShenMap = {
                // 甲日主
                '甲甲': '比肩', '甲乙': '劫财', '甲丙': '食神', '甲丁': '伤官', '甲戊': '偏财',
                '甲己': '正财', '甲庚': '七杀', '甲辛': '正官', '甲壬': '偏印', '甲癸': '正印',
                // 乙日主
                '乙乙': '比肩', '乙甲': '劫财', '乙丁': '食神', '乙丙': '伤官', '乙己': '偏财',
                '乙戊': '正财', '乙辛': '七杀', '乙庚': '正官', '乙癸': '偏印', '乙壬': '正印',
                // 丙日主
                '丙丙': '比肩', '丙丁': '劫财', '丙戊': '食神', '丙己': '伤官', '丙庚': '偏财',
                '丙辛': '正财', '丙壬': '七杀', '丙癸': '正官', '丙甲': '偏印', '丙乙': '正印',
                // 丁日主
                '丁丁': '比肩', '丁丙': '劫财', '丁己': '食神', '丁戊': '伤官', '丁辛': '偏财',
                '丁庚': '正财', '丁癸': '七杀', '丁壬': '正官', '丁乙': '偏印', '丁甲': '正印',
                // 戊日主
                '戊戊': '比肩', '戊己': '劫财', '戊庚': '食神', '戊辛': '伤官', '戊壬': '偏财',
                '戊癸': '正财', '戊甲': '七杀', '戊乙': '正官', '戊丙': '偏印', '戊丁': '正印',
                // 己日主
                '己己': '比肩', '己戊': '劫财', '己辛': '食神', '己庚': '伤官', '己癸': '偏财',
                '己壬': '正财', '己乙': '七杀', '己甲': '正官', '己丁': '偏印', '己丙': '正印',
                // 庚日主
                '庚庚': '比肩', '庚辛': '劫财', '庚壬': '食神', '庚癸': '伤官', '庚甲': '偏财',
                '庚乙': '正财', '庚丙': '七杀', '庚丁': '正官', '庚戊': '偏印', '庚己': '正印',
                // 辛日主
                '辛辛': '比肩', '辛庚': '劫财', '辛癸': '食神', '辛壬': '伤官', '辛乙': '偏财',
                '辛甲': '正财', '辛丁': '七杀', '辛丙': '正官', '辛己': '偏印', '辛戊': '正印',
                // 壬日主
                '壬壬': '比肩', '壬癸': '劫财', '壬甲': '食神', '壬乙': '伤官', '壬丙': '偏财',
                '壬丁': '正财', '壬戊': '七杀', '壬己': '正官', '壬庚': '偏印', '壬辛': '正印',
                // 癸日主
                '癸癸': '比肩', '癸壬': '劫财', '癸乙': '食神', '癸甲': '伤官', '癸丁': '偏财',
                '癸丙': '正财', '癸己': '七杀', '癸戊': '正官', '癸辛': '偏印', '癸庚': '正印'
            };
            
            const key = dayStem + target;
            return shiShenMap[key] || '未知';
        }

        // 统计十神数量
        function countTenGods(pillars) {
            const dayStem = pillars.day.charAt(0);
            const tenGodsCount = {
                '比肩': 0, '劫财': 0, '食神': 0, '伤官': 0,
                '偏财': 0, '正财': 0, '七杀': 0, '正官': 0,
                '偏印': 0, '正印': 0
            };
            
            // 统计天干十神
            [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)].forEach(stem => {
                const tenGod = getTenGod(dayStem, stem);
                if (tenGodsCount.hasOwnProperty(tenGod)) {
                    tenGodsCount[tenGod]++;
                }
            });
            
            // 统计地支藏干十神
            [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)].forEach(branch => {
                const hiddenStems = getHiddenStems(branch);
                hiddenStems.forEach(stem => {
                    if (stem !== dayStem) {
                        const tenGod = getTenGod(dayStem, stem);
                        if (tenGodsCount.hasOwnProperty(tenGod)) {
                            tenGodsCount[tenGod] += 0.3; // 藏干权重较低
                        }
                    }
                });
            });
            
            return tenGodsCount;
        }

        // 三合三会检查（使用严格检测函数）
        function hasSanHui(branches, type = 'sanhe') {
            if (type === 'sanhe') {
                const result = checkStrictSanHe(branches);
                if (result.isValid) {
                    return { count: result.count, element: result.element, type: 'sanhe' };
                }
            } else if (type === 'sanhui') {
                const result = checkStrictSanHui(branches);
                if (result.isValid) {
                    return { count: result.count, element: result.element, type: 'sanhui' };
                }
            }
            
            return { count: 0, element: null, type: null };
        }

        // 空亡检查
        function checkVoidPenalty(pillars) {
            const dayBranch = pillars.day.charAt(1);
            const hourBranch = pillars.hour.charAt(1);
            
            // 简化的空亡检查（基于日支和时支）
            const voidPairs = [
                ['甲子', '乙丑'], ['丙寅', '丁卯'], ['戊辰', '己巳'],
                ['庚午', '辛未'], ['壬申', '癸酉'], ['甲戌', '乙亥']
            ];
            
            let penalty = 0;
            const dayPillar = pillars.day;
            
            // 检查日柱是否空亡
            for (const pair of voidPairs) {
                if (pair.includes(dayPillar)) {
                    penalty += 3; // 日柱空亡，扣分
                    break;
                }
            }
            
            return penalty;
        }

        // 十神流通检查
        function checkTenGodsFlow(pillars) {
            const dayStem = pillars.day.charAt(0);
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            
            // 检查是否有连续的生克关系
            let flowCount = 0;
            for (let i = 0; i < stems.length - 1; i++) {
                const tenGod1 = getTenGod(dayStem, stems[i]);
                const tenGod2 = getTenGod(dayStem, stems[i + 1]);
                
                // 检查十神之间的流通关系
                if (isGoodTenGodFlow(tenGod1, tenGod2)) {
                    flowCount++;
                }
            }
            
            return flowCount >= 1; // 至少有一组流通
        }

        // 判断十神流通关系
        function isGoodTenGodFlow(god1, god2) {
            const flowMap = {
                '食神': ['偏财', '正财'],
                '伤官': ['偏财', '正财'],
                '偏财': ['七杀', '正官'],
                '正财': ['七杀', '正官'],
                '七杀': ['偏印', '正印'],
                '正官': ['偏印', '正印'],
                '偏印': ['比肩', '劫财'],
                '正印': ['比肩', '劫财']
            };
            
            return flowMap[god1]?.includes(god2) || false;
        }

        // 判断用神元素
        function isFavorableElement(dayElement, targetElement, dayStrength) {
            
            if (dayStrength > 70) {
                // 身强，克泄为用
                const drainMap = {
                    '木': ['火'], '火': ['土'], '土': ['金'], '金': ['水'], '水': ['木']
                };
                const restrainMap = {
                    '木': ['土'], '火': ['金'], '土': ['水'], '金': ['木'], '水': ['火']
                };
                return drainMap[dayElement]?.includes(targetElement) || 
                       restrainMap[dayElement]?.includes(targetElement);
            } else if (dayStrength < 30) {
                // 身弱，生助为用
                const supportMap = {
                    '木': ['水'], '火': ['木'], '土': ['火'], '金': ['土'], '水': ['金']
                };
                return supportMap[dayElement]?.includes(targetElement) || dayElement === targetElement;
            }
            
            return false;
        }

        // 判断喜神元素
        function isSupportiveElement(dayElement, targetElement) {
            // 简化判断：生用神的为喜神
            const supportMap = {
                '木': ['水'], '火': ['木'], '土': ['火'], '金': ['土'], '水': ['金']
            };
            
            return supportMap[targetElement]?.includes(dayElement);
        }

        // 判断忌神元素
        function isUnfavorableElement(dayElement, targetElement, dayStrength) {
            
            if (dayStrength > 70) {
                // 身强，生助为忌
                const supportMap = {
                    '木': ['水'], '火': ['木'], '土': ['火'], '金': ['土'], '水': ['金']
                };
                return supportMap[dayElement]?.includes(targetElement) || dayElement === targetElement;
            } else if (dayStrength < 30) {
                // 身弱，克泄为忌
                const drainMap = {
                    '木': ['火'], '火': ['土'], '土': ['金'], '金': ['水'], '水': ['木']
                };
                const restrainMap = {
                    '木': ['土'], '火': ['金'], '土': ['水'], '金': ['木'], '水': ['火']
                };
                return drainMap[dayElement]?.includes(targetElement) || 
                       restrainMap[dayElement]?.includes(targetElement);
            }
            
            return false;
        }

        // 正格成败检查
        function checkRegularPatternIntegrity(pillars) {
            const monthStem = pillars.month.charAt(0);
            const dayStem = pillars.day.charAt(0);
            const tenGod = getTenGod(dayStem, monthStem);
            
            let integrityScore = 5; // 基础分
            
            // 检查格局是否被破坏
            switch(tenGod) {
                case '正官':
                    // 正官格怕伤官破格
                    if (hasInjuringOfficer(pillars)) {
                        integrityScore -= 3;
                    }
                    break;
                case '七杀':
                    // 七杀格要有制化
                    if (hasKillControl(pillars)) {
                        integrityScore += 2;
                    } else {
                        integrityScore -= 2;
                    }
                    break;
                case '正财':
                case '偏财':
                    // 财格怕比劫夺财
                    if (hasWealthRobbery(pillars)) {
                        integrityScore -= 3;
                    }
                    break;
                case '食神':
                    // 食神格怕枭印夺食
                    if (hasOwlSnatching(pillars)) {
                        integrityScore -= 3;
                    }
                    break;
            }
            
            return Math.max(0, integrityScore);
        }

        // 变格成败检查
        function checkSpecialPatternIntegrity(pillars, patternType) {
            let integrityScore = 8; // 特殊格局基础分较高
            
            if (patternType === 'congqiang' || patternType === 'congruo') {
                // 从格怕逢反局
                if (hasReversalElements(pillars, patternType)) {
                    integrityScore -= 5;
                }
            } else if (patternType === 'zhuanwang') {
                // 专旺格要气势连贯
                if (hasContinuousForce(pillars)) {
                    integrityScore += 3;
                } else {
                    integrityScore -= 2;
                }
            }
            
            return Math.max(0, integrityScore);
        }

        // 身强用神评分
        function evaluateWeakeningGods(pillars) {
            const tenGodsCount = countTenGods(pillars);
            let score = 0;
            
            // 食伤泄秀
            score += (tenGodsCount.食神 + tenGodsCount.伤官) * 2;
            
            // 财星耗身
            score += (tenGodsCount.正财 + tenGodsCount.偏财) * 1.5;
            
            // 官杀制身
            score += (tenGodsCount.正官 + tenGodsCount.七杀) * 1;
            
            return Math.min(8, score);
        }

        // 身弱用神评分
        function evaluateStrengtheningGods(pillars) {
            const tenGodsCount = countTenGods(pillars);
            let score = 0;
            
            // 印星生身
            score += (tenGodsCount.正印 + tenGodsCount.偏印) * 2;
            
            // 比劫帮身
            score += (tenGodsCount.比肩 + tenGodsCount.劫财) * 1.5;
            
            return Math.min(8, score);
        }

        // 中和调候用神评分
        function evaluateBalancingGods(pillars) {
            const monthBranch = pillars.month.charAt(1);
            let score = 5; // 中和基础分
            
            // 根据季节调候
            if (['子', '丑', '亥'].includes(monthBranch)) {
                // 冬季用火调候
                const tenGodsCount = countTenGods(pillars);
                if (tenGodsCount.食神 > 0) score += 2; // 食神生火
            } else if (['午', '未', '巳'].includes(monthBranch)) {
                // 夏季用水调候
                const tenGodsCount = countTenGods(pillars);
                if (tenGodsCount.正官 > 0 || tenGodsCount.七杀 > 0) score += 2; // 官杀为水
            }
            
            return Math.min(8, score);
        }

        // 辅助检查函数
        function hasInjuringOfficer(pillars) {
            const dayStem = pillars.day.charAt(0);
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            return stems.some(stem => getTenGod(dayStem, stem) === '伤官');
        }

        function hasKillControl(pillars) {
            const tenGodsCount = countTenGods(pillars);
            return tenGodsCount.食神 > 0 || tenGodsCount.正印 > 0;
        }

        function hasWealthRobbery(pillars) {
            const tenGodsCount = countTenGods(pillars);
            return tenGodsCount.比肩 > 0 || tenGodsCount.劫财 > 0;
        }

        function hasOwlSnatching(pillars) {
            const tenGodsCount = countTenGods(pillars);
            return tenGodsCount.偏印 > 0;
        }

        function hasReversalElements(pillars, patternType) {
            const dayStem = pillars.day.charAt(0);
            const dayElement = getElementMap()[dayStem];
            
            // 简化检查：从强格忌克泄，从弱格忌生助
            if (patternType === 'congqiang') {
                // 从强格怕食伤财官
                const tenGodsCount = countTenGods(pillars);
                return (tenGodsCount.食神 + tenGodsCount.伤官 + 
                       tenGodsCount.正财 + tenGodsCount.偏财 + 
                       tenGodsCount.正官 + tenGodsCount.七杀) > 1;
            } else if (patternType === 'congruo') {
                // 从弱格怕印比
                const tenGodsCount = countTenGods(pillars);
                return (tenGodsCount.正印 + tenGodsCount.偏印 + 
                       tenGodsCount.比肩 + tenGodsCount.劫财) > 1;
            }
            
            return false;
        }

        function hasContinuousForce(pillars) {
            const dayElement = getElementMap()[pillars.day.charAt(0)];
            let sameElementCount = 0;
            
            // 统计同类五行数量
            [pillars.year, pillars.month, pillars.day, pillars.hour].forEach(pillar => {
                const stemElement = getElementMap()[pillar.charAt(0)];
                const branchElement = getElementMap()[pillar.charAt(1)];
                if (stemElement === dayElement) sameElementCount++;
                if (branchElement === dayElement) sameElementCount++;
            });
            
            return sameElementCount >= 5; // 超过一半为同类五行
        }

        // 判断从格
        function isCongGe(pillars) {
            const dayStem = pillars.day.charAt(0);
            const stems = [
                pillars.year.charAt(0),
                pillars.month.charAt(0),
                pillars.hour.charAt(0)
            ];
            const branches = [
                pillars.year.charAt(1),
                pillars.month.charAt(1),
                pillars.day.charAt(1),
                pillars.hour.charAt(1)
            ];
            if (isCongQiangGe(dayStem, stems, branches)) {
                return true;
            }
            if (isCongRuoGe(dayStem, stems, branches)) {
                return true;
            }
            return false;
        }

        // 判断从强格 - 直接使用已计算的身强身弱分析结果
        function isCongQiangGe(dayStem, stems, branches) {
            // 优先使用已计算的身强身弱分析结果
            if (window.currentBaziData && window.currentBaziData.strengthAnalysis) {
                const analysis = window.currentBaziData.strengthAnalysis;
                return analysis.type === '从强';
            }
            
            // 备用计算方法（原有逻辑）
            let count = 0;
            stems.forEach(function(stem) {
                if (isSameElement(stem, dayStem) || isGenerateElement(stem, dayStem)) {
                    count++;
                }
            });
            branches.forEach(function(branch) {
                if (isSameElement(branch, dayStem) || isGenerateElement(branch, dayStem)) {
                    count++;
                }
            });
            return count >= 6;
        }

        // 判断从弱格 - 直接使用已计算的身强身弱分析结果
        function isCongRuoGe(dayStem, stems, branches) {
            // 优先使用已计算的身强身弱分析结果
            if (window.currentBaziData && window.currentBaziData.strengthAnalysis) {
                const analysis = window.currentBaziData.strengthAnalysis;
                return analysis.type === '从弱';
            }
            
            // 备用计算方法（原有逻辑）
            let count = 0;
            stems.forEach(function(stem) {
                if (isSameElement(stem, dayStem) || isGenerateElement(stem, dayStem)) {
                    count++;
                }
            });
            branches.forEach(function(branch) {
                if (isSameElement(branch, dayStem) || isGenerateElement(branch, dayStem)) {
                    count++;
                }
            });
            return count <= 1;
        }

        // 判断专旺格
        function isZhuanWangGe(pillars) {
            const dayStem = pillars.day.charAt(0);
            const stems = [
                pillars.year.charAt(0),
                pillars.month.charAt(0),
                pillars.hour.charAt(0)
            ];
            const branches = [
                pillars.year.charAt(1),
                pillars.month.charAt(1),
                pillars.day.charAt(1),
                pillars.hour.charAt(1)
            ];
            let sameCount = 0;
            let otherCount = 0;
            stems.forEach(function(stem) {
                if (isSameElement(stem, dayStem)) {
                    sameCount++;
                } else {
                    otherCount++;
                }
            });
            branches.forEach(function(branch) {
                if (isSameElement(branch, dayStem)) {
                    sameCount++;
                } else {
                    otherCount++;
                }
            });
            return sameCount >= 5 && otherCount <= 2;
        }

        // 判断相同元素
        function isSameElement(a, b) {
            const elementMap = {
                '甲': '木', '乙': '木',
                '丙': '火', '丁': '火',
                '戊': '土', '己': '土',
                '庚': '金', '辛': '金',
                '壬': '水', '癸': '水',
                '寅': '木', '卯': '木',
                '午': '火', '巳': '火',
                '辰': '土', '戌': '土', '丑': '土', '未': '土',
                '申': '金', '酉': '金',
                '子': '水', '亥': '水'
            };
            return elementMap[a] === elementMap[b];
        }

        // 判断生成元素
        function isGenerateElement(a, b) {
            const elementMap = {
                '甲': '木', '乙': '木',
                '丙': '火', '丁': '火',
                '戊': '土', '己': '土',
                '庚': '金', '辛': '金',
                '壬': '水', '癸': '水',
                '寅': '木', '卯': '木',
                '午': '火', '巳': '火',
                '辰': '土', '戌': '土', '丑': '土', '未': '土',
                '申': '金', '酉': '金',
                '子': '水', '亥': '水'
            };
            const aElement = elementMap[a];
            const bElement = elementMap[b];
            const generateMap = {
                '木': '火',
                '火': '土',
                '土': '金',
                '金': '水',
                '水': '木'
            };
            return generateMap[aElement] === bElement;
        }

        // 计算十神分数
        function calculateGodsScore(pillars) {
            return 10;
        }

        // 计算组合分数
        function calculateCombinationScore(pillars) {
            const branches = [
                pillars.year.charAt(1),
                pillars.month.charAt(1),
                pillars.day.charAt(1),
                pillars.hour.charAt(1)
            ];
            if (hasSanHe(branches)) {
                return 8;
            }
            if (hasLiuHe(branches)) {
                return 5;
            }
            return 2;
        }

        // 严格的三合局检测函数
        function checkStrictSanHe(branches) {
            const sanHeGroups = [
                {branches: ['申', '子', '辰'], element: 'water'},
                {branches: ['亥', '卯', '未'], element: 'wood'},
                {branches: ['寅', '午', '戌'], element: 'fire'},
                {branches: ['巳', '酉', '丑'], element: 'metal'}
            ];
            
            for (const group of sanHeGroups) {
                const foundBranches = [];
                const foundIndices = [];
                
                // 检查每个地支是否存在并记录位置
                for (let i = 0; i < branches.length; i++) {
                    if (group.branches.includes(branches[i])) {
                        foundBranches.push(branches[i]);
                        foundIndices.push(i);
                    }
                }
                
                // 至少需要2个地支才能形成半三合
                if (foundBranches.length >= 2) {
                    let isValid = false;
                    
                    // 检查相邻性：对于半三合，地支必须相邻
                    if (foundBranches.length === 2) {
                        // 检查两个地支是否相邻
                        if (Math.abs(foundIndices[0] - foundIndices[1]) === 1) {
                            isValid = true;
                        }
                    } else if (foundBranches.length === 3) {
                        // 全三合：检查是否有连续的三个位置
                        foundIndices.sort((a, b) => a - b);
                        if (foundIndices[1] === foundIndices[0] + 1 && 
                            foundIndices[2] === foundIndices[0] + 2) {
                            isValid = true;
                        }
                    }
                    
                    if (isValid) {
                        return {
                            isValid: true,
                            count: foundBranches.length,
                            element: group.element,
                            type: group.branches.join(''),
                            foundBranches: foundBranches
                        };
                    }
                }
            }
            
            return {isValid: false, count: 0};
        }
        
        // 严格的三会局检测函数
        function checkStrictSanHui(branches) {
            const sanHuiGroups = [
                {branches: ['寅', '卯', '辰'], element: 'wood'},
                {branches: ['巳', '午', '未'], element: 'fire'},
                {branches: ['申', '酉', '戌'], element: 'metal'},
                {branches: ['亥', '子', '丑'], element: 'water'}
            ];
            
            for (const group of sanHuiGroups) {
                const foundBranches = [];
                const foundIndices = [];
                
                // 检查每个地支是否存在并记录位置
                for (let i = 0; i < branches.length; i++) {
                    if (group.branches.includes(branches[i])) {
                        foundBranches.push(branches[i]);
                        foundIndices.push(i);
                    }
                }
                
                // 三会局需要3个地支且必须连续
                if (foundBranches.length === 3) {
                    foundIndices.sort((a, b) => a - b);
                    if (foundIndices[1] === foundIndices[0] + 1 && 
                        foundIndices[2] === foundIndices[0] + 2) {
                        return {
                            isValid: true,
                            count: 3,
                            element: group.element,
                            type: group.branches.join(''),
                            foundBranches: foundBranches
                        };
                    }
                }
            }
            
            return {isValid: false, count: 0};
        }

        // 判断三合（保持向后兼容）
        function hasSanHe(branches) {
            const result = checkStrictSanHe(branches);
            return result.isValid;
        }

        // 判断六合
        function hasLiuHe(branches) {
            const liuHePairs = [
                ['子', '丑'],
                ['寅', '亥'],
                ['卯', '戌'],
                ['辰', '酉'],
                ['巳', '申'],
                ['午', '未']
            ];
            for (const pair of liuHePairs) {
                if (branches.includes(pair[0]) && branches.includes(pair[1])) {
                    return true;
                }
            }
            return false;
        }

        // 获取命运等级 - 适配新的120分满分制度，改为5星制
        function getFateLevel(score) {
            if (score >= 100) return { name: "帝王之命 ★★★★★", class: "emperor" };       // 100+：帝王之命（五星）
            if (score >= 80) return { name: "天赐鸿运 ★★★★☆", class: "excellent" };     // 80-99：天赐鸿运（四星）
            if (score >= 60) return { name: "福星高照 ★★★☆☆", class: "good" };         // 60-79：福星高照（三星）
            if (score >= 40) return { name: "安常守分 ★★☆☆☆", class: "average" };        // 40-59：安常守分（二星）
            if (score >= 20) return { name: "勤能补拙 ★☆☆☆☆", class: "struggling" };     // 20-39：勤能补拙（一星）
            return { name: "逆水行舟 ☆☆☆☆☆", class: "needs-improvement" };             // <20：逆水行舟（零星）
        }

        // 获取命格描述
        function getFateDescription(score) {
            if (score >= 100) return '命格极佳，天赋卓越，一生富贵荣华，前程似锦';
            if (score >= 80) return '天赋异禀，福泽深厚，运势极佳，发展顺遂';
            if (score >= 60) return '聪明才智，运势较佳，发展前景良好，努力可成';
            if (score >= 40) return '资质良好，发展平稳，需要努力进取，稳中求进';
            if (score >= 20) return '普通命格，需要勤奋努力方能成功，持之以恒';
            return '命途坎坷，需要坚持不懈，逆境求生，自强不息';
        }



        // 计算财富等级 - 专业版
        function calculateWealthLevel(pillars) {
            // 优先使用 window.currentBaziData.pillars 如果可用
            let effectivePillars = pillars;
            if (window.currentBaziData && window.currentBaziData.pillars) {
                effectivePillars = window.currentBaziData.pillars;
            }
            
            const score = calculateWealthScore(effectivePillars);
            const levelInfo = getWealthLevel(score);
            
            return {
                score: score,
                level: levelInfo.name,
                description: getWealthDescription(score),
                details: wealthScoreDetails
            };
        }

        // 计算财富分数 - 基于专业八字命理的无上限评分，融入自坐财库、财气通门户等因素
        function calculateWealthScore(pillars) {
            wealthScoreValue = 0; // 重置缓存，确保每次重新计算
            if (wealthScoreValue === 0) {
                // 优先使用 window.currentBaziData.pillars 如果可用
                let effectivePillars = pillars;
                if (window.currentBaziData && window.currentBaziData.pillars) {
                    effectivePillars = window.currentBaziData.pillars;
                }
                
                // 确保输入是字符串
                const dayStr = typeof effectivePillars.day === 'string' ? effectivePillars.day : String(effectivePillars.day);
                const monthStr = typeof effectivePillars.month === 'string' ? effectivePillars.month : String(effectivePillars.month);
                const yearStr = typeof effectivePillars.year === 'string' ? effectivePillars.year : String(effectivePillars.year);
                const hourStr = typeof effectivePillars.hour === 'string' ? effectivePillars.hour : String(effectivePillars.hour);
                
                // 创建安全的pillars对象
                const safePillars = {
                    year: yearStr,
                    month: monthStr,
                    day: dayStr,
                    hour: hourStr
                };
                
                // 优化的专业八字财富算法 - 调整权重分配
                const wealthPositionScore = calculateWealthPosition(safePillars);    // 财星位置 (20分) - 最重要
                const dayMasterCapacity = calculateDayMasterCapacity(safePillars);   // 日主承载力 (15分) - 身财平衡
                const shishangScore = calculateShishangEnergy(safePillars);         // 食伤生财 (12分) - 生财之源
                const wealthStarScore = calculateWealthStarEnergy(safePillars);      // 财星能量 (10分)
                const wealthVaultScore = calculateWealthVault(safePillars);          // 财富库 (8分)
                const yinshouScore = calculateYinshouSupport(safePillars);          // 印绶护身 (6分)
                const selfVaultScore = calculateSelfSittingVault(safePillars);       // 自坐财库 (6分)
                const portalScore = calculateWealthPortal(safePillars);             // 财气通门户 (5分)
                const fromWealthScore = calculateFromWealthGrid(safePillars);        // 从财格 (0分，已废弃)
                
                // 基础分数
                let baseScore = shishangScore + yinshouScore + wealthStarScore + wealthPositionScore + wealthVaultScore + dayMasterCapacity + selfVaultScore + portalScore + fromWealthScore;
                
                // 十神组合特效
                const tenGodsBonus = calculateTenGodsEffects(safePillars);
                baseScore += tenGodsBonus;
                
                // 特殊格局识别和加分 - 直接调用八字排盘的特殊格局计算结果
                const baziData = window.currentBaziData || {};
                const specialPattern = detectSpecialPattern(safePillars, baziData);
                let specialBonus = 0;
                
                if (specialPattern && specialPattern !== '无') {
                    // 调整财富等级中的特殊格局加分，突出高贵格局的财富价值
                    if (specialPattern.includes('从财')) {
                        specialBonus += 25; // 从财格对财富最有利
                    } else if (specialPattern.includes('日贵')) {
                        specialBonus += 20; // 日贵格 - 贵人相助，财富丰厚
                    } else if (specialPattern.includes('魁罡')) {
                        specialBonus += 18; // 魁罡格 - 刚强有力，财富可观
                    } else if (specialPattern.includes('从弱') || specialPattern.includes('从儿')) {
                        specialBonus += 15; // 从弱格、从儿格对财富有利
                    } else if (specialPattern.includes('专旺')) {
                        specialBonus += 14; // 专旺格
                    } else if (specialPattern.includes('化气')) {
                        specialBonus += 12; // 化气格
                    } else if (specialPattern.includes('金神')) {
                        specialBonus += 11; // 金神格
                    } else if (specialPattern.includes('从强')) {
                        specialBonus += 8; // 从强格对财富相对不利
                    } else if (specialPattern.includes('三奇')) {
                        specialBonus += 10; // 三奇贵人格
                    } else {
                        specialBonus += 6; // 其他特殊格局
                    }
                }
                baseScore += specialBonus;
                
                // 身财平衡调整
                const balanceAdjustment = calculateBodyWealthBalance(safePillars);
                baseScore += balanceAdjustment;
                
                // 大运流年修正 (简化版本，基于当前年份)
                const luckAdjustment = calculateLuckAdjustment(safePillars, new Date().getFullYear());
                
                const dayunStrength = calculateDayunStrength(safePillars);
                let total = baseScore + luckAdjustment + dayunStrength; // 不再封顶，显示真实得分
                
                // 专业八字要素：空亡检查 - 传统命理核心理论
                const kongWangPenalty = calculateKongWangPenalty(safePillars);
                
                // 专业八字要素：喜忌平衡分析
                const favorableBalance = calculateFavorableBalance(safePillars);
                
                // 专业八字要素：季节性财运潜力
                const seasonalWealthPotential = calculateSeasonalWealthPotential(safePillars.day.charAt(0), safePillars.month.charAt(1));
                
                // 专业八字要素：财星保护分数（官星护财、印星化劫等）
                const wealthProtectionScore = calculateWealthProtectionScore(safePillars);
                
                // 调整总分，增加专业分析维度
                total = total + favorableBalance + seasonalWealthPotential + wealthProtectionScore - kongWangPenalty;
                
                // 应用传统否决条款（升级版）
                const vetoResult = applyTraditionalVetoRules(total, safePillars);
                total = vetoResult.adjustedScore;
                
                // 移除100分上限，显示真实财富评分
                
                // 基础模块合计（食伤生财、印绶护身、财星能量、财星位置、财富库藏、自坐财库、财气通门户、日主承载）
                const baseModulesTotal = shishangScore + yinshouScore + wealthStarScore + wealthPositionScore + wealthVaultScore + dayMasterCapacity + selfVaultScore + portalScore;
                
                wealthScoreDetails = {
                    shishangScore,
                    yinshouScore,
                    wealthStarScore,
                    wealthPositionScore,
                    wealthVaultScore,
                    dayMasterCapacity,
                    selfVaultScore,
                    portalScore,
                    fromWealthScore,
                    tenGodsBonus,
                    specialPatterns: specialPattern && specialPattern !== '无' ? [{ name: specialPattern, bonus: specialBonus }] : [],
                    specialBonus,
                    balanceAdjustment,
                    luckAdjustment,
                    dayunStrength,
                    // 新增专业八字分析要素
                    kongWangPenalty,
                    favorableBalance,
                    seasonalWealthPotential,
                    wealthProtectionScore,
                    // 基础合计为基础模块总和
                    baseScore: baseModulesTotal,
                    // 否决条款详情
                    vetoDetails: vetoResult.details,
                    // 否决条款前的分数
                    beforeVetoScore: baseModulesTotal + tenGodsBonus + specialBonus + balanceAdjustment + luckAdjustment + dayunStrength + favorableBalance + seasonalWealthPotential + wealthProtectionScore - kongWangPenalty,
                    total
                };
                wealthScoreValue = Math.round(total);
            }
            return wealthScoreValue;
        }

        // 辅助函数定义
        function isShishang(dayElement, element) {
            // 食伤: 日主所生的五行 (食神和伤官)
            const shishangMap = {
                '木': ['火'], '火': ['土'], '土': ['金'], '金': ['水'], '水': ['木']
            };
            return shishangMap[dayElement]?.includes(element);
        }

        function isYinshou(dayElement, element) {
            // 正印/偏印: 生日主的元素
            const yinshouMap = {
                '木': ['水'], '火': ['木'], '土': ['火'], '金': ['土'], '水': ['金']
            };
            return yinshouMap[dayElement]?.includes(element);
        }

        function isWealth(dayElement, element) {
            // 正财/偏财: 日所克的元素
            const wealthMap = {
                '木': ['土'], '火': ['金'], '土': ['水'], '金': ['木'], '水': ['火']
            };
            return wealthMap[dayElement]?.includes(element);
        }

        function hasWealthNearby(pillars) {
            // 检查食伤旁是否有财星 (简化检查月日柱)
            return isWealth(getStemElement(pillars.day.charAt(0)), getStemElement(pillars.month.charAt(0))) ||
                   isWealth(getStemElement(pillars.day.charAt(0)), getBranchElement(pillars.month.slice(1)));
        }

        // 计算食伤能量 - 作为财富源头 (15分) - 修正版
          function calculateShishangEnergy(pillars) {
             const dayElement = getStemElement(pillars.day.charAt(0));
             const dayStrength = calculateSimpleDayStrength(pillars);
             let score = 0;
             let shishangCount = 0;
             let wealthCount = 0;
             
             const positions = ['year', 'month', 'day', 'hour'];
             positions.forEach(pos => {
                 const stem = pillars[pos].charAt(0);
                 const branch = pillars[pos].slice(1);
                 if (isShishang(dayElement, getStemElement(stem))) {
                     score += 3; // 食伤在天干，基础得分
                     shishangCount++;
                 }
                 if (isShishang(dayElement, getBranchElement(branch))) {
                     score += 2; // 食伤在地支，基础得分
                     shishangCount++;
                 }
                 if (isWealth(dayElement, getStemElement(stem)) || isWealth(dayElement, getBranchElement(branch))) {
                     wealthCount++;
                 }
             });
             
             // 食伤生财组合 - 富贵之源
             if (shishangCount > 0 && wealthCount > 0) {
                 score += 4; // 食伤生财组合奖励
                 
                 // 身强食伤生财更佳
                 if (dayStrength >= 60) {
                     score += 2; // 身强能驾驭食伤
                 }
             }
             
             // 伤官佩印格局检查
             const yinCount = countYinStars(pillars);
             if (shishangCount >= 2 && yinCount >= 1 && dayStrength >= 40 && dayStrength <= 70) {
                 score += 2; // 伤官佩印格局
             }
             
             return Math.min(12, Math.round(score)); // 调整上限到12分
         }

        // 计算印绶支持 - 护身担财 (6分) - 优化版
         function calculateYinshouSupport(pillars) {
             const dayElement = getStemElement(pillars.day.charAt(0));
             const dayStrength = calculateSimpleDayStrength(pillars);
             const wealthStrength = calculateWealthStrength(pillars);
             let score = 0;
             let yinCount = 0;
             
             const positions = ['year', 'month', 'day', 'hour'];
             positions.forEach(pos => {
                 const stem = pillars[pos].charAt(0);
                 const branch = pillars[pos].slice(1);
                 if (isYinshou(dayElement, getStemElement(stem))) {
                     score += (pos === 'month' ? 3 : 1); // 月令印星最重要
                     yinCount++;
                 }
                 if (isYinshou(dayElement, getBranchElement(branch))) {
                     score += 1;
                     yinCount++;
                 }
             });
             
             // 身弱财旺时印星的重要性
             if (dayStrength < 50 && wealthStrength > 60) {
                 score += yinCount * 1; // 身弱财旺，印星护身
             }
             
             // 印星化杀生身 - 贵格
             const officerCount = calculateOfficerPresence(pillars);
             if (yinCount >= 1 && officerCount >= 1) {
                 score += 2; // 印星化杀，转危为安
             }
             
             return Math.min(6, score); // 调整上限到6分
         }

        // 计算财星能量 - 优化版（增加财星质量系数）
         function calculateWealthStarEnergy(pillars) {
             const dayElement = getStemElement(pillars.day.charAt(0));
             const monthBranch = pillars.month.slice(1);
             let totalEnergy = 0;
             
             const positions = ['year', 'month', 'day', 'hour'];
             positions.forEach(pos => {
                 const stem = pillars[pos].charAt(0);
                 const branch = pillars[pos].slice(1);
                 const stemElement = getStemElement(stem);
                 const branchElement = getBranchElement(branch);
                 
                 // 天干财星
                 if (isWealth(dayElement, stemElement)) {
                     let baseScore = (pos === 'month' || pos === 'day' ? 3 : 1);
                     let qualityFactor = calculateWealthQuality(stem, monthBranch, pillars);
                     totalEnergy += baseScore * qualityFactor;
                 }
                 
                 // 地支财星
                 if (isWealth(dayElement, branchElement)) {
                     let baseScore = 2;
                     let qualityFactor = calculateWealthQuality(branch, monthBranch, pillars);
                     totalEnergy += baseScore * qualityFactor * 0.6;
                 }
             });
             
             // 流通系数调整
             const flowFactor = calculateWealthFlow(pillars);
             totalEnergy *= flowFactor;
             
             const score = Math.min(10, totalEnergy); // 调整上限到10分
             return Math.max(0, Math.round(score));
         }
         
         // 新增：计算财星质量系数
         function calculateWealthQuality(wealthStar, monthBranch, pillars) {
             let quality = 1.0;
             
             // 得令系数（2.0）
             if (isWealthInSeason(wealthStar, monthBranch)) {
                 quality *= 2.0;
             }
             // 得地系数（1.5）
             else if (isWealthSupported(wealthStar, pillars)) {
                 quality *= 1.5;
             }
             // 有源系数（1.3）- 有食伤生财
             else if (hasWealthSource(wealthStar, pillars)) {
                 quality *= 1.3;
             }
             // 无破系数（1.2）- 无比劫夺财
             else if (!hasWealthDestruction(wealthStar, pillars)) {
                 quality *= 1.2;
             }
             // 被克泄系数（0.7）
             else if (isWealthWeakened(wealthStar, pillars)) {
                 quality *= 0.7;
             }
             
             return quality;
         }
         
         // 新增：计算财星流通系数
         function calculateWealthFlow(pillars) {
             let flow = 1.0;
             
             // 检查刑冲破害
             const harmFactor = calculateHarmEffects(pillars);
             flow *= harmFactor;
             
             // 检查合化效果
             const combineFactor = calculateCombineEffects(pillars);
             flow *= combineFactor;
             
             return Math.max(0.3, Math.min(2.5, flow));
         }
        
        // 新增：财星质量评估辅助函数
        function isWealthInSeason(wealthStar, monthBranch) {
            const wealthElement = getStemElement(wealthStar) || getBranchElement(wealthStar);
            const monthElement = getBranchElement(monthBranch);
            
            // 财星得令判断
            const seasonMap = {
                '木': ['寅', '卯'], '火': ['巳', '午'], 
                '土': ['辰', '戌', '丑', '未'], '金': ['申', '酉'], 
                '水': ['亥', '子']
            };
            
            return seasonMap[wealthElement]?.includes(monthBranch);
        }
        
        function isWealthSupported(wealthStar, pillars) {
            const wealthElement = getStemElement(wealthStar) || getBranchElement(wealthStar);
            const allBranches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
            
            // 检查是否有同类或生扶
            return allBranches.some(branch => {
                const branchElement = getBranchElement(branch);
                return branchElement === wealthElement || isElementSupporting(branchElement, wealthElement);
            });
        }
        
        function hasWealthSource(wealthStar, pillars) {
            const dayElement = getStemElement(pillars.day.charAt(0));
            const allStems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            
            // 检查是否有食伤生财
            return allStems.some(stem => isShishang(dayElement, getStemElement(stem)));
        }
        
        function hasWealthDestruction(wealthStar, pillars) {
            const dayElement = getStemElement(pillars.day.charAt(0));
            const allStems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            
            // 检查是否有比劫夺财
            return allStems.some(stem => {
                const stemElement = getStemElement(stem);
                return stemElement === dayElement; // 比劫同类
            });
        }
        
        function isWealthWeakened(wealthStar, pillars) {
            const wealthElement = getStemElement(wealthStar) || getBranchElement(wealthStar);
            const allElements = [];
            
            // 收集所有天干地支元素
            ['year', 'month', 'day', 'hour'].forEach(pos => {
                allElements.push(getStemElement(pillars[pos].charAt(0)));
                allElements.push(getBranchElement(pillars[pos].slice(1)));
            });
            
            // 检查是否被克或泄
            return allElements.some(element => {
                return isElementWeakening(element, wealthElement);
            });
        }
        
        function isElementSupporting(source, target) {
            const supportMap = {
                '木': ['火'], '火': ['土'], '土': ['金'], '金': ['水'], '水': ['木']
            };
            return supportMap[source]?.includes(target);
        }
        
        function isElementWeakening(source, target) {
             const weakenMap = {
                 '木': ['土'], '火': ['金'], '土': ['水'], '金': ['木'], '水': ['火']
             };
             const supportMap = {
                 '木': ['火'], '火': ['土'], '土': ['金'], '金': ['水'], '水': ['木']
             };
             return weakenMap[target]?.includes(source) || supportMap[target]?.includes(source);
         }
         
         function isElementControlling(source, target) {
             const controlMap = {
                 '木': ['土'], '火': ['金'], '土': ['水'], '金': ['木'], '水': ['火']
             };
             return controlMap[source]?.includes(target);
         }
         
         // 新增：刑冲破害效果计算
         function calculateHarmEffects(pillars) {
             let harmFactor = 1.0;
             const branches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
             
             // 相冲关系
             const chongPairs = [
                 ['子', '午'], ['丑', '未'], ['寅', '申'], ['卯', '酉'],
                 ['辰', '戌'], ['巳', '亥']
             ];
             
             // 相穿关系（六害）
             const chuanPairs = [
                 ['子', '未'], ['丑', '午'], ['寅', '巳'], ['卯', '辰'],
                 ['申', '亥'], ['酉', '戌']
             ];
             
             // 相刑关系
             const xingGroups = [
                 ['寅', '巳', '申'], // 无恩之刑
                 ['丑', '戌', '未'], // 恃势之刑
                 ['子', '卯']       // 无礼之刑
             ];
             
             // 检查相冲
             for (const pair of chongPairs) {
                 if (branches.includes(pair[0]) && branches.includes(pair[1])) {
                     // 财库逢冲是好事，其他冲一般不利
                     if (['辰', '戌', '丑', '未'].includes(pair[0]) || ['辰', '戌', '丑', '未'].includes(pair[1])) {
                         harmFactor *= 1.5; // 财库逢冲，冲开财库
                     } else {
                         harmFactor *= 0.8; // 其他冲减分
                     }
                 }
             }
             
             // 检查相穿（特别是申亥相穿）
             for (const pair of chuanPairs) {
                 if (branches.includes(pair[0]) && branches.includes(pair[1])) {
                     if ((pair[0] === '申' && pair[1] === '亥') || (pair[0] === '亥' && pair[1] === '申')) {
                         harmFactor *= 0.6; // 申亥相穿，严重减分
                     } else {
                         harmFactor *= 0.85; // 其他相穿
                     }
                 }
             }
             
             // 检查相刑
             for (const group of xingGroups) {
                 const presentCount = group.filter(branch => branches.includes(branch)).length;
                 if (presentCount >= 2) {
                     harmFactor *= Math.pow(0.9, presentCount - 1); // 相刑减分
                 }
             }
             
             return harmFactor;
         }
         
         // 新增：合化效果计算
         function calculateCombineEffects(pillars) {
             let combineFactor = 1.0;
             const branches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
             
             // 六合关系
             const liuHePairs = [
                 ['子', '丑'], ['寅', '亥'], ['卯', '戌'],
                 ['辰', '酉'], ['巳', '申'], ['午', '未']
             ];
             
             // 三合局
             const sanHeGroups = [
                 ['申', '子', '辰'], // 水局
                 ['亥', '卯', '未'], // 木局
                 ['寅', '午', '戌'], // 火局
                 ['巳', '酉', '丑']  // 金局
             ];
             
             // 检查六合
             for (const pair of liuHePairs) {
                 if (branches.includes(pair[0]) && branches.includes(pair[1])) {
                     // 寅亥合化木，对财运有利
                     if ((pair[0] === '寅' && pair[1] === '亥') || (pair[0] === '亥' && pair[1] === '寅')) {
                         combineFactor *= 1.4; // 寅亥合化，化忌为喜
                     } else {
                         combineFactor *= 1.2; // 其他六合
                     }
                 }
             }
             
             // 检查三合局
             for (const group of sanHeGroups) {
                 const presentCount = group.filter(branch => branches.includes(branch)).length;
                 if (presentCount === 3) {
                     combineFactor *= 1.8; // 三合财局，大吉
                 } else if (presentCount === 2) {
                     combineFactor *= 1.3; // 半合局
                 }
             }
             
             return combineFactor;
          }
          
          // 新增：十神组合特效计算
          function calculateTenGodsEffects(pillars) {
              let bonus = 0;
              const dayElement = getStemElement(pillars.day.charAt(0));
              
              // 获取当前格局类型
              let patternType = '普通格局';
              if (window.currentBaziData && window.currentBaziData.strengthAnalysis) {
                  patternType = window.currentBaziData.strengthAnalysis.type || '普通格局';
              }
              
              // 官星带财库检查
              const hasOfficer = ['year', 'month', 'hour'].some(pos => {
                  const stem = pillars[pos].charAt(0);
                  return isOfficer(dayElement, getStemElement(stem));
              });
              
              const hasWealthVault = ['year', 'month', 'day', 'hour'].some(pos => {
                  const branch = pillars[pos].slice(1);
                  return ['辰', '戌', '丑', '未'].includes(branch);
              });
              
              if (hasOfficer && hasWealthVault) {
                  bonus += 25; // 官星带财库
              }
              
              // 劫财夺财无制检查 - 考虑格局类型
              const robbingWealth = ['year', 'month', 'hour'].filter(pos => {
                  const stem = pillars[pos].charAt(0);
                  const stemElement = getStemElement(stem);
                  return stemElement === dayElement; // 比劫同类
              }).length;
              
              const hasControl = ['year', 'month', 'hour'].some(pos => {
                  const stem = pillars[pos].charAt(0);
                  return isOfficer(dayElement, getStemElement(stem)); // 有官杀制比劫
              });
              
              if (robbingWealth > 0 && !hasControl) {
                  // 根据格局类型调整比劫的影响
                  if (patternType === '从强') {
                      // 从强格：比劫是用神，不扣分，反而加分
                      bonus += 15; // 比劫助身，有利财运
                  } else if (patternType === '从弱') {
                      // 从弱格：比劫是忌神，扣分更重
                      bonus -= 25; // 比劫夺财，严重不利
                  } else {
                      // 普通格局：按原逻辑扣分
                      bonus -= 20; // 劫财夺财无制
                  }
              }
              
              // 暗拱财局检查（简化版）
              const wealthStars = [];
              ['year', 'month', 'hour'].forEach(pos => {
                  const stem = pillars[pos].charAt(0);
                  if (isWealth(dayElement, getStemElement(stem))) {
                      wealthStars.push(pos);
                  }
              });
              
              if (wealthStars.length >= 2) {
                  // 检查是否有克制财星的因素
                  const hasWealthDestruction = ['year', 'month', 'hour'].some(pos => {
                      const stem = pillars[pos].charAt(0);
                      const stemElement = getStemElement(stem);
                      return wealthStars.some(wPos => {
                          const wealthStem = pillars[wPos].charAt(0);
                          const wealthElement = getStemElement(wealthStem);
                          return isElementWeakening(stemElement, wealthElement);
                      });
                  });
                  
                  if (hasWealthDestruction) {
                      bonus += 18; // 暗拱财局但受克
                  }
              }
              
              return bonus;
           }
           
           // 新增：否决条款检查
           function applyVetoRules(score, pillars) {
               let adjustedScore = score;
               const dayElement = getStemElement(pillars.day.charAt(0));
               
               // 1. 财星被合化忌神检查
               const wealthStars = [];
               ['year', 'month', 'hour'].forEach(pos => {
                   const stem = pillars[pos].charAt(0);
                   if (isWealth(dayElement, getStemElement(stem))) {
                       wealthStars.push({pos, stem});
                   }
               });
               
               // 检查财星是否被合化为忌神（简化版）
               const hasWealthCombinedToTaboo = wealthStars.some(wealth => {
                   // 检查申亥相穿等不利组合
                   const branches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
                   return branches.includes('申') && branches.includes('亥');
               });
               
               if (hasWealthCombinedToTaboo) {
                   adjustedScore -= 50; // 财星被合化忌神，严重减分
               }
               
               // 2. 全局无明现财库检查
               const hasWealthVault = ['year', 'month', 'day', 'hour'].some(pos => {
                   const branch = pillars[pos].slice(1);
                   return ['辰', '戌', '丑', '未'].includes(branch);
               });
               
               if (!hasWealthVault) {
                   adjustedScore = Math.min(67, adjustedScore); // 无财库，分数封顶67
               }
               
               // 3. 比劫夺财无制检查
               const robbingWealth = ['year', 'month', 'hour'].filter(pos => {
                   const stem = pillars[pos].charAt(0);
                   const stemElement = getStemElement(stem);
                   return stemElement === dayElement; // 比劫同类
               }).length;
               
               const hasControl = ['year', 'month', 'hour'].some(pos => {
                   const stem = pillars[pos].charAt(0);
                   return isOfficer(dayElement, getStemElement(stem)); // 有官杀制比劫
               });
               
               if (robbingWealth > 1 && !hasControl) {
                   // 比劫夺财无制，财富等级自动降一级
                   adjustedScore *= 0.8;
               }
               
               // 4. 身不胜财否决条款
               const dayStrength = calculateSimpleDayStrength(pillars);
               const wealthCount = ['year', 'month', 'hour'].filter(pos => {
                   const stem = pillars[pos].charAt(0);
                   return isWealth(dayElement, getStemElement(stem));
               }).length;
               const biJieCount = countBiJieStars(pillars);
               
               // 财多身弱且无比劫帮身的情况，限制最高分数
               // 但排除真从财格（日主极弱且财星极多的情况）
               if (dayStrength < 40 && wealthCount >= 3 && biJieCount === 0 && !(dayStrength <= 35 && wealthCount >= 4)) {
                   adjustedScore = Math.min(adjustedScore, 60); // 身不胜财最高60分
               }
               
               return Math.max(0, Math.round(adjustedScore));
            }
            
            // 新增：特殊格局识别模块 - 优化版，优先使用 strengthAnalysis.type
            function identifySpecialPatterns(pillars) {
                const dayElement = getStemElement(pillars.day.charAt(0));
                const patterns = [];
                
                // 优先使用已计算的身强身弱分析结果
                if (window.currentBaziData && window.currentBaziData.strengthAnalysis) {
                    const analysis = window.currentBaziData.strengthAnalysis;
                    
                    // 1. 从强格识别
                    if (analysis.type === '从强') {
                        patterns.push({
                            name: '从强格',
                            description: '日主极强，从比劫印星之势，宜用食伤财星',
                            bonus: 25 // 从强格财富潜力很高
                        });
                    }
                    
                    // 2. 从弱格识别  
                    if (analysis.type === '从弱') {
                        patterns.push({
                            name: '从弱格',
                            description: '日主极弱，从财官食伤之势，富贵可期',
                            bonus: 30 // 从弱格往往财富更好
                        });
                    }
                }
                
                // 财星相关格局分析（补充分析）
                let wealthCount = 0;
                ['year', 'month', 'day', 'hour'].forEach(pos => {
                    const stem = pillars[pos].charAt(0);
                    const branch = pillars[pos].charAt(1);
                    if (isWealth(dayElement, getStemElement(stem))) wealthCount++;
                    if (isWealth(dayElement, getBranchElement(branch))) wealthCount++;
                });
                
                const biJieCount = countBiJieStars(pillars);
                const yinCount = countYinStars(pillars);
                const dayStrength = calculateSimpleDayStrength(pillars);
                
                // 3. 从财格识别 - 备用方案（当无 strengthAnalysis 时）
                if ((!window.currentBaziData || !window.currentBaziData.strengthAnalysis) && 
                    wealthCount >= 2 && biJieCount === 0 && yinCount <= 1) {
                    
                    const wealthStrength = calculateWealthStrength(pillars);
                    
                    // 真从财格：日主极弱(≤35)且财星数量多(≥4)
                    if (dayStrength <= 35 && wealthCount >= 4) {
                        patterns.push({
                            name: '真从财格',
                            description: '日主极弱从财星之势，富贵可期',
                            bonus: 30 // 真从财格财富潜力很高
                        });
                    }
                    // 假从财格：日主较弱但财星较多
                    else if (dayStrength <= 50 && wealthCount >= 3) {
                        patterns.push({
                            name: '假从财格',
                            description: '日主偏弱，财星较旺，中等富贵',
                            bonus: 18 // 假从财格有一定财富潜力
                        });
                    }
                }
                
                // 4. 身不胜财检查（通用）
                if (dayStrength < 40 && wealthCount >= 3 && (biJieCount + yinCount) === 0) {
                    // 排除已识别的从格
                    const hasFromPattern = patterns.some(p => 
                        p.name.includes('从强') || p.name.includes('从弱') || p.name.includes('从财')
                    );
                    
                    if (!hasFromPattern) {
                        patterns.push({
                            name: '身不胜财',
                            description: '财星过多，日主承载不足',
                            bonus: -15
                        });
                    }
                }
                
                // 2. 从杀格识别
                const officerCount = ['year', 'month', 'hour'].filter(pos => {
                    const stem = pillars[pos].charAt(0);
                    return isOfficer(dayElement, getStemElement(stem));
                }).length;
                
                if (officerCount >= 2 && biJieCount === 0 && yinCount === 0) {
                    patterns.push({
                        name: '从杀格',
                        description: '日主从官杀之势，权贵之命',
                        bonus: 25
                    });
                }
                
                // 3. 化气格识别（超严格版）- 需要多重条件同时满足
                const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.day.charAt(0), pillars.hour.charAt(0)];
                const chemicalCombinations = [
                    ['甲', '己', '土'], ['乙', '庚', '金'], ['丙', '辛', '水'], ['丁', '壬', '木'], ['戊', '癸', '火']
                ];
                
                // 严格化气格条件：
                // 1. 日干必须参与化合（月日化合或日时化合）
                // 2. 化神必须在天干中透出
                // 3. 化神得月令旺气
                // 4. 无明显破格因素
                
                const dayIndex = 2; // 日干在stems数组中的位置
                const dayStem = stems[dayIndex];
                
                for (const [stem1, stem2, element] of chemicalCombinations) {
                    let isValidChemical = false;
                    let chemicalDescription = '';
                    
                    // 只认可日干参与的化合：月日化合或日时化合
                    if (dayStem === stem1) {
                        if (stems[1] === stem2) { // 月日化合
                            isValidChemical = true;
                            chemicalDescription = '月日化合';
                        } else if (stems[3] === stem2) { // 日时化合
                            isValidChemical = true;
                            chemicalDescription = '日时化合';
                        }
                    } else if (dayStem === stem2) {
                        if (stems[1] === stem1) { // 月日化合
                            isValidChemical = true;
                            chemicalDescription = '月日化合';
                        } else if (stems[3] === stem1) { // 日时化合
                            isValidChemical = true;
                            chemicalDescription = '日时化合';
                        }
                    }
                    
                    if (isValidChemical) {
                        // 检查化神是否透出
                        const chemicalElementStems = {
                            '土': ['戊', '己'],
                            '金': ['庚', '辛'],
                            '水': ['壬', '癸'],
                            '木': ['甲', '乙'],
                            '火': ['丙', '丁']
                        };
                        
                        const hasChemicalStemTransparent = stems.some(stem => 
                            chemicalElementStems[element] && chemicalElementStems[element].includes(stem)
                        );
                        
                        // 检查化神是否得月令之气
                        const monthBranch = pillars.month.slice(1);
                        const monthElement = getBranchElement(monthBranch);
                        const isChemicalSupported = monthElement === element || isGenerateElement(monthElement, element);
                        
                        // 只有同时满足化神透出且得月令之气才认定为化气格
                        if (hasChemicalStemTransparent && isChemicalSupported) {
                            patterns.push({
                                name: '化气格',
                                description: `${stem1}${stem2}化${element}（${chemicalDescription}），化神透出得令`,
                                bonus: 18
                            });
                        }
                        break;
                    }
                }
                
                // 4. 专旺格识别
                const dayBranch = pillars.day.slice(1);
                const monthBranch = pillars.month.slice(1);
                
                // 曲直格（木专旺）
                if (dayElement === '木' && ['寅', '卯'].includes(monthBranch)) {
                    const woodCount = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)]
                        .filter(branch => ['寅', '卯', '辰'].includes(branch)).length;
                    if (woodCount >= 3) {
                        patterns.push({
                            name: '曲直格',
                            description: '木气专旺，文贵之命',
                            bonus: 15
                        });
                    }
                }
                
                // 炎上格（火专旺）
                if (dayElement === '火' && ['巳', '午'].includes(monthBranch)) {
                    const fireCount = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)]
                        .filter(branch => ['巳', '午', '未'].includes(branch)).length;
                    if (fireCount >= 3) {
                        patterns.push({
                            name: '炎上格',
                            description: '火气专旺，威权之命',
                            bonus: 15
                        });
                    }
                }
                
                return patterns;
            }
           
           // 获取旺衰系数
        function getSeasonCoefficient(stem, branch, monthBranch) {
            // 简化的旺衰判断
            if (isDayStemInSeason(stem, monthBranch)) {
                return 2.0; // 得令
            }
            
            // 根据五行生克关系判断
            const stemElement = getStemElement(stem);
            const monthElement = getBranchElement(monthBranch);
            
            if (isElementSupported(stemElement, monthElement)) {
                return 1.5; // 得地
            } else if (isElementNeutral(stemElement, monthElement)) {
                return 1.0; // 平和
            } else {
                return 0.6; // 失令
            }
        }
        
        // 获取天干五行
        function getStemElement(stem) {
            const elementMap = {
                '甲': '木', '乙': '木',
                '丙': '火', '丁': '火',
                '戊': '土', '己': '土',
                '庚': '金', '辛': '金',
                '壬': '水', '癸': '水'
            };
            return elementMap[stem] || '土';
        }
        
        // 获取地支五行
        function getBranchElement(branch) {
            const elementMap = {
                '寅': '木', '卯': '木',
                '巳': '火', '午': '火',
                '申': '金', '酉': '金',
                '亥': '水', '子': '水',
                '辰': '土', '戌': '土', '丑': '土', '未': '土'
            };
            return elementMap[branch] || '土';
        }
        
        // 判断五行是否得生
        function isElementSupported(element, monthElement) {
            const supportMap = {
                '木': ['水'],
                '火': ['木'],
                '土': ['火'],
                '金': ['土'],
                '水': ['金']
            };
            return supportMap[element]?.includes(monthElement) || false;
        }
        
        // 判断五行是否中性
        function isElementNeutral(element, monthElement) {
            return element !== monthElement && !isElementSupported(element, monthElement) && !isElementWeakened(element, monthElement);
        }
        
        // 判断五行是否被克
        function isElementWeakened(element, monthElement) {
            const weakenMap = {
                '木': ['金'],
                '火': ['水'],
                '土': ['木'],
                '金': ['火'],
                '水': ['土']
            };
            return weakenMap[element]?.includes(monthElement) || false;
        }

        // 判断财星是否有利
        function isFavorableWealth(dayStem, wealthStem) {
            const dayElement = getStemElement(dayStem);
            const wealthElement = getStemElement(wealthStem);
            return isElementSupported(dayElement, wealthElement) || dayElement === wealthElement;
        }

        // 计算财星位置分数 (20分) - 专业命理优化版
        function calculateWealthPosition(pillars) {
            let score = 0;
            const dayStem = pillars.day.charAt(0);
            const dayStrength = calculateSimpleDayStrength(pillars);
            const zhengCai = getZhengCai(dayStem);
            const pianCai = getPianCai(dayStem);
            const wealthBranches = getWealthBranches(dayStem);

            // 月令财星 - 财气通门户（最重要）
            if (wealthBranches.includes(pillars.month.charAt(1))) {
                score += 8; // 月支见财，财气通门户，最重要
            }
            if (pillars.month.charAt(0) === zhengCai || pillars.month.charAt(0) === pianCai) {
                score += 6; // 月干见财
            }
            
            // 时上偏财格 - 晚年富贵
            if (pillars.hour.charAt(0) === pianCai) {
                score += 5; // 时上偏财，晚年发达
            }
            
            // 日坐财星 - 配偶助财
            if (wealthBranches.includes(pillars.day.charAt(1))) {
                score += 4; // 日支见财，配偶助财
                if (dayStrength >= 60) {
                    score += 2; // 身强坐财更佳
                }
            }
            
            // 年柱财星 - 祖业或早年财运
            if (pillars.year.charAt(0) === zhengCai || pillars.year.charAt(0) === pianCai) {
                score += 3; // 年干见财
            }
            if (wealthBranches.includes(pillars.year.charAt(1))) {
                score += 2; // 年支见财
            }

            return Math.min(20, score);
        }

        // 计算财星强度分数 (20分)
        function calculateWealthStrength(pillars) {
            // 优先使用 currentBaziData 提供的月令信息
            let monthBranch = pillars.month.charAt(1);
            if (window.currentBaziData && window.currentBaziData.pillars && typeof window.currentBaziData.pillars.month === 'string') {
                const mb = window.currentBaziData.pillars.month;
                if (mb.length > 1) monthBranch = mb.charAt(1);
            }
            
            let score = 0;
            const dayStem = pillars.day.charAt(0);
            const wealthStems = [getZhengCai(dayStem), getPianCai(dayStem)];

            wealthStems.forEach(stem => {
                const coeff = getSeasonCoefficient(stem, '', monthBranch);
                score += coeff * 5;
            });

            return Math.min(8, Math.round(score)); // 降低上限到8分
        }

        // 计算财富库分数 (10分) - 优化版
        function calculateWealthVault(pillars) {
            const dayStem = pillars.day.charAt(0);
            const dayElement = getStemElement(dayStem);
            const vaults = ['辰', '戌', '丑', '未'];
            let score = 0;
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 财库的定义：土为甲乙木的财库，金为丙丁火的财库等
            const wealthVaultMap = {
                '甲': ['辰', '戌', '丑', '未'], // 土库
                '乙': ['辰', '戌', '丑', '未'],
                '丙': ['申', '酉'], // 金库（简化）
                '丁': ['申', '酉'],
                '戊': ['子', '亥'], // 水库（简化）
                '己': ['子', '亥'],
                '庚': ['寅', '卯'], // 木库（简化）
                '辛': ['寅', '卯'],
                '壬': ['午', '巳'], // 火库（简化）
                '癸': ['午', '巳']
            };
            
            const myWealthVaults = wealthVaultMap[dayStem] || [];
            let vaultCount = 0;
            
            branches.forEach((branch, index) => {
                if (myWealthVaults.includes(branch)) {
                    vaultCount++;
                    if (index === 1) score += 5; // 月支财库最重要
                    else if (index === 2) score += 4; // 日支财库
                    else score += 2; // 年时财库
                }
            });
            
            // 财库逢冲 - 冲开财库发大财
            const chongMap = {
                '辰': '戌', '戌': '辰', '丑': '未', '未': '丑',
                '子': '午', '午': '子', '卯': '酉', '酉': '卯',
                '寅': '申', '申': '寅', '巳': '亥', '亥': '巳'
            };
            
            branches.forEach(branch1 => {
                if (myWealthVaults.includes(branch1)) {
                    branches.forEach(branch2 => {
                        if (chongMap[branch1] === branch2) {
                            score += 8; // 财库逢冲，财富爆发
                        }
                    });
                }
            });
            
            // 四库俱全特殊加分
            const uniqueVaults = new Set(branches.filter(b => vaults.includes(b)));
            if (uniqueVaults.size === 4) score += 6; // 四库俱全，财富丰厚
            
            return Math.min(8, score); // 降低上限到8分
        }
        
        // 计算自坐财库 (6分)
        function calculateSelfSittingVault(pillars) {
            const dayElement = getStemElement(pillars.day.charAt(0));
            const dayBranch = pillars.day.charAt(1);
            const vaults = ['辰', '戌', '丑', '未'];
            const vaultElements = { '辰': '土', '戌': '土', '丑': '土', '未': '土' };
            if (vaults.includes(dayBranch) && isWealth(dayElement, vaultElements[dayBranch])) {
                return 6; // 调整自坐财库分数
            }
            return 0;
        }
        
        // 计算财气通门户 (5分) - 优化版
        function calculateWealthPortal(pillars) {
            const dayStrength = calculateSimpleDayStrength(pillars);
            const monthBranch = pillars.month.charAt(1);
            const dayStem = pillars.day.charAt(0);
            const wealthBranches = getWealthBranches(dayStem);
            
            let score = 0;
            
            // 月令财星 - 财气通门户的核心
            if (wealthBranches.includes(monthBranch)) {
                score += 3; // 月令见财，财气通门户
                
                // 身强配财星更佳
                if (dayStrength >= 60) {
                    score += 1; // 身强能胜财
                }
                
                // 有食伤生财更佳
                const hasShishang = calculateShishangEnergy(pillars) > 0;
                if (hasShishang) {
                    score += 1; // 食伤生财，源源不断
                }
            }
            
            // 时柱见财星 - 晚年富贵
            const hourBranch = pillars.hour.charAt(1);
            if (wealthBranches.includes(hourBranch)) {
                score += 2; // 时上见财，晚年富足
            }
            
            return Math.min(5, score); // 调整上限到5分
        }
        
        // 计算从财格分数 - 已废弃，统一由identifySpecialPatterns处理
        function calculateFromWealthGrid(pillars) {
            // 从财格识别已统一由identifySpecialPatterns函数处理
            // 避免重复计分，此函数返回0
            return 0;
        }
        
        // 新函数：检查官杀存在
        function calculateOfficerPresence(pillars) {
            const dayElement = getStemElement(pillars.day.charAt(0));
            let presence = 0;
            const positions = ['year', 'month', 'day', 'hour'];
            positions.forEach(pos => {
                const stem = pillars[pos].charAt(0);
                if (isOfficer(dayElement, getStemElement(stem))) presence += 1;
            });
            return presence;
        }
        
        // 新辅助函数：判断是否官杀
        function isOfficer(dayElement, element) {
            const officerMap = {
                '木': ['金'], '火': ['水'], '土': ['木'], '金': ['火'], '水': ['土']
            };
            return officerMap[dayElement]?.includes(element);
        }
                
        
        // 计算比劫星数量
        function countBiJieStars(pillars) {
            const dayStem = pillars.day.charAt(0);
            const biJieStars = getBiJieStars(dayStem);
            const allChars = [
                pillars.year.charAt(0), pillars.year.charAt(1),
                pillars.month.charAt(0), pillars.month.charAt(1),
                pillars.hour.charAt(0), pillars.hour.charAt(1)
            ];
            return allChars.filter(char => biJieStars.includes(char)).length;
        }
        
        // 计算印星数量
        function countYinStars(pillars) {
            const dayStem = pillars.day.charAt(0);
            const yinStars = getYinStars(dayStem);
            const allChars = [
                pillars.year.charAt(0), pillars.year.charAt(1),
                pillars.month.charAt(0), pillars.month.charAt(1),
                pillars.hour.charAt(0), pillars.hour.charAt(1)
            ];
            return allChars.filter(char => yinStars.includes(char)).length;
        }
        
        // 计算身财平衡调整 (-10 to +10) - 优化版
        // 升级版身财平衡算法 - 非线性阈值计算
        function calculateBodyWealthBalance(pillars) {
            const dayStrength = calculateSimpleDayStrength(pillars);
            const wealthStrength = calculateWealthStrength(pillars);
            
            // 计算承载系数
            const carryingCapacity = wealthStrength > 0 ? dayStrength / wealthStrength : dayStrength / 50;
            
            let balanceScore = 0;
            
            // 非线性阈值算法
            if (carryingCapacity > 1.5) {
                // 身强财弱，承载力过剩
                balanceScore = Math.min(15, carryingCapacity * 5);
            } else if (carryingCapacity >= 0.8 && carryingCapacity <= 1.5) {
                // 身财平衡，最佳状态
                balanceScore = carryingCapacity * 10;
            } else {
                // 身弱财强，承载不足
                balanceScore = -10 + (carryingCapacity - 0.5) * 20;
            }
            
            // 特殊格局修正 - 移除重复的从财格判断
            if (carryingCapacity < 0.3) {
                // 身极弱财极强的情况，由identifySpecialPatterns统一处理
                // 这里只做基础的身财平衡计算
                balanceScore = -10; // 身弱财强，承载不足
            }
            
            // 身强财旺特殊加分
            if (dayStrength >= 70 && wealthStrength >= 70) {
                balanceScore += 5; // 身强财旺，额外加分
            }
            
            return Math.max(-20, Math.min(20, Math.round(balanceScore)));
        }
        
        // 简化的日主强度计算 - 优先使用已计算的身强身弱分析
        function calculateSimpleDayStrength(pillars) {
            // 优先使用已计算的身强身弱分析结果
            if (window.currentBaziData && window.currentBaziData.strengthAnalysis) {
                const analysis = window.currentBaziData.strengthAnalysis;
                
                // 将身强身弱类型转换为数值
                let strength = 50; // 默认中等
                
                switch(analysis.type) {
                    case '身强':
                        strength = 75;
                        break;
                    case '身弱':
                        strength = 25;
                        break;
                    case '从强':
                        strength = 85;
                        break;
                    case '从弱':
                        strength = 15;
                        break;
                    case '化气':
                        strength = 60;
                        break;
                    default:
                        // 使用力量比例计算
                        if (analysis.ratio !== undefined) {
                            strength = Math.round(analysis.ratio * 100);
                        }
                }
                
                return Math.max(10, Math.min(100, strength));
            }
            
            // 备用计算方法（原有逻辑）
            const dayStem = pillars.day.charAt(0);
            const monthBranch = pillars.month.charAt(1);
            
            let strength = 40; // 基础值
            
            // 月令对日主的影响 (最重要)
            if (isDayStemInSeason(dayStem, monthBranch)) {
                strength += 25; // 日主当令
            } else if (isDayStemSupported(dayStem, monthBranch)) {
                strength += 15; // 日主得生
            } else {
                strength -= 10; // 日主失令
            }
            
            // 其他柱的比劫帮身
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            const biJieStars = getBiJieStars(dayStem);
            
            stems.forEach(stem => {
                if (biJieStars.includes(stem)) {
                    strength += 12; // 比劫帮身
                }
            });
            
            // 印星生身
            const yinStars = getYinStars(dayStem);
            stems.forEach(stem => {
                if (yinStars.includes(stem)) {
                    strength += 10; // 印星生身
                }
            });
            
            return Math.max(10, Math.min(100, strength));
        }
        
        // 判断日主是否当令
        function isDayStemInSeason(dayStem, monthBranch) {
            const seasonMap = {
                '甲': ['寅', '卯'], '乙': ['寅', '卯'], // 木旺于春
                '丙': ['午', '巳'], '丁': ['午', '巳'], // 火旺于夏
                '戊': ['辰', '戌', '丑', '未'], '己': ['辰', '戌', '丑', '未'], // 土旺于四季
                '庚': ['申', '酉'], '辛': ['申', '酉'], // 金旺于秋
                '壬': ['子', '亥'], '癸': ['子', '亥']  // 水旺于冬
            };
            return seasonMap[dayStem]?.includes(monthBranch) || false;
        }
        
        // 判断日主是否得生
        function isDayStemSupported(dayStem, monthBranch) {
            const supportMap = {
                '甲': ['子', '亥'], '乙': ['子', '亥'], // 水生木
                '丙': ['寅', '卯'], '丁': ['寅', '卯'], // 木生火
                '戊': ['午', '巳'], '己': ['午', '巳'], // 火生土
                '庚': ['辰', '戌', '丑', '未'], '辛': ['辰', '戌', '丑', '未'], // 土生金
                '壬': ['申', '酉'], '癸': ['申', '酉']  // 金生水
            };
            return supportMap[dayStem]?.includes(monthBranch) || false;
        }
        
        // 判断财星是否当令
        function isWealthInSeason(dayStem, monthBranch) {
            const wealthSeasonMap = {
                '甲': ['辰', '戌', '丑', '未'], '乙': ['辰', '戌', '丑', '未'], // 土财旺于四季
                '丙': ['申', '酉'], '丁': ['申', '酉'], // 金财旺于秋
                '戊': ['子', '亥'], '己': ['子', '亥'], // 水财旺于冬
                '庚': ['寅', '卯'], '辛': ['寅', '卯'], // 木财旺于春
                '壬': ['午', '巳'], '癸': ['午', '巳']  // 火财旺于夏
            };
            return wealthSeasonMap[dayStem]?.includes(monthBranch) || false;
        }
        
        // 获取月令对日主的支持度
        function getMonthSupport(dayStem, monthBranch) {
            const supportMap = {
                '甲': { '寅': 20, '卯': 15, '子': 10, '亥': 8, '辰': 5, '未': 5 },
                '乙': { '卯': 20, '寅': 15, '亥': 10, '子': 8, '辰': 5, '未': 5 },
                '丙': { '午': 20, '巳': 15, '寅': 10, '卯': 8, '戌': 5, '未': 5 },
                '丁': { '巳': 20, '午': 15, '卯': 10, '寅': 8, '戌': 5, '未': 5 },
                '戊': { '戌': 20, '未': 15, '午': 10, '巳': 8, '辰': 5, '丑': 5 },
                '己': { '未': 20, '戌': 15, '巳': 10, '午': 8, '丑': 5, '辰': 5 },
                '庚': { '申': 20, '酉': 15, '戌': 10, '未': 8, '辰': 5, '丑': 5 },
                '辛': { '酉': 20, '申': 15, '未': 10, '戌': 8, '丑': 5, '辰': 5 },
                '壬': { '子': 20, '亥': 15, '申': 10, '酉': 8, '辰': 5, '丑': 5 },
                '癸': { '亥': 20, '子': 15, '酉': 10, '申': 8, '丑': 5, '辰': 5 }
            };
            
            return supportMap[dayStem] && supportMap[dayStem][monthBranch] ? supportMap[dayStem][monthBranch] : -10;
        }
        
        // 获取支持日主的星
        function getSupportStars(dayStem) {
            const supportMap = {
                '甲': ['甲', '乙', '寅', '卯', '壬', '癸', '子', '亥'], // 比劫 + 印星
                '乙': ['甲', '乙', '寅', '卯', '壬', '癸', '子', '亥'],
                '丙': ['丙', '丁', '午', '巳', '甲', '乙', '寅', '卯'],
                '丁': ['丙', '丁', '午', '巳', '甲', '乙', '寅', '卯'],
                '戊': ['戊', '己', '辰', '戌', '丑', '未', '丙', '丁', '午', '巳'],
                '己': ['戊', '己', '辰', '戌', '丑', '未', '丙', '丁', '午', '巳'],
                '庚': ['庚', '辛', '申', '酉', '戊', '己', '辰', '戌', '丑', '未'],
                '辛': ['庚', '辛', '申', '酉', '戊', '己', '辰', '戌', '丑', '未'],
                '壬': ['壬', '癸', '子', '亥', '庚', '辛', '申', '酉'],
                '癸': ['壬', '癸', '子', '亥', '庚', '辛', '申', '酉']
            };
            return supportMap[dayStem] || [];
        }
        
        // 计算财星强度分数 - 100分制版 (20分) - 保留作为备用
        function calculateWealthStarScore(pillars) {
            const dayStr = typeof pillars.day === 'string' ? pillars.day : String(pillars.day);
            const monthStr = typeof pillars.month === 'string' ? pillars.month : String(pillars.month);
            const yearStr = typeof pillars.year === 'string' ? pillars.year : String(pillars.year);
            const hourStr = typeof pillars.hour === 'string' ? pillars.hour : String(pillars.hour);
            
            const dayStem = dayStr.charAt(0);
            const dayBranch = dayStr.charAt(1);
            const monthBranch = monthStr.charAt(1);
            
            let score = 5; // 基础分数
            
            // 1. 正财偏财透干得分 (最高10分)
            const zhengCai = getZhengCai(dayStem);
            const pianCai = getPianCai(dayStem);
            const stems = [yearStr.charAt(0), monthStr.charAt(0), hourStr.charAt(0)];
            
            let zhengCaiCount = 0;
            let pianCaiCount = 0;
            stems.forEach(stem => {
                if (stem === zhengCai) zhengCaiCount++;
                if (stem === pianCai) pianCaiCount++;
            });
            
            // 正财透干评分
            if (zhengCaiCount >= 2) score += 10;
            else if (zhengCaiCount === 1) score += 8;
            
            // 偏财透干评分
            if (pianCaiCount >= 2) score += 8;
            else if (pianCaiCount === 1) score += 6;
            
            // 2. 财星在地支的强度 (最高7分)
            const wealthBranches = getWealthBranches(dayStem);
            const branches = [yearStr.charAt(1), monthStr.charAt(1), dayStr.charAt(1), hourStr.charAt(1)];
            
            let branchWealthCount = 0;
            branches.forEach(branch => {
                if (wealthBranches.includes(branch)) {
                    branchWealthCount++;
                }
            });
            
            // 地支财星评分
            if (branchWealthCount >= 3) score += 7;
            else if (branchWealthCount === 2) score += 5;
            else if (branchWealthCount === 1) score += 3;
            
            // 3. 财星得月令之气 (最高5分)
            if (wealthBranches.includes(monthBranch)) {
                score += 5;
            } else if (isWealthSeasonallyStrong(dayStem, monthBranch)) {
                score += 3;
            }
            
            return Math.min(20, score);
        }

        // 获取正财
        function getZhengCai(dayStem) {
            const zhengCaiMap = {
                '甲': '己', '乙': '戊', '丙': '辛', '丁': '庚',
                '戊': '癸', '己': '壬', '庚': '乙', '辛': '甲',
                '壬': '丁', '癸': '丙'
            };
            return zhengCaiMap[dayStem] || '';
        }
        
        // 获取偏财
        function getPianCai(dayStem) {
            const pianCaiMap = {
                '甲': '戊', '乙': '己', '丙': '庚', '丁': '辛',
                '戊': '壬', '己': '癸', '庚': '甲', '辛': '乙',
                '壬': '丙', '癸': '丁'
            };
            return pianCaiMap[dayStem] || '';
        }
        
        // 获取财星地支
        function getWealthBranches(dayStem) {
            const wealthBranchMap = {
                '甲': ['辰', '戌', '丑', '未'], // 土为财
                '乙': ['辰', '戌', '丑', '未'],
                '丙': ['申', '酉'],             // 金为财
                '丁': ['申', '酉'],
                '戊': ['子', '亥'],             // 水为财
                '己': ['子', '亥'],
                '庚': ['寅', '卯'],             // 木为财
                '辛': ['寅', '卯'],
                '壬': ['午', '巳'],             // 火为财
                '癸': ['午', '巳']
            };
            return wealthBranchMap[dayStem] || [];
        }
        
        // 判断财星是否得季节之气
        function isWealthSeasonallyStrong(dayStem, monthBranch) {
            const seasonMap = {
                '甲': ['辰', '戌', '丑', '未'], // 土旺于四季月
                '乙': ['辰', '戌', '丑', '未'],
                '丙': ['申', '酉'],             // 金旺于秋
                '丁': ['申', '酉'],
                '戊': ['子', '亥'],             // 水旺于冬
                '己': ['子', '亥'],
                '庚': ['寅', '卯'],             // 木旺于春
                '辛': ['寅', '卯'],
                '壬': ['午', '巳'],             // 火旺于夏
                '癸': ['午', '巳']
            };
            return seasonMap[dayStem]?.includes(monthBranch) || false;
        }

        // 计算财富格局 - 基于专业命理格局理论 (40分)
        function calculateWealthPattern(pillars) {
            const dayStr = typeof pillars.day === 'string' ? pillars.day : String(pillars.day);
            const monthStr = typeof pillars.month === 'string' ? pillars.month : String(pillars.month);
            const yearStr = typeof pillars.year === 'string' ? pillars.year : String(pillars.year);
            const hourStr = typeof pillars.hour === 'string' ? pillars.hour : String(pillars.hour);
            
            const dayStem = dayStr.charAt(0);
            const monthBranch = monthStr.charAt(1);
            let score = 0;
            
            // 1. 财气通门户 (月令财星) - 基础50分转换为20分
            const wealthBranches = getWealthBranches(dayStem);
            if (wealthBranches.includes(monthBranch)) {
                score += 20; // 财气通门户，财运根基深厚
            }
            
            // 2. 财星组合评分
            const zhengCai = getZhengCai(dayStem);
            const pianCai = getPianCai(dayStem);
            const allStems = [yearStr.charAt(0), monthStr.charAt(0), hourStr.charAt(0)];
            
            // 财星得食伤生 (每组合+8分，原20分压缩)
            const shiShangStars = getShiShangStars(dayStem);
            let shiShangCount = 0;
            let wealthCount = 0;
            
            allStems.forEach(stem => {
                if (shiShangStars.includes(stem)) shiShangCount++;
                if (stem === zhengCai || stem === pianCai) wealthCount++;
            });
            
            if (shiShangCount > 0 && wealthCount > 0) {
                score += 8; // 食伤生财组合
            }
            
            // 财星合入日主 (甲己合等) - 12分
            const mergePartner = getWealthMergePartner(dayStem);
            if (allStems.includes(mergePartner)) {
                score += 12; // 财星合身，财缘深厚
            }
            
            // 财星被比劫争夺 (每处-6分，原15分压缩)
            const biJieStars = getBiJieStars(dayStem);
            let biJieCount = 0;
            allStems.forEach(stem => {
                if (biJieStars.includes(stem)) biJieCount++;
            });
            
            if (biJieCount > 0 && wealthCount > 0) {
                score -= Math.min(biJieCount * 6, 12); // 比劫夺财，最多扣12分
            }
            
            // 3. 特殊格局判断
            const totalStems = [dayStem, ...allStems];
            const wealthStarRatio = totalStems.filter(stem => stem === zhengCai || stem === pianCai).length / totalStems.length;
            
            // 从财格 (财星占比>50%) - 32分 (原80分压缩)
            if (wealthStarRatio > 0.5) {
                score += 32;
            }
            
            // 财滋杀格 (财生杀有制化) - 16分 (原40分压缩)
            const officialStars = getGuanShaStars(dayStem);
            let hasOfficial = false;
            allStems.forEach(stem => {
                if (officialStars.includes(stem)) hasOfficial = true;
            });
            
            if (hasOfficial && wealthCount > 0) {
                score += 16; // 财滋杀格
            }
            
            // 伤官生财 (无官星混杂) - 24分 (原60分压缩)
            if (shiShangCount > 0 && wealthCount > 0 && !hasOfficial) {
                score += 24; // 伤官生财，清纯有力
            }
            
            return Math.max(0, Math.min(40, score));
        }
        
        // 获取财星合化对象
        function getWealthMergePartner(dayStem) {
            const mergeMap = {
                '甲': '己', '己': '甲', // 甲己合土
                '乙': '庚', '庚': '乙', // 乙庚合金
                '丙': '辛', '辛': '丙', // 丙辛合水
                '丁': '壬', '壬': '丁', // 丁壬合木
                '戊': '癸', '癸': '戊'  // 戊癸合火
            };
            
            const partner = mergeMap[dayStem];
            const zhengCai = getZhengCai(dayStem);
            const pianCai = getPianCai(dayStem);
            
            // 只有当合化对象是财星时才算财星合身
            if (partner === zhengCai || partner === pianCai) {
                return partner;
            }
            return null;
        }
        
        // 计算五行流通性
        function calculateElementFlow(pillars) {
            const elements = {
                '甲': '木', '乙': '木', '寅': '木', '卯': '木',
                '丙': '火', '丁': '火', '午': '火', '巳': '火',
                '戊': '土', '己': '土', '辰': '土', '戌': '土', '丑': '土', '未': '土',
                '庚': '金', '辛': '金', '申': '金', '酉': '金',
                '壬': '水', '癸': '水', '子': '水', '亥': '水'
            };
            
            const allChars = [
                pillars.year.charAt(0), pillars.year.charAt(1),
                pillars.month.charAt(0), pillars.month.charAt(1),
                pillars.day.charAt(0), pillars.day.charAt(1),
                pillars.hour.charAt(0), pillars.hour.charAt(1)
            ];
            
            const elementCount = {};
            allChars.forEach(char => {
                const element = elements[char];
                if (element) {
                    elementCount[element] = (elementCount[element] || 0) + 1;
                }
            });
            
            const presentElements = Object.keys(elementCount);
            let flowScore = 0;
            
            // 五行齐全加分
            if (presentElements.length >= 4) flowScore += 4;
            else if (presentElements.length >= 3) flowScore += 2;
            
            // 相生关系加分
            const shengRelations = [
                ['木', '火'], ['火', '土'], ['土', '金'], ['金', '水'], ['水', '木']
            ];
            
            shengRelations.forEach(([from, to]) => {
                if (elementCount[from] && elementCount[to]) {
                    flowScore += 1;
                }
            });
            
            return flowScore;
        }
        
        // 获取印星
        function getYinStars(dayStem) {
            const yinMap = {
                '甲': ['壬', '癸', '子', '亥'], // 水生木
                '乙': ['壬', '癸', '子', '亥'],
                '丙': ['甲', '乙', '寅', '卯'], // 木生火
                '丁': ['甲', '乙', '寅', '卯'],
                '戊': ['丙', '丁', '午', '巳'], // 火生土
                '己': ['丙', '丁', '午', '巳'],
                '庚': ['戊', '己', '辰', '戌', '丑', '未'], // 土生金
                '辛': ['戊', '己', '辰', '戌', '丑', '未'],
                '壬': ['庚', '辛', '申', '酉'], // 金生水
                '癸': ['庚', '辛', '申', '酉']
            };
            return yinMap[dayStem] || [];
        }
        
        // 获取官星
        function getOfficialStars(dayStem) {
            const officialMap = {
                '甲': ['庚', '辛', '申', '酉'], // 金克木
                '乙': ['庚', '辛', '申', '酉'],
                '丙': ['壬', '癸', '子', '亥'], // 水克火
                '丁': ['壬', '癸', '子', '亥'],
                '戊': ['甲', '乙', '寅', '卯'], // 木克土
                '己': ['甲', '乙', '寅', '卯'],
                '庚': ['丙', '丁', '午', '巳'], // 火克金
                '辛': ['丙', '丁', '午', '巳'],
                '壬': ['戊', '己', '辰', '戌', '丑', '未'], // 土克水
                '癸': ['戊', '己', '辰', '戌', '丑', '未']
            };
            return officialMap[dayStem] || [];
        }
        
        // 计算财星位置分数 - 重新设计版 (25分) - 保留作为备用
        function calculateWealthPositionScore(pillars) {
            const dayStem = pillars.day.charAt(0);
            const dayBranch = pillars.day.charAt(1);
            const monthBranch = pillars.month.charAt(1);
            const hourBranch = pillars.hour.charAt(1);
            const yearBranch = pillars.year.charAt(1);
            
            let score = 5; // 基础分数
            
            // 1. 财星居月令 (最重要位置，8分)
            const wealthBranches = getWealthBranches(dayStem);
            if (wealthBranches.includes(monthBranch)) {
                score += 8;
            }
            
            // 2. 财星居时柱 (财库位置，6分)
            if (wealthBranches.includes(hourBranch)) {
                score += 6;
            }
            
            // 3. 财星居年柱 (祖业财，4分)
            if (wealthBranches.includes(yearBranch)) {
                score += 4;
            }
            
            // 4. 财星居日支 (配偶宫财，3分)
            if (wealthBranches.includes(dayBranch)) {
                score += 3;
            }
            
            return Math.min(20, score);
        }

        // 计算日主承载力 - 基于专业身强身弱理论 (30分)
        function calculateDayMasterCapacity(pillars) {
            const dayStr = typeof pillars.day === 'string' ? pillars.day : String(pillars.day);
            const monthStr = typeof pillars.month === 'string' ? pillars.month : String(pillars.month);
            const yearStr = typeof pillars.year === 'string' ? pillars.year : String(pillars.year);
            const hourStr = typeof pillars.hour === 'string' ? pillars.hour : String(pillars.hour);
            
            const dayStem = dayStr.charAt(0);
            const monthBranch = monthStr.charAt(1);
            
            // 1. 身强判断标准
            let strengthPoints = 0;
            
            // 得令判断 (月令是否帮扶日主)
            if (isDayStemInSeason(dayStem, monthBranch)) {
                strengthPoints += 2; // 得令+2分
            }
            
            // 得地判断 (地支帮扶)
            const supportiveBranches = getSupportiveBranches(dayStem);
            const allBranches = [yearStr.charAt(1), monthBranch, dayStr.charAt(1), hourStr.charAt(1)];
            let supportiveCount = 0;
            
            allBranches.forEach(branch => {
                if (supportiveBranches.includes(branch)) {
                    supportiveCount++;
                }
            });
            
            if (supportiveCount >= 2) {
                strengthPoints += 1; // 得地+1分
            }
            
            // 印比帮扶总数
            const yinStars = getYinStars(dayStem);
            const biJieStars = getBiJieStars(dayStem);
            const allStems = [yearStr.charAt(0), monthStr.charAt(0), hourStr.charAt(0)];
            
            let helpCount = 0;
            allStems.forEach(stem => {
                if (yinStars.includes(stem) || biJieStars.includes(stem)) {
                    helpCount++;
                }
            });
            
            if (helpCount >= 2) {
                strengthPoints += 1; // 印比帮扶+1分
            }
            
            // 2. 承载系数计算
            let yinScore = 0;
            let biJieScore = 0;
            let wealthScore = 0;
            
            // 计算印星总分
            allStems.forEach(stem => {
                if (yinStars.includes(stem)) {
                    yinScore += 1;
                }
            });
            
            // 计算比劫总分
            allStems.forEach(stem => {
                if (biJieStars.includes(stem)) {
                    biJieScore += 1;
                }
            });
            
            // 计算财星总分
            const zhengCai = getZhengCai(dayStem);
            const pianCai = getPianCai(dayStem);
            allStems.forEach(stem => {
                if (stem === zhengCai || stem === pianCai) {
                    wealthScore += 1;
                }
            });
            
            // 承载系数 = (印星总分 + 比劫总分) / 财星总分
            let capacityRatio = 0;
            if (wealthScore > 0) {
                capacityRatio = (yinScore + biJieScore) / wealthScore;
            } else {
                capacityRatio = yinScore + biJieScore; // 无财星时直接用帮扶力量
            }
            
            // 3. 最终承载力评分 - 调整为15分制
            let score = 5; // 基础分
            
            // 身强程度加分
            if (strengthPoints >= 3) {
                score += 8; // 身强
            } else if (strengthPoints >= 2) {
                score += 4; // 身中等
            }
            
            // 承载系数调整
            if (capacityRatio > 1.5) {
                score += 6; // 可担财
            } else if (capacityRatio > 0.8) {
                score += 3; // 正常承载
            } else if (wealthScore > 0) {
                score -= 2; // 不担财时扣分
            }
            
            return Math.max(0, Math.min(15, score)); // 调整上限到15分
        }
        
        // 获取支持日主的地支
        function getSupportiveBranches(dayStem) {
            const branchMap = {
                '甲': ['寅', '卯', '亥', '未'], // 木的根和生扶
                '乙': ['寅', '卯', '亥', '未'],
                '丙': ['巳', '午', '寅', '戌'], // 火的根和生扶
                '丁': ['巳', '午', '寅', '戌'],
                '戊': ['辰', '戌', '丑', '未', '巳', '午'], // 土的根和生扶
                '己': ['辰', '戌', '丑', '未', '巳', '午'],
                '庚': ['申', '酉', '辰', '丑'], // 金的根和生扶
                '辛': ['申', '酉', '辰', '丑'],
                '壬': ['亥', '子', '申', '辰'], // 水的根和生扶
                '癸': ['亥', '子', '申', '辰']
            };
            return branchMap[dayStem] || [];
        }
        
        // 计算大运流年修正 - 优先使用 currentBaziData，考虑格局类型
        function calculateLuckAdjustment(pillars, currentYear) {
            const dayStr = typeof pillars.day === 'string' ? pillars.day : String(pillars.day);
            const dayStem = dayStr.charAt(0);
            
            let adjustment = 0;
            
            // 获取格局类型
            let strengthType = null;
            if (window.currentBaziData && window.currentBaziData.strengthAnalysis) {
                strengthType = window.currentBaziData.strengthAnalysis.type;
            }
            
            // 优先从 currentBaziData 读取当前流年信息（若有）
            let yearStem, yearBranch;
            if (window.currentBaziData) {
                if (window.currentBaziData.currentYearGanZhi && typeof window.currentBaziData.currentYearGanZhi === 'string' && window.currentBaziData.currentYearGanZhi.length >= 2) {
                    const ygz = window.currentBaziData.currentYearGanZhi;
                    yearStem = ygz.charAt(0);
                    yearBranch = ygz.charAt(1);
                }
                // 兼容：从 baziData 返回对象读取
                if ((!yearStem || !yearBranch) && window.currentBaziData.currentYearGanZhi) {
                    const ygz2 = window.currentBaziData.currentYearGanZhi;
                    yearStem = ygz2.charAt(0);
                    yearBranch = ygz2.charAt(1);
                }
            }
            // 退化到本地简化计算
            if (!yearStem || !yearBranch) {
                yearStem = getYearStem(currentYear);
                yearBranch = getYearBranch(currentYear);
            }
            
            // 获取各种十神
            const zhengCai = getZhengCai(dayStem);
            const pianCai = getPianCai(dayStem);
            const shiShangStars = getShiShangStars(dayStem);
            const biJieStars = getBiJieStars(dayStem);
            const wealthBranches = getWealthBranches(dayStem);
            
            // 根据格局类型调整判断逻辑
            if (strengthType === '从强') {
                // 从强格：比劫印星为喜用，财官食伤为忌神
                
                // 1. 比劫流年（从强格喜用）
                if (biJieStars.includes(yearStem)) {
                    adjustment += 12; // 从强格比劫流年，助力财运
                }
                
                // 2. 印星流年（从强格喜用）
                const yinStars = getYinStars(dayStem);
                if (yinStars.includes(yearStem)) {
                    adjustment += 10; // 从强格印星流年，稳固根基
                }
                
                // 3. 财星流年（从强格忌神）
                if (yearStem === zhengCai || yearStem === pianCai) {
                    adjustment -= 10; // 从强格财星流年，财运受阻
                }
                
                // 4. 食伤流年（从强格忌神）
                if (shiShangStars.includes(yearStem)) {
                    adjustment -= 8; // 从强格食伤流年，泄身不利
                }
                
            } else if (strengthType === '从弱') {
                // 从弱格：财官食伤为喜用，比劫印星为忌神
                
                // 1. 财星流年（从弱格喜用）
                if (yearStem === zhengCai || yearStem === pianCai) {
                    adjustment += 15; // 从弱格财星流年，顺势得财
                }
                
                // 2. 食伤流年（从弱格喜用）
                if (shiShangStars.includes(yearStem)) {
                    adjustment += 12; // 从弱格食伤流年，泄身生财
                }
                
                // 3. 比劫流年（从弱格忌神）
                if (biJieStars.includes(yearStem)) {
                    adjustment -= 12; // 从弱格比劫流年，逆势不利
                }
                
                // 4. 印星流年（从弱格忌神）
                const yinStars = getYinStars(dayStem);
                if (yinStars.includes(yearStem)) {
                    adjustment -= 10; // 从弱格印星流年，助身破格
                }
                
            } else {
                // 普通格局：传统判断方式
                
                // 1. 财星流年加成
                if (yearStem === zhengCai || yearStem === pianCai) {
                    adjustment += 15; // 财星流年，财运亨通
                }
                
                // 2. 食伤流年 (生财)
                if (shiShangStars.includes(yearStem)) {
                    adjustment += 10; // 食伤流年，利于生财
                }
                
                // 3. 比劫流年 (夺财)
                if (biJieStars.includes(yearStem)) {
                    adjustment -= 8; // 比劫流年，财运受阻
                }
            }
            
            // 4. 三合财局判断（所有格局通用）
            if (wealthBranches.includes(yearBranch)) {
                if (strengthType === '从强') {
                    adjustment -= 6; // 从强格地支财星不利
                } else {
                    adjustment += 12; // 其他格局地支财星有利
                }
            }
            
            return adjustment;
        }
        
        // 计算大运强弱系数（-10~+10）- 优先使用 currentBaziData 的大运
        function calculateDayunStrength(pillars){
            const dayStr = typeof pillars.day === 'string' ? pillars.day : String(pillars.day);
            const dayStem = dayStr.charAt(0);
            const stagesTable = getTwelveStagesTable();
            const stageMap = {"长生":6, "沐浴":4, "冠带":5, "临官":8, "帝旺":10, "衰":-4, "病":-6, "死":-8, "墓":-9, "绝":-10, "胎":-3, "养":-2};
            
            // 优先从 currentBaziData 缓存中获取当前大运地支，避免重复计算
            let dayunZhi = null;
            if (window.currentBaziData && window.currentBaziData.currentDayun) {
                const currentDayun = window.currentBaziData.currentDayun;
                if (currentDayun && typeof currentDayun.ganZhi === 'string' && currentDayun.ganZhi.length >= 2) {
                    dayunZhi = currentDayun.ganZhi.charAt(1);
                }
            }
            
            // 回退：如果缓存不可用，则调用 getCurrentDayun()
            if (!dayunZhi) {
                try {
                    const currentDayunFallback = getCurrentDayun();
                    if (currentDayunFallback && typeof currentDayunFallback.ganZhi === 'string' && currentDayunFallback.ganZhi.length >= 2) {
                        dayunZhi = currentDayunFallback.ganZhi.charAt(1);
                    }
                } catch (e) {
                    console.warn('获取当前大运失败:', e);
                }
            }
            
            if (!dayunZhi) return 0;
            
            let strength = 0;
            if (stagesTable[dayStem]) {
                const stages = stagesTable[dayStem];
                for (const [stage, zhi] of Object.entries(stages)) {
                    if (zhi === dayunZhi) {
                        strength = stageMap[stage] || 0;
                        break;
                    }
                }
            }
            return strength;
        }
        
        // 获取流年天干 (简化计算)
        function getYearStem(year) {
            const stems = ['庚', '辛', '壬', '癸', '甲', '乙', '丙', '丁', '戊', '己'];
            return stems[year % 10];
        }
        
        // 获取流年地支 (简化计算)
        function getYearBranch(year) {
            const branches = ['申', '酉', '戌', '亥', '子', '丑', '寅', '卯', '辰', '巳', '午', '未'];
            return branches[year % 12];
        }
        
        // 计算季节性财运潜力
        function calculateSeasonalWealthPotential(dayStem, monthBranch) {
            let score = 0;
            
            // 根据日主和月令判断财运的季节性潜力
            const seasonalMap = {
                '甲': { '申': 6, '酉': 8, '戌': 5, '未': 4, '辰': 3 }, // 木日主在金旺季节
                '乙': { '申': 6, '酉': 8, '戌': 5, '未': 4, '辰': 3 },
                '丙': { '子': 6, '亥': 8, '戌': 4, '丑': 5, '辰': 3 }, // 火日主在水旺季节
                '丁': { '子': 6, '亥': 8, '戌': 4, '丑': 5, '辰': 3 },
                '戊': { '寅': 6, '卯': 8, '辰': 4, '未': 3, '戌': 3 }, // 土日主在木旺季节
                '己': { '寅': 6, '卯': 8, '辰': 4, '未': 3, '戌': 3 },
                '庚': { '午': 6, '巳': 8, '未': 5, '戌': 4, '辰': 3 }, // 金日主在火旺季节
                '辛': { '午': 6, '巳': 8, '未': 5, '戌': 4, '辰': 3 },
                '壬': { '辰': 6, '戌': 8, '丑': 5, '未': 5, '午': 4 }, // 水日主在土旺季节
                '癸': { '辰': 6, '戌': 8, '丑': 5, '未': 5, '午': 4 }
            };
            
            if (seasonalMap[dayStem] && seasonalMap[dayStem][monthBranch]) {
                score += seasonalMap[dayStem][monthBranch];
            } else {
                score += 2; // 基础分数
            }
            
            return score;
        }
        
        // 计算财星保护分数 - 100分制版 (20分) - 保留作为备用
        function calculateWealthProtectionScore(pillars) {
            const dayStem = pillars.day.charAt(0);
            let score = 6; // 基础保护分数
            
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            
            // 1. 印星保护财星 (最高8分)
            const yinStars = getYinStars(dayStem);
            let yinCount = 0;
            stems.forEach(stem => {
                if (yinStars.includes(stem)) yinCount++;
            });
            branches.forEach(branch => {
                if (yinStars.includes(branch)) yinCount++;
            });
            
            if (yinCount >= 2) score += 8;
            else if (yinCount === 1) score += 5;
            
            // 2. 食伤适度 (最高6分) - 改为正面评分
            const shiShangStars = getShiShangStars(dayStem);
            let shiShangCount = 0;
            stems.forEach(stem => {
                if (shiShangStars.includes(stem)) shiShangCount++;
            });
            branches.forEach(branch => {
                if (shiShangStars.includes(branch)) shiShangCount++;
            });
            
            if (shiShangCount === 1) score += 6; // 适度食伤有利财运
            else if (shiShangCount === 2) score += 4;
            else if (shiShangCount === 0) score += 3; // 无食伤也可以
            
            // 3. 比劫适度 (最高5分) - 改为正面评分
            const biJieStars = getBiJieStars(dayStem);
            let biJieCount = 0;
            stems.forEach(stem => {
                if (biJieStars.includes(stem)) biJieCount++;
            });
            branches.forEach(branch => {
                if (biJieStars.includes(branch)) biJieCount++;
            });
            
            if (biJieCount === 1) score += 5; // 适度比劫有助合作
            else if (biJieCount === 0) score += 4; // 无比劫也不错
            else if (biJieCount === 2) score += 2;
            
            return Math.min(20, score);
        }
        
        // 专业八字：喜忌平衡分析 (0~10分)
        function calculateFavorableBalance(pillars) {
            const dayElement = getStemElement(pillars.day.charAt(0));
            const dayStrength = calculateSimpleDayStrength(pillars);
            let balance = 0;
            
            // 财星在天干的力度
            let wealthStrength = 0;
            ['year', 'month', 'hour'].forEach(pos => {
                const stem = pillars[pos].charAt(0);
                if (isWealth(dayElement, getStemElement(stem))) {
                    wealthStrength += (pos === 'month') ? 3 : 1;
                }
            });
            
            const ratio = wealthStrength > 0 ? dayStrength / (wealthStrength * 10) : dayStrength / 50;
            if (ratio >= 0.8 && ratio <= 1.5) {
                balance += 6;
            } else if (ratio > 1.5) {
                balance += 4;
            } else {
                balance += 2;
            }
            
            // 用神到位：身弱要印比，身强要食伤
            if (dayStrength < 50) {
                let supportCount = 0;
                ['year', 'month', 'hour'].forEach(pos => {
                    const stem = pillars[pos].charAt(0);
                    const elem = getStemElement(stem);
                    if (elem === dayElement || isYinshou(dayElement, elem)) supportCount++;
                });
                if (supportCount >= 1) balance += 2;
            } else if (dayStrength >= 70) {
                let xsCount = 0;
                ['year', 'month', 'hour'].forEach(pos => {
                    const stem = pillars[pos].charAt(0);
                    if (isShishang(dayElement, getStemElement(stem))) xsCount++;
                });
                if (xsCount >= 1) balance += 2;
            }
            
            return Math.max(0, Math.min(10, Math.round(balance)));
        }
        
        // 专业八字：空亡减分 (按旬空简化，0~15分)
        function calculateKongWangPenalty(pillars) {
            const dayStem = pillars.day.charAt(0);
            const dayBranch = pillars.day.charAt(1);
            const dayGanZhi = dayStem + dayBranch;
            const kongWangBranches = (getKongWangTable()[dayGanZhi]) || [];
            let penalty = 0;
            
            // 财星空亡检查
            const wealthBranches = getWealthBranches(dayStem);
            [pillars.year.charAt(1), pillars.month.charAt(1), pillars.hour.charAt(1)].forEach(branch => {
                if (wealthBranches.includes(branch) && kongWangBranches.includes(branch)) {
                    penalty += 5;
                }
            });
            
            // 财库空亡检查
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            const vaults = ['辰', '戌', '丑', '未'];
            branches.forEach(b => {
                if (vaults.includes(b) && kongWangBranches.includes(b)) penalty += 3;
            });
            
            return Math.max(0, Math.min(15, penalty));
        }
        
        // 旬空表（简化版本）
        function getKongWangTable() {
            return {
                '甲子': ['戌', '亥'], '乙丑': ['戌', '亥'], '丙寅': ['戌', '亥'], '丁卯': ['戌', '亥'], '戊辰': ['戌', '亥'], '己巳': ['戌', '亥'], '庚午': ['戌', '亥'], '辛未': ['戌', '亥'], '壬申': ['戌', '亥'], '癸酉': ['戌', '亥'],
                '甲戌': ['申', '酉'], '乙亥': ['申', '酉'], '丙子': ['申', '酉'], '丁丑': ['申', '酉'], '戊寅': ['申', '酉'], '己卯': ['申', '酉'], '庚辰': ['申', '酉'], '辛巳': ['申', '酉'], '壬午': ['申', '酉'], '癸未': ['申', '酉'],
                '甲申': ['午', '未'], '乙酉': ['午', '未'], '丙戌': ['午', '未'], '丁亥': ['午', '未'], '戊子': ['午', '未'], '己丑': ['午', '未'], '庚寅': ['午', '未'], '辛卯': ['午', '未'], '壬辰': ['午', '未'], '癸巳': ['午', '未'],
                '甲午': ['辰', '巳'], '乙未': ['辰', '巳'], '丙申': ['辰', '巳'], '丁酉': ['辰', '巳'], '戊戌': ['辰', '巳'], '己亥': ['辰', '巳'], '庚子': ['辰', '巳'], '辛丑': ['辰', '巳'], '壬寅': ['辰', '巳'], '癸卯': ['辰', '巳'],
                '甲辰': ['寅', '卯'], '乙巳': ['寅', '卯'], '丙午': ['寅', '卯'], '丁未': ['寅', '卯'], '戊申': ['寅', '卯'], '己酉': ['寅', '卯'], '庚戌': ['寅', '卯'], '辛亥': ['寅', '卯'], '壬子': ['寅', '卯'], '癸丑': ['寅', '卯'],
                '甲寅': ['子', '丑'], '乙卯': ['子', '丑'], '丙辰': ['子', '丑'], '丁巳': ['子', '丑'], '戊午': ['子', '丑'], '己未': ['子', '丑'], '庚申': ['子', '丑'], '辛酉': ['子', '丑'], '壬戌': ['子', '丑'], '癸亥': ['子', '丑']
            };
        }

        // 计算日主强弱分数 (0~10分) - 增强版
        function calculateDayMasterStrengthScore(pillars) {
            const enhancedStrength = calculateEnhancedDayMasterStrength(pillars);
            
            // 根据得令、得地、得势的综合评分转换为0-10分
            if (enhancedStrength.totalScore >= 80) {
                return 10; // 极佳平衡
            } else if (enhancedStrength.totalScore >= 70) {
                return 9; // 很好平衡
            } else if (enhancedStrength.totalScore >= 60) {
                return 8; // 良好平衡
            } else if (enhancedStrength.totalScore >= 50) {
                return 7; // 中等平衡
            } else if (enhancedStrength.totalScore >= 40) {
                return 6; // 稍有偏颇
            } else if (enhancedStrength.totalScore >= 30) {
                return 5; // 明显偏颇
            } else if (enhancedStrength.totalScore >= 20) {
                return 4; // 严重偏颇
            } else {
                return 3; // 极度失衡
            }
        }
        
        // 增强版日主强弱分析 - 融合得令/得地/得势
        function calculateEnhancedDayMasterStrength(pillars) {
            const dayStem = pillars.day.charAt(0);
            const dayBranch = pillars.day.charAt(1);
            
            // 计算得令、得地、得势
            const deLing = calculateDeLing(dayStem, pillars.month.charAt(1));
            const deDi = calculateDeDi(dayStem, dayBranch, pillars);
            const deShi = calculateDeShi(dayStem, pillars);
            
            // 综合评分 (满分100)
            const totalScore = deLing.score + deDi.score + deShi.score;
            
            // 判断强弱类型
            let strengthType = '中和';
            if (totalScore >= 70) {
                strengthType = '身强';
            } else if (totalScore <= 30) {
                strengthType = '身弱';
            }
            
            return {
                deLing,
                deDi,
                deShi,
                totalScore,
                strengthType,
                details: {
                    seasonSupport: deLing.details,
                    earthlySupport: deDi.details,
                    momentumSupport: deShi.details
                }
            };
        }
        
        // 计算得令 - 日主在月令中的旺衰状态
        function calculateDeLing(dayStem, monthBranch) {
            const dayElement = getStemElement(dayStem);
            const monthElement = getBranchElement(monthBranch);
            
            let score = 0;
            let status = '';
            let details = [];
            
            // 月令旺衰表
            const seasonStrengthMap = {
                '木': { '寅': 30, '卯': 35, '辰': 10, '巳': -10, '午': -15, '未': -5, '申': -25, '酉': -30, '戌': -5, '亥': 15, '子': 10, '丑': 5 },
                '火': { '寅': 15, '卯': 10, '辰': 5, '巳': 30, '午': 35, '未': 20, '申': -15, '酉': -20, '戌': 10, '亥': -25, '子': -30, '丑': -10 },
                '土': { '寅': -10, '卯': -15, '辰': 25, '巳': 10, '午': 15, '未': 30, '申': 5, '酉': 0, '戌': 35, '亥': -5, '子': -10, '丑': 25 },
                '金': { '寅': -20, '卯': -25, '辰': 5, '巳': -15, '午': -20, '未': 0, '申': 30, '酉': 35, '戌': 10, '亥': 5, '子': -5, '丑': 15 },
                '水': { '寅': 10, '卯': 5, '辰': -5, '巳': -25, '午': -30, '未': -10, '申': 15, '酉': 10, '戌': -5, '亥': 30, '子': 35, '丑': 5 }
            };
            
            const baseScore = seasonStrengthMap[dayElement]?.[monthBranch] || 0;
            score = Math.max(0, baseScore + 30); // 转换为0-65分范围
            
            if (baseScore >= 25) {
                status = '旺';
                details.push('日主当令而旺');
            } else if (baseScore >= 10) {
                status = '相';
                details.push('日主得令而相');
            } else if (baseScore >= -10) {
                status = '休';
                details.push('日主失令而休');
            } else if (baseScore >= -20) {
                status = '囚';
                details.push('日主失令而囚');
            } else {
                status = '死';
                details.push('日主失令而死');
            }
            
            return { score, status, details };
        }
        
        // 计算得地 - 日主在地支中的根基
        function calculateDeDi(dayStem, dayBranch, pillars) {
            const dayElement = getStemElement(dayStem);
            let score = 0;
            let details = [];
            
            // 日支根基最重要
            const dayBranchSupport = calculateBranchSupport(dayElement, dayBranch);
            score += dayBranchSupport * 1.5; // 日支权重最高
            if (dayBranchSupport > 0) {
                details.push(`日支${dayBranch}为日主根基`);
            }
            
            // 其他地支的支持
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.hour.charAt(1)];
            branches.forEach((branch, index) => {
                const support = calculateBranchSupport(dayElement, branch);
                const weight = index === 1 ? 1.2 : 1.0; // 月支权重稍高
                score += support * weight;
                if (support > 0) {
                    details.push(`${['年', '月', '时'][index]}支${branch}助日主`);
                }
            });
            
            // 地支合化的影响
            const combinations = checkBranchCombinations(pillars);
            combinations.forEach(combo => {
                if (combo.resultElement === dayElement) {
                    score += 5;
                    details.push(`${combo.type}化${combo.resultElement}助日主`);
                } else if (isElementSupporting(combo.resultElement, dayElement)) {
                    score += 3;
                    details.push(`${combo.type}化${combo.resultElement}生日主`);
                } else if (isElementControlling(combo.resultElement, dayElement)) {
                    score -= 3;
                    details.push(`${combo.type}化${combo.resultElement}克日主`);
                }
            });
            
            return { score: Math.max(0, Math.min(25, score)), details };
        }
        
        // 计算得势 - 日主在整体格局中的气势
        function calculateDeShi(dayStem, pillars) {
            const dayElement = getStemElement(dayStem);
            let score = 0;
            let details = [];
            
            // 天干同类帮扶
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            let sameElementCount = 0;
            let supportElementCount = 0;
            
            stems.forEach((stem, index) => {
                const stemElement = getStemElement(stem);
                if (stemElement === dayElement) {
                    sameElementCount++;
                    score += 3;
                    details.push(`${['年', '月', '时'][index]}干${stem}比肩助势`);
                } else if (isElementSupporting(stemElement, dayElement)) {
                    supportElementCount++;
                    score += 2;
                    details.push(`${['年', '月', '时'][index]}干${stem}印星生身`);
                }
            });
            
            // 整体五行分布的势
            const elementCounts = countElementsInPillars(pillars);
            const totalElements = Object.values(elementCounts).reduce((sum, count) => sum + count, 0);
            const dayElementRatio = elementCounts[dayElement] / totalElements;
            
            if (dayElementRatio >= 0.4) {
                score += 5;
                details.push('日主五行占比过高，形成专旺之势');
            } else if (dayElementRatio >= 0.25) {
                score += 3;
                details.push('日主五行占比适中，气势较旺');
            } else if (dayElementRatio <= 0.1) {
                score -= 2;
                details.push('日主五行占比过低，气势不足');
            }
            
            // 生扶链的连续性
            if (sameElementCount >= 2 && supportElementCount >= 1) {
                score += 3;
                details.push('比印相连，气势连贯');
            }
            
            return { score: Math.max(0, Math.min(15, score)), details };
        }
        
        // 计算地支对日主的支持力度
        function calculateBranchSupport(dayElement, branch) {
            // 地支藏干表
            const branchHiddenStems = {
                '子': ['癸'], '丑': ['己', '癸', '辛'], '寅': ['甲', '丙', '戊'], '卯': ['乙'],
                '辰': ['戊', '乙', '癸'], '巳': ['丙', '戊', '庚'], '午': ['丁', '己'], '未': ['己', '丁', '乙'],
                '申': ['庚', '壬', '戊'], '酉': ['辛'], '戌': ['戊', '辛', '丁'], '亥': ['壬', '甲']
            };
            
            const hiddenStems = branchHiddenStems[branch] || [];
            let support = 0;
            
            hiddenStems.forEach((stem, index) => {
                const stemElement = getStemElement(stem);
                const weight = index === 0 ? 1.0 : (index === 1 ? 0.6 : 0.3); // 本气权重最高
                
                if (stemElement === dayElement) {
                    support += 5 * weight; // 同类支持
                } else if (isElementSupporting(stemElement, dayElement)) {
                    support += 3 * weight; // 生扶支持
                }
            });
            
            return support;
        }
        
        // 检查地支合化组合
        function checkBranchCombinations(pillars) {
            const branches = [
                pillars.year.charAt(1),
                pillars.month.charAt(1),
                pillars.day.charAt(1),
                pillars.hour.charAt(1)
            ];
            
            const combinations = [];
            
            // 三合局
            const sanHeMap = {
                '申子辰': '水', '亥卯未': '木', '寅午戌': '火', '巳酉丑': '金'
            };
            
            // 六合
            const liuHeMap = {
                '子丑': '土', '寅亥': '木', '卯戌': '火', '辰酉': '金', '巳申': '水', '午未': '土'
            };
            
            // 检查三合
            Object.entries(sanHeMap).forEach(([pattern, element]) => {
                const chars = pattern.split('');
                if (chars.every(char => branches.includes(char))) {
                    combinations.push({ type: '三合', resultElement: element, pattern });
                }
            });
            
            // 检查六合
            Object.entries(liuHeMap).forEach(([pattern, element]) => {
                const chars = pattern.split('');
                if (chars.every(char => branches.includes(char))) {
                    combinations.push({ type: '六合', resultElement: element, pattern });
                }
            });
            
            return combinations;
        }
        
        // 统计四柱中各五行的数量
        function countElementsInPillars(pillars) {
            const elementCounts = { '木': 0, '火': 0, '土': 0, '金': 0, '水': 0 };
            
            // 统计天干
            const stems = [
                pillars.year.charAt(0),
                pillars.month.charAt(0),
                pillars.day.charAt(0),
                pillars.hour.charAt(0)
            ];
            
            stems.forEach(stem => {
                const element = getStemElement(stem);
                elementCounts[element]++;
            });
            
            // 统计地支（按本气计算）
            const branches = [
                pillars.year.charAt(1),
                pillars.month.charAt(1),
                pillars.day.charAt(1),
                pillars.hour.charAt(1)
            ];
            
            branches.forEach(branch => {
                const element = getBranchElement(branch);
                elementCounts[element]++;
            });
            
            return elementCounts;
        }

        // 计算用神得力分数 (0~12分) - 增强版
        function calculateUsefulGodScore(pillars) {
            const enhancedScore = calculateEnhancedUsefulGodScore(pillars);
            return Math.min(12, Math.max(0, enhancedScore.totalScore));
        }
        
        // 增强版喜用神评分系统
        function calculateEnhancedUsefulGodScore(pillars) {
            const dayStrength = calculateEnhancedDayMasterStrength(pillars);
            const dayStem = pillars.day.charAt(0);
            
            // 确定用神类型
            const usefulGods = determineUsefulGods(dayStrength.strengthType, dayStem, pillars);
            
            let baseScore = 0;
            let powerScore = 0;
            let damageScore = 0;
            let details = [];
            
            // 计算用神基础分数
            baseScore = evaluateUsefulGodPresence(usefulGods, pillars);
            details.push(`用神基础分: ${baseScore}`);
            
            // 计算用神有力程度
            powerScore = evaluateUsefulGodPower(usefulGods, pillars);
            details.push(`用神有力分: ${powerScore}`);
            
            // 计算用神受损程度
            damageScore = evaluateUsefulGodDamage(usefulGods, pillars);
            details.push(`用神受损分: -${damageScore}`);
            
            const totalScore = baseScore + powerScore - damageScore;
            
            return {
                usefulGods,
                baseScore,
                powerScore,
                damageScore,
                totalScore,
                details
            };
        }
        
        // 确定喜用神
        function determineUsefulGods(strengthType, dayStem, pillars) {
            const dayElement = getStemElement(dayStem);
            const monthBranch = pillars.month.charAt(1);
            
            let primaryGods = []; // 用神
            let secondaryGods = []; // 喜神
            let tabooGods = []; // 忌神
            
            switch(strengthType) {
                case '身强':
                    // 身强用食伤泄秀、财星耗身、官杀制身
                    primaryGods = ['食神', '伤官'];
                    secondaryGods = ['正财', '偏财', '正官', '七杀'];
                    tabooGods = ['正印', '偏印', '比肩', '劫财'];
                    break;
                    
                case '身弱':
                    // 身弱用印星生身、比劫帮身
                    primaryGods = ['正印', '偏印'];
                    secondaryGods = ['比肩', '劫财'];
                    tabooGods = ['食神', '伤官', '正财', '偏财', '正官', '七杀'];
                    break;
                    
                case '中和':
                    // 中和重调候，根据季节确定
                    const seasonalGods = getSeasonalUsefulGods(monthBranch, dayElement);
                    primaryGods = seasonalGods.primary;
                    secondaryGods = seasonalGods.secondary;
                    tabooGods = seasonalGods.taboo;
                    break;
                    
                default:
                    // 默认按身弱处理
                    primaryGods = ['正印', '偏印'];
                    secondaryGods = ['比肩', '劫财'];
                    tabooGods = ['食神', '伤官'];
            }
            
            return { primaryGods, secondaryGods, tabooGods };
        }
        
        // 根据季节确定调候用神
        function getSeasonalUsefulGods(monthBranch, dayElement) {
            const seasonMap = {
                // 春季 - 木旺
                '寅': { primary: ['正官', '七杀'], secondary: ['正财', '偏财'], taboo: ['正印', '偏印'] },
                '卯': { primary: ['正官', '七杀'], secondary: ['正财', '偏财'], taboo: ['正印', '偏印'] },
                '辰': { primary: ['食神', '伤官'], secondary: ['正财', '偏财'], taboo: ['比肩', '劫财'] },
                
                // 夏季 - 火旺
                '巳': { primary: ['正印', '偏印'], secondary: ['正官', '七杀'], taboo: ['食神', '伤官'] },
                '午': { primary: ['正印', '偏印'], secondary: ['正官', '七杀'], taboo: ['食神', '伤官'] },
                '未': { primary: ['正官', '七杀'], secondary: ['正印', '偏印'], taboo: ['食神', '伤官'] },
                
                // 秋季 - 金旺
                '申': { primary: ['食神', '伤官'], secondary: ['正财', '偏财'], taboo: ['正官', '七杀'] },
                '酉': { primary: ['食神', '伤官'], secondary: ['正财', '偏财'], taboo: ['正官', '七杀'] },
                '戌': { primary: ['正印', '偏印'], secondary: ['比肩', '劫财'], taboo: ['正财', '偏财'] },
                
                // 冬季 - 水旺
                '亥': { primary: ['食神', '伤官'], secondary: ['正财', '偏财'], taboo: ['正印', '偏印'] },
                '子': { primary: ['食神', '伤官'], secondary: ['正财', '偏财'], taboo: ['正印', '偏印'] },
                '丑': { primary: ['正官', '七杀'], secondary: ['食神', '伤官'], taboo: ['正印', '偏印'] }
            };
            
            return seasonMap[monthBranch] || { primary: ['正印'], secondary: ['比肩'], taboo: ['食神'] };
        }
        
        // 评估用神存在程度
        function evaluateUsefulGodPresence(usefulGods, pillars) {
            const tenGodsCount = countTenGods(pillars);
            let score = 0;
            
            // 用神存在加分
            usefulGods.primaryGods.forEach(god => {
                score += tenGodsCount[god] * 3; // 用神权重最高
            });
            
            usefulGods.secondaryGods.forEach(god => {
                score += tenGodsCount[god] * 2; // 喜神权重中等
            });
            
            return Math.min(6, score);
        }
        
        // 评估用神有力程度
        function evaluateUsefulGodPower(usefulGods, pillars) {
            let score = 0;
            const dayStem = pillars.day.charAt(0);
            
            // 检查用神是否得令（在月令中旺相）
            const monthBranch = pillars.month.charAt(1);
            const monthElement = getBranchElement(monthBranch);
            
            usefulGods.primaryGods.forEach(god => {
                if (isUsefulGodInSeason(god, dayStem, monthBranch)) {
                    score += 2;
                }
            });
            
            // 检查用神是否得地（有根基）
            score += evaluateUsefulGodRoots(usefulGods, pillars);
            
            // 检查用神是否得势（有帮扶）
            score += evaluateUsefulGodMomentum(usefulGods, pillars);
            
            return Math.min(4, score);
        }
        
        // 评估用神受损程度
        function evaluateUsefulGodDamage(usefulGods, pillars) {
            let damage = 0;
            const dayStem = pillars.day.charAt(0);
            
            // 检查用神是否被合化
            damage += checkUsefulGodCombination(usefulGods, pillars);
            
            // 检查用神是否被冲克
            damage += checkUsefulGodConflict(usefulGods, pillars);
            
            // 检查用神是否空亡
            damage += checkUsefulGodVoid(usefulGods, pillars);
            
            // 检查忌神是否过旺
            damage += checkTabooGodOverpower(usefulGods, pillars);
            
            return Math.min(6, damage);
        }
        
        // 检查用神是否得令
        function isUsefulGodInSeason(tenGod, dayStem, monthBranch) {
            const dayElement = getStemElement(dayStem);
            const monthElement = getBranchElement(monthBranch);
            
            // 根据十神类型判断是否得令
            const tenGodElementMap = {
                '食神': getElementByRelation(dayElement, 'produce'),
                '伤官': getElementByRelation(dayElement, 'produce'),
                '正财': getElementByRelation(dayElement, 'control'),
                '偏财': getElementByRelation(dayElement, 'control'),
                '正官': getElementByRelation(dayElement, 'controlled'),
                '七杀': getElementByRelation(dayElement, 'controlled'),
                '正印': getElementByRelation(dayElement, 'support'),
                '偏印': getElementByRelation(dayElement, 'support'),
                '比肩': dayElement,
                '劫财': dayElement
            };
            
            const tenGodElement = tenGodElementMap[tenGod];
            return tenGodElement === monthElement;
        }
        
        // 根据关系获取五行
        function getElementByRelation(element, relation) {
            const elementCycle = ['木', '火', '土', '金', '水'];
            const index = elementCycle.indexOf(element);
            
            switch(relation) {
                case 'produce': // 我生
                    return elementCycle[(index + 1) % 5];
                case 'control': // 我克
                    return elementCycle[(index + 2) % 5];
                case 'controlled': // 克我
                    return elementCycle[(index + 3) % 5];
                case 'support': // 生我
                    return elementCycle[(index + 4) % 5];
                default:
                    return element;
            }
        }
        
        // 评估用神根基
        function evaluateUsefulGodRoots(usefulGods, pillars) {
            let score = 0;
            const dayStem = pillars.day.charAt(0);
            const branches = [
                pillars.year.charAt(1),
                pillars.month.charAt(1),
                pillars.day.charAt(1),
                pillars.hour.charAt(1)
            ];
            
            // 检查地支藏干中是否有用神
            branches.forEach(branch => {
                const hiddenStems = getHiddenStems(branch);
                hiddenStems.forEach(stem => {
                    const tenGod = getTenGod(dayStem, stem);
                    if (usefulGods.primaryGods.includes(tenGod)) {
                        score += 0.5;
                    } else if (usefulGods.secondaryGods.includes(tenGod)) {
                        score += 0.3;
                    }
                });
            });
            
            return Math.min(2, score);
        }
        
        // 评估用神气势
        function evaluateUsefulGodMomentum(usefulGods, pillars) {
            let score = 0;
            const dayStem = pillars.day.charAt(0);
            const stems = [
                pillars.year.charAt(0),
                pillars.month.charAt(0),
                pillars.hour.charAt(0)
            ];
            
            // 检查天干中用神的连续性
            let consecutiveCount = 0;
            stems.forEach(stem => {
                const tenGod = getTenGod(dayStem, stem);
                if (usefulGods.primaryGods.includes(tenGod) || usefulGods.secondaryGods.includes(tenGod)) {
                    consecutiveCount++;
                }
            });
            
            if (consecutiveCount >= 2) {
                score += 1;
            }
            
            return Math.min(1, score);
        }
        
        // 检查用神合化损伤
        function checkUsefulGodCombination(usefulGods, pillars) {
            let damage = 0;
            const dayStem = pillars.day.charAt(0);
            
            // 检查天干合化
            const stemCombinations = [
                ['甲', '己'], ['乙', '庚'], ['丙', '辛'], ['丁', '壬'], ['戊', '癸']
            ];
            
            const stems = [
                pillars.year.charAt(0),
                pillars.month.charAt(0),
                pillars.day.charAt(0),
                pillars.hour.charAt(0)
            ];
            
            stemCombinations.forEach(combo => {
                if (combo.every(stem => stems.includes(stem))) {
                    // 检查被合化的是否为用神
                    combo.forEach(stem => {
                        if (stem !== dayStem) {
                            const tenGod = getTenGod(dayStem, stem);
                            if (usefulGods.primaryGods.includes(tenGod)) {
                                damage += 2;
                            } else if (usefulGods.secondaryGods.includes(tenGod)) {
                                damage += 1;
                            }
                        }
                    });
                }
            });
            
            return damage;
        }
        
        // 检查用神冲克损伤
        function checkUsefulGodConflict(usefulGods, pillars) {
            let damage = 0;
            const dayStem = pillars.day.charAt(0);
            
            // 检查地支相冲
            const branchConflicts = [
                ['子', '午'], ['丑', '未'], ['寅', '申'],
                ['卯', '酉'], ['辰', '戌'], ['巳', '亥']
            ];
            
            const branches = [
                pillars.year.charAt(1),
                pillars.month.charAt(1),
                pillars.day.charAt(1),
                pillars.hour.charAt(1)
            ];
            
            branchConflicts.forEach(conflict => {
                if (conflict.every(branch => branches.includes(branch))) {
                    // 检查冲克是否影响用神
                    conflict.forEach(branch => {
                        const hiddenStems = getHiddenStems(branch);
                        hiddenStems.forEach(stem => {
                            const tenGod = getTenGod(dayStem, stem);
                            if (usefulGods.primaryGods.includes(tenGod)) {
                                damage += 1;
                            }
                        });
                    });
                }
            });
            
            return damage;
        }
        
        // 检查用神空亡
        function checkUsefulGodVoid(usefulGods, pillars) {
            let damage = 0;
            const dayStem = pillars.day.charAt(0);
            
            // 简化的空亡检查
            const dayPillar = pillars.day;
            const voidBranches = getVoidBranches(dayPillar);
            
            const branches = [
                pillars.year.charAt(1),
                pillars.month.charAt(1),
                pillars.hour.charAt(1)
            ];
            
            branches.forEach(branch => {
                if (voidBranches.includes(branch)) {
                    const hiddenStems = getHiddenStems(branch);
                    hiddenStems.forEach(stem => {
                        const tenGod = getTenGod(dayStem, stem);
                        if (usefulGods.primaryGods.includes(tenGod)) {
                            damage += 1;
                        }
                    });
                }
            });
            
            return damage;
        }
        
        // 检查忌神过旺
        function checkTabooGodOverpower(usefulGods, pillars) {
            const tenGodsCount = countTenGods(pillars);
            let damage = 0;
            
            usefulGods.tabooGods.forEach(god => {
                if (tenGodsCount[god] >= 3) {
                    damage += 2; // 忌神过旺
                } else if (tenGodsCount[god] >= 2) {
                    damage += 1; // 忌神较旺
                }
            });
            
            return damage;
        }
        
        // 获取空亡地支
        function getVoidBranches(dayPillar) {
            const voidMap = {
                '甲子': ['戌', '亥'], '乙丑': ['戌', '亥'], '丙寅': ['子', '丑'], '丁卯': ['子', '丑'],
                '戊辰': ['寅', '卯'], '己巳': ['寅', '卯'], '庚午': ['辰', '巳'], '辛未': ['辰', '巳'],
                '壬申': ['午', '未'], '癸酉': ['午', '未'], '甲戌': ['申', '酉'], '乙亥': ['申', '酉']
            };
            
            return voidMap[dayPillar] || [];
        }

        // 增强版地支架构分析函数
        function calculateEnhancedEarthlyBranchScore(pillars) {
            let totalScore = 0;
            const maxScore = 15;
            
            // 1. 地支合化分析 (0-4分)
            const combinationScore = analyzeBranchCombinations(pillars);
            totalScore += combinationScore;
            
            // 2. 地支冲刑害分析 (0-4分)
            const conflictScore = analyzeBranchConflicts(pillars);
            totalScore += conflictScore;
            
            // 3. 地支藏干相互作用 (0-4分)
            const hiddenStemScore = analyzeHiddenStemInteractions(pillars);
            totalScore += hiddenStemScore;
            
            // 4. 空亡影响分析 (0-3分)
            const voidScore = analyzeVoidImpact(pillars);
            totalScore += voidScore;
            
            return Math.min(maxScore, totalScore);
        }
        
        // 分析地支合化关系
        function analyzeBranchCombinations(pillars) {
            let score = 0;
            const branches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
            const dayElement = getStemElement(pillars.day.charAt(0));
            
            // 检查三合局
            const sanHeResult = checkSanHeCombinations(branches, dayElement);
            score += sanHeResult.score;
            
            // 检查六合
            const liuHeResult = checkLiuHeCombinations(branches, dayElement);
            score += liuHeResult.score;
            
            // 检查三会局
            const sanHuiResult = checkSanHuiCombinations(branches, dayElement);
            score += sanHuiResult.score;
            
            return Math.min(4, score);
        }
        
        // 分析地支冲刑害关系
        function analyzeBranchConflicts(pillars) {
            let score = 4; // 基础分，冲刑害会减分
            const branches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
            
            // 相冲检查
            const chongResult = checkBranchClashes(branches);
            score -= chongResult.penalty;
            
            // 相刑检查
            const xingResult = checkBranchPunishments(branches);
            score -= xingResult.penalty;
            
            // 相害检查
            const haiResult = checkBranchHarms(branches);
            score -= haiResult.penalty;
            
            return Math.max(0, score);
        }
        
        // 分析地支藏干相互作用
        function analyzeHiddenStemInteractions(pillars) {
            let score = 0;
            const branches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
            const dayElement = getStemElement(pillars.day.charAt(0));
            
            // 检查藏干生克关系
            const hiddenStemSupport = calculateHiddenStemSupport(branches, dayElement);
            if (hiddenStemSupport >= 3) score += 2;
            else if (hiddenStemSupport >= 1) score += 1;
            
            // 检查藏干透出情况
            const transparentScore = calculateTransparentHiddenStems(pillars);
            score += transparentScore;
            
            return Math.min(4, score);
        }
        
        // 分析空亡影响
        function analyzeVoidImpact(pillars) {
            let score = 3; // 基础分，空亡会减分
            const voidBranches = getVoidBranches(pillars.day);
            const branches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
            
            // 检查重要地支是否空亡
            const monthBranch = pillars.month.slice(1);
            const dayBranch = pillars.day.slice(1);
            
            if (voidBranches.includes(monthBranch)) {
                score -= 1.5; // 月支空亡，影响较大
            }
            
            if (voidBranches.includes(dayBranch)) {
                score -= 1; // 日支空亡，影响中等
            }
            
            // 检查其他地支空亡
            const otherVoidCount = branches.filter(branch => voidBranches.includes(branch)).length;
            if (otherVoidCount > 2) {
                score -= 0.5; // 多个地支空亡
            }
            
            return Math.max(0, score);
         }
         
         // 检查三合局组合
         function checkSanHeCombinations(branches, dayElement) {
             const sanHeGroups = [
                 {branches: ['申', '子', '辰'], element: 'water', name: '申子辰水局'},
                 {branches: ['亥', '卯', '未'], element: 'wood', name: '亥卯未木局'},
                 {branches: ['寅', '午', '戌'], element: 'fire', name: '寅午戌火局'},
                 {branches: ['巳', '酉', '丑'], element: 'metal', name: '巳酉丑金局'}
             ];
             
             let score = 0;
             let foundCombinations = [];
             
             for (const group of sanHeGroups) {
                 const matches = group.branches.filter(branch => branches.includes(branch));
                 if (matches.length >= 2) {
                     const isComplete = matches.length === 3;
                     const isAdjacent = checkBranchAdjacency(matches, branches);
                     
                     if (isAdjacent) {
                         const elementScore = calculateElementBenefit(group.element, dayElement);
                         score += isComplete ? elementScore * 2 : elementScore;
                         foundCombinations.push({
                             type: group.name,
                             element: group.element,
                             complete: isComplete,
                             score: isComplete ? elementScore * 2 : elementScore
                         });
                     }
                 }
             }
             
             return { score: Math.min(2, score), combinations: foundCombinations };
         }
         
         // 检查六合组合
         function checkLiuHeCombinations(branches, dayElement) {
             const liuHePairs = [
                 {pair: ['子', '丑'], element: 'earth', name: '子丑合土'},
                 {pair: ['寅', '亥'], element: 'wood', name: '寅亥合木'},
                 {pair: ['卯', '戌'], element: 'fire', name: '卯戌合火'},
                 {pair: ['辰', '酉'], element: 'metal', name: '辰酉合金'},
                 {pair: ['巳', '申'], element: 'water', name: '巳申合水'},
                 {pair: ['午', '未'], element: 'earth', name: '午未合土'}
             ];
             
             let score = 0;
             let foundCombinations = [];
             
             for (const pair of liuHePairs) {
                 if (branches.includes(pair.pair[0]) && branches.includes(pair.pair[1])) {
                     const isAdjacent = checkBranchAdjacency(pair.pair, branches);
                     if (isAdjacent) {
                         const elementScore = calculateElementBenefit(pair.element, dayElement);
                         score += elementScore * 0.5; // 六合效果比三合弱
                         foundCombinations.push({
                             type: pair.name,
                             element: pair.element,
                             score: elementScore * 0.5
                         });
                     }
                 }
             }
             
             return { score: Math.min(1.5, score), combinations: foundCombinations };
         }
         
         // 检查三会局组合
         function checkSanHuiCombinations(branches, dayElement) {
             const sanHuiGroups = [
                 {branches: ['寅', '卯', '辰'], element: 'wood', name: '寅卯辰东方木'},
                 {branches: ['巳', '午', '未'], element: 'fire', name: '巳午未南方火'},
                 {branches: ['申', '酉', '戌'], element: 'metal', name: '申酉戌西方金'},
                 {branches: ['亥', '子', '丑'], element: 'water', name: '亥子丑北方水'}
             ];
             
             let score = 0;
             let foundCombinations = [];
             
             for (const group of sanHuiGroups) {
                 const matches = group.branches.filter(branch => branches.includes(branch));
                 if (matches.length >= 2) {
                     const isComplete = matches.length === 3;
                     const isAdjacent = checkBranchAdjacency(matches, branches);
                     
                     if (isAdjacent) {
                         const elementScore = calculateElementBenefit(group.element, dayElement);
                         score += isComplete ? elementScore * 1.5 : elementScore * 0.8;
                         foundCombinations.push({
                             type: group.name,
                             element: group.element,
                             complete: isComplete,
                             score: isComplete ? elementScore * 1.5 : elementScore * 0.8
                         });
                     }
                 }
             }
             
             return { score: Math.min(1, score), combinations: foundCombinations };
         }
         
         // 检查地支相冲
         function checkBranchClashes(branches) {
             const chongPairs = [
                 ['子', '午'], ['丑', '未'], ['寅', '申'], ['卯', '酉'],
                 ['辰', '戌'], ['巳', '亥']
             ];
             
             let penalty = 0;
             let foundClashes = [];
             
             for (const pair of chongPairs) {
                 if (branches.includes(pair[0]) && branches.includes(pair[1])) {
                     // 财库逢冲可能是好事
                     if (['辰', '戌', '丑', '未'].some(treasury => pair.includes(treasury))) {
                         penalty += 0.5; // 财库冲开，轻微减分
                     } else {
                         penalty += 1; // 其他相冲，减分较多
                     }
                     foundClashes.push(`${pair[0]}${pair[1]}相冲`);
                 }
             }
             
             return { penalty: Math.min(2, penalty), clashes: foundClashes };
         }
         
         // 检查地支相刑
         function checkBranchPunishments(branches) {
             const xingGroups = [
                 {branches: ['寅', '巳', '申'], name: '寅巳申无恩之刑'},
                 {branches: ['丑', '戌', '未'], name: '丑戌未恃势之刑'},
                 {branches: ['子', '卯'], name: '子卯无礼之刑'},
                 {branches: ['辰', '辰'], name: '辰辰自刑'},
                 {branches: ['午', '午'], name: '午午自刑'},
                 {branches: ['酉', '酉'], name: '酉酉自刑'},
                 {branches: ['亥', '亥'], name: '亥亥自刑'}
             ];
             
             let penalty = 0;
             let foundPunishments = [];
             
             for (const group of xingGroups) {
                 if (group.branches.length === 2 && group.branches[0] === group.branches[1]) {
                     // 自刑检查
                     const count = branches.filter(branch => branch === group.branches[0]).length;
                     if (count >= 2) {
                         penalty += 0.5;
                         foundPunishments.push(group.name);
                     }
                 } else {
                     // 三刑检查
                     const matches = group.branches.filter(branch => branches.includes(branch));
                     if (matches.length >= 2) {
                         penalty += matches.length === 3 ? 1 : 0.5;
                         foundPunishments.push(group.name);
                     }
                 }
             }
             
             return { penalty: Math.min(1.5, penalty), punishments: foundPunishments };
         }
         
         // 检查地支相害
         function checkBranchHarms(branches) {
             const haiPairs = [
                 ['子', '未'], ['丑', '午'], ['寅', '巳'], ['卯', '辰'],
                 ['申', '亥'], ['酉', '戌']
             ];
             
             let penalty = 0;
             let foundHarms = [];
             
             for (const pair of haiPairs) {
                 if (branches.includes(pair[0]) && branches.includes(pair[1])) {
                     penalty += 0.5;
                     foundHarms.push(`${pair[0]}${pair[1]}相害`);
                 }
             }
             
             return { penalty: Math.min(1, penalty), harms: foundHarms };
         }
         
         // 检查地支相邻性
         function checkBranchAdjacency(targetBranches, allBranches) {
             const positions = targetBranches.map(branch => allBranches.indexOf(branch)).filter(pos => pos !== -1);
             if (positions.length < 2) return false;
             
             positions.sort((a, b) => a - b);
             
             // 检查是否相邻
             for (let i = 0; i < positions.length - 1; i++) {
                 if (positions[i + 1] - positions[i] !== 1) {
                     return false;
                 }
             }
             
             return true;
         }
         
         // 计算五行对日主的益处
         function calculateElementBenefit(element, dayElement) {
             const relationships = {
                 'wood': { 'wood': 0.5, 'fire': 1, 'earth': -1, 'metal': -0.5, 'water': 1 },
                 'fire': { 'wood': -1, 'fire': 0.5, 'earth': 1, 'metal': -0.5, 'water': -1 },
                 'earth': { 'wood': -1, 'fire': -0.5, 'earth': 0.5, 'metal': 1, 'water': -1 },
                 'metal': { 'wood': -0.5, 'fire': -1, 'earth': -1, 'metal': 0.5, 'water': 1 },
                 'water': { 'wood': 1, 'fire': -1, 'earth': -0.5, 'metal': -1, 'water': 0.5 }
             };
             
             return relationships[element]?.[dayElement] || 0;
         }
         
         // 计算地支藏干生扶力量
         function calculateHiddenStemSupport(branches, dayElement) {
             const hiddenStems = {
                 '子': ['癸'], '丑': ['己', '癸', '辛'], '寅': ['甲', '丙', '戊'], '卯': ['乙'],
                 '辰': ['戊', '乙', '癸'], '巳': ['丙', '庚', '戊'], '午': ['丁', '己'], '未': ['己', '丁', '乙'],
                 '申': ['庚', '壬', '戊'], '酉': ['辛'], '戌': ['戊', '辛', '丁'], '亥': ['壬', '甲']
             };
             
             let supportCount = 0;
             
             for (const branch of branches) {
                 const stems = hiddenStems[branch] || [];
                 for (const stem of stems) {
                     const stemElement = getStemElement(stem);
                     if (stemElement === dayElement || isElementSupporting(stemElement, dayElement)) {
                         supportCount++;
                     }
                 }
             }
             
             return supportCount;
         }
         
         // 计算藏干透出分数
         function calculateTransparentHiddenStems(pillars) {
             let score = 0;
             const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.day.charAt(0), pillars.hour.charAt(0)];
             const branches = [pillars.year.slice(1), pillars.month.slice(1), pillars.day.slice(1), pillars.hour.slice(1)];
             
             const hiddenStems = {
                 '子': ['癸'], '丑': ['己', '癸', '辛'], '寅': ['甲', '丙', '戊'], '卯': ['乙'],
                 '辰': ['戊', '乙', '癸'], '巳': ['丙', '庚', '戊'], '午': ['丁', '己'], '未': ['己', '丁', '乙'],
                 '申': ['庚', '壬', '戊'], '酉': ['辛'], '戌': ['戊', '辛', '丁'], '亥': ['壬', '甲']
             };
             
             for (const branch of branches) {
                 const branchHiddenStems = hiddenStems[branch] || [];
                 for (const hiddenStem of branchHiddenStems) {
                     if (stems.includes(hiddenStem)) {
                         score += 0.5; // 藏干透出，增加分数
                     }
                 }
             }
             
             return Math.min(2, score);
         }
         
         // 判断五行是否生扶
         function isElementSupporting(sourceElement, targetElement) {
             const supportRelations = {
                 'wood': 'fire',
                 'fire': 'earth',
                 'earth': 'metal',
                 'metal': 'water',
                 'water': 'wood'
             };
             
             return supportRelations[sourceElement] === targetElement || sourceElement === targetElement;
         }
 
         // 计算忌神制约分数 (0~8分)
        function calculateTabooGodControlScore(pillars) {
            const dayElement = getStemElement(pillars.day.charAt(0));
            const dayStrength = calculateSimpleDayStrength(pillars);
            let score = 0;
            
            if (dayStrength > 70) {
                // 身强时，制约比劫、印星
                if (hasKillControl(pillars)) score += 3;
                if (hasInjuringOfficer(pillars)) score += 2;
            } else if (dayStrength < 30) {
                // 身弱时，制约财星、食伤
                if (hasWealthRobbery(pillars)) score += 3;
                if (hasOwlSnatching(pillars)) score += 2;
            } else {
                // 中和时，制约突出的忌神
                const tenGodsCount = countTenGods(pillars);
                const maxCount = Math.max(...Object.values(tenGodsCount));
                if (maxCount <= 2) score += 3; // 无明显忌神
            }
            
            return Math.min(8, score);
        }

        // 计算流年助力分数 (0~10分)
        function calculateLuckSupportScore(pillars) {
            try {
                // 使用已有的流年调整函数
                const currentYear = new Date().getFullYear();
                const adjustment = calculateLuckAdjustment(pillars, currentYear);
                
                // 将调整值转换为0-10分
                if (adjustment >= 15) return 10;
                else if (adjustment >= 10) return 8;
                else if (adjustment >= 5) return 6;
                else if (adjustment >= 0) return 4;
                else if (adjustment >= -5) return 2;
                else return 0;
            } catch (e) {
                return 5; // 默认中等分数
            }
        }

        // 计算大运配合分数 (0~8分)
        function calculateDayunCoordinationScore(pillars) {
            try {
                const dayunStrength = calculateDayunStrength(pillars);
                const dayStrength = calculateSimpleDayStrength(pillars);
                
                // 身强喜泄耗，身弱喜生助
                if (dayStrength > 60 && dayunStrength < 0) return 8; // 身强遇弱运
                else if (dayStrength < 40 && dayunStrength > 0) return 8; // 身弱遇强运
                else if (dayStrength >= 40 && dayStrength <= 60) return 6; // 中和配任何运
                else return 3; // 配合一般
            } catch (e) {
                return 4; // 默认分数
            }
        }

        // 增强大运分析系统
        function calculateEnhancedDayunAnalysis(pillars) {
            try {
                const analysis = {
                    currentDayunQuality: calculateCurrentDayunQuality(pillars),
                    firstFiveDayunQuality: calculateFirstFiveDayunQuality(pillars),
                    dayunLifeCycleAnalysis: analyzeDayunLifeCycle(pillars),
                    criticalDayunPeriods: identifyCriticalDayunPeriods(pillars),
                    overallScore: 0
                };
                
                // 添加新的分析维度
                const currentDayun = getCurrentDayun();
                if (currentDayun && currentDayun.ganZhi !== '未知') {
                    // 大运内部配合分析
                    analysis.internalHarmony = calculateDayunInternalHarmony(
                        currentDayun.ganZhi.charAt(0), 
                        currentDayun.ganZhi.charAt(1)
                    );
                    
                    // 大运与命局互动分析
                    analysis.commandInteraction = calculateDayunCommandInteraction(
                        currentDayun.ganZhi, 
                        pillars
                    );
                    
                    // 大运五行平衡贡献
                    analysis.elementBalance = evaluateDayunElementBalance(
                        currentDayun.ganZhi, 
                        pillars
                    );
                    
                    // 大运十神影响
                    analysis.tenGodsImpact = calculateDayunTenGodsImpact(
                        currentDayun.ganZhi, 
                        pillars
                    );
                    
                    // 转换期影响分析
                    const currentAge = new Date().getFullYear() - (window.currentBaziData?.birthYear || 2000) + 1;
                    const dayunList = calculateDayunSequence(
                        window.eightChar?.getMonth() || '甲子',
                        window.currentBaziData?.luckTiming?.direction === '顺排',
                        window.currentBaziData?.luckTiming?.age || 8
                    );
                    analysis.transitionPeriod = analyzeDayunTransitionPeriod(currentAge, dayunList);
                }
                
                // 计算增强的综合评分 (0-10分)
                let totalScore = 0;
                let weights = {
                    currentQuality: 0.25,
                    firstFiveQuality: 0.3,
                    lifeCycleBalance: 0.2,
                    criticalPeriods: 0.1,
                    internalHarmony: 0.05,
                    commandInteraction: 0.05,
                    elementBalance: 0.03,
                    tenGodsImpact: 0.02
                };
                
                totalScore += analysis.currentDayunQuality.score * weights.currentQuality;
                totalScore += analysis.firstFiveDayunQuality.averageScore * weights.firstFiveQuality;
                totalScore += analysis.dayunLifeCycleAnalysis.balanceScore * weights.lifeCycleBalance;
                totalScore += (analysis.criticalDayunPeriods.managementScore || 0.5) * weights.criticalPeriods;
                
                if (analysis.internalHarmony !== undefined) {
                    totalScore += analysis.internalHarmony * weights.internalHarmony;
                    totalScore += analysis.commandInteraction * weights.commandInteraction;
                    totalScore += analysis.elementBalance * weights.elementBalance;
                    totalScore += analysis.tenGodsImpact * weights.tenGodsImpact;
                }
                
                analysis.overallScore = Math.round(totalScore * 10) / 10;
                
                return analysis;
            } catch (e) {
                console.error('增强大运分析失败:', e);
                return {
                    currentDayunQuality: { score: 0.5, description: '分析失败' },
                    firstFiveDayunQuality: { averageScore: 0.5, description: '分析失败' },
                    dayunLifeCycleAnalysis: { balanceScore: 0.5, description: '分析失败' },
                    criticalDayunPeriods: { managementScore: 0.5, description: '分析失败' },
                    overallScore: 5.0
                };
            }
        }

        // 计算当前大运质量 (0-1分)
        function calculateCurrentDayunQuality(pillars) {
            try {
                const currentDayun = getCurrentDayun();
                if (!currentDayun || currentDayun.ganZhi === '未知' || currentDayun.ganZhi === '计算错误') {
                    return { score: 0.5, description: '无法获取当前大运信息' };
                }
                
                const dayunStem = currentDayun.ganZhi.charAt(0);
                const dayunBranch = currentDayun.ganZhi.charAt(1);
                const dayStem = pillars.day.charAt(0);
                
                let qualityScore = 0.5; // 基础分
                let factors = [];
                
                // 1. 大运与日主的十二长生关系 (0.3权重)
                const stagesTable = getTwelveStagesTable();
                const stageMap = {
                    "长生": 0.9, "沐浴": 0.4, "冠带": 0.6, "临官": 0.95, "帝旺": 1.0,
                    "衰": 0.3, "病": 0.2, "死": 0.1, "墓": 0.15, "绝": 0.05, "胎": 0.35, "养": 0.4
                };
                
                if (stagesTable[dayStem]) {
                    const stages = stagesTable[dayStem];
                    for (const [stage, zhi] of Object.entries(stages)) {
                        if (zhi === dayunBranch) {
                            const stageScore = stageMap[stage] || 0.5;
                            qualityScore += (stageScore - 0.5) * 0.3;
                            factors.push(`十二长生${stage}(${(stageScore * 100).toFixed(0)}%)`);
                            break;
                        }
                    }
                }
                
                // 2. 大运与用神忌神关系 (0.4权重)
                const dayStrength = calculateSimpleDayStrength(pillars);
                const dayunStemElement = getStemElement(dayunStem);
                const dayunBranchElement = getBranchElement(dayunBranch);
                const dayStemElement = getStemElement(dayStem);
                
                let usefulGodScore = 0;
                if (dayStrength > 60) { // 身强喜泄耗
                    if (isElementWeakening(dayunStemElement, dayStemElement)) usefulGodScore += 0.2;
                    if (isElementWeakening(dayunBranchElement, dayStemElement)) usefulGodScore += 0.2;
                } else if (dayStrength < 40) { // 身弱喜生助
                    if (isElementSupporting(dayunStemElement, dayStemElement)) usefulGodScore += 0.2;
                    if (isElementSupporting(dayunBranchElement, dayStemElement)) usefulGodScore += 0.2;
                } else { // 中和
                    usefulGodScore = 0.2; // 中性评分
                }
                qualityScore += usefulGodScore;
                factors.push(`用神配合(${(usefulGodScore * 250).toFixed(0)}%)`);
                
                // 3. 大运内部干支配合 (0.2权重)
                const internalHarmony = calculateDayunInternalHarmony(dayunStem, dayunBranch);
                qualityScore += internalHarmony * 0.2;
                factors.push(`干支配合(${(internalHarmony * 100).toFixed(0)}%)`);
                
                // 4. 大运与命局合冲关系 (0.1权重)
                const interactionScore = calculateDayunCommandInteraction(currentDayun.ganZhi, pillars);
                qualityScore += interactionScore * 0.1;
                factors.push(`命局互动(${(interactionScore * 100).toFixed(0)}%)`);
                
                // 确保分数在0-1范围内
                qualityScore = Math.max(0, Math.min(1, qualityScore));
                
                const description = `当前大运${currentDayun.ganZhi}(${currentDayun.startAge}-${currentDayun.endAge}岁): ${factors.join(', ')}`;
                
                return { score: qualityScore, description, factors };
            } catch (e) {
                console.error('计算当前大运质量失败:', e);
                return { score: 0.5, description: '计算失败' };
            }
        }

        // 计算前五步大运质量 (0-1分)
        function calculateFirstFiveDayunQuality(pillars) {
            try {
                const luckTiming = window.currentBaziData?.luckTiming;
                if (!luckTiming) {
                    return { averageScore: 0.5, description: '无法获取起运信息' };
                }
                
                const monthGanZhi = window.eightChar?.getMonth();
                if (!monthGanZhi) {
                    return { averageScore: 0.5, description: '无法获取月柱信息' };
                }
                
                const isForward = luckTiming.direction === '顺排';
                const startAge = luckTiming.age;
                const dayunList = calculateDayunSequence(monthGanZhi, isForward, startAge);
                
                if (dayunList.length < 5) {
                    return { averageScore: 0.5, description: '大运数据不足' };
                }
                
                const firstFiveDayun = dayunList.slice(0, 5);
                let totalScore = 0;
                const dayunAnalysis = [];
                
                firstFiveDayun.forEach((dayun, index) => {
                    const quality = analyzeSingleDayunQuality(dayun.ganZhi, pillars);
                    totalScore += quality.score;
                    dayunAnalysis.push({
                        step: index + 1,
                        ganZhi: dayun.ganZhi,
                        ageRange: `${dayun.startAge}-${dayun.endAge}岁`,
                        score: quality.score,
                        description: quality.description
                    });
                });
                
                const averageScore = totalScore / 5;
                const description = `前五步大运平均质量: ${(averageScore * 100).toFixed(1)}%`;
                
                return {
                    averageScore,
                    description,
                    dayunAnalysis,
                    bestDayun: dayunAnalysis.reduce((best, current) => 
                        current.score > best.score ? current : best
                    ),
                    worstDayun: dayunAnalysis.reduce((worst, current) => 
                        current.score < worst.score ? current : worst
                    )
                };
            } catch (e) {
                console.error('计算前五步大运质量失败:', e);
                return { averageScore: 0.5, description: '计算失败' };
            }
        }

        // 分析单个大运质量
        function analyzeSingleDayunQuality(dayunGanZhi, pillars) {
            const dayunStem = dayunGanZhi.charAt(0);
            const dayunBranch = dayunGanZhi.charAt(1);
            const dayStem = pillars.day.charAt(0);
            
            let score = 0.5;
            let factors = [];
            
            // 十二长生关系
            const stagesTable = getTwelveStagesTable();
            const stageMap = {
                "长生": 0.9, "沐浴": 0.4, "冠带": 0.6, "临官": 0.95, "帝旺": 1.0,
                "衰": 0.3, "病": 0.2, "死": 0.1, "墓": 0.15, "绝": 0.05, "胎": 0.35, "养": 0.4
            };
            
            if (stagesTable[dayStem]) {
                const stages = stagesTable[dayStem];
                for (const [stage, zhi] of Object.entries(stages)) {
                    if (zhi === dayunBranch) {
                        score = stageMap[stage] || 0.5;
                        factors.push(stage);
                        break;
                    }
                }
            }
            
            // 用神忌神关系
            const dayStrength = calculateSimpleDayStrength(pillars);
            const dayunStemElement = getStemElement(dayunStem);
            const dayunBranchElement = getBranchElement(dayunBranch);
            const dayStemElement = getStemElement(dayStem);
            
            if (dayStrength > 60) { // 身强
                if (isElementWeakening(dayunStemElement, dayStemElement) || 
                    isElementWeakening(dayunBranchElement, dayStemElement)) {
                    factors.push('用神运');
                } else {
                    factors.push('忌神运');
                    score *= 0.7;
                }
            } else if (dayStrength < 40) { // 身弱
                if (isElementSupporting(dayunStemElement, dayStemElement) || 
                    isElementSupporting(dayunBranchElement, dayStemElement)) {
                    factors.push('用神运');
                } else {
                    factors.push('忌神运');
                    score *= 0.7;
                }
            }
            
            return {
                score: Math.max(0, Math.min(1, score)),
                description: factors.join(', ') || '平运'
            };
        }

        // 分析大运生命周期
        function analyzeDayunLifeCycle(pillars) {
            try {
                const luckTiming = window.currentBaziData?.luckTiming;
                if (!luckTiming) {
                    return { balanceScore: 0.5, description: '无法获取起运信息' };
                }
                
                const monthGanZhi = window.eightChar?.getMonth();
                if (!monthGanZhi) {
                    return { balanceScore: 0.5, description: '无法获取月柱信息' };
                }
                
                const isForward = luckTiming.direction === '顺排';
                const startAge = luckTiming.age;
                const dayunList = calculateDayunSequence(monthGanZhi, isForward, startAge);
                
                // 分析不同人生阶段的大运质量
                const lifePeriods = {
                    youth: { start: 0, end: 25, dayuns: [], avgScore: 0 },      // 青年期
                    prime: { start: 25, end: 45, dayuns: [], avgScore: 0 },     // 壮年期
                    middle: { start: 45, end: 65, dayuns: [], avgScore: 0 },    // 中年期
                    senior: { start: 65, end: 85, dayuns: [], avgScore: 0 }     // 老年期
                };
                
                dayunList.forEach(dayun => {
                    const quality = analyzeSingleDayunQuality(dayun.ganZhi, pillars);
                    
                    Object.keys(lifePeriods).forEach(period => {
                        const periodData = lifePeriods[period];
                        if (dayun.startAge < periodData.end && dayun.endAge > periodData.start) {
                            periodData.dayuns.push({
                                ganZhi: dayun.ganZhi,
                                ageRange: `${dayun.startAge}-${dayun.endAge}岁`,
                                score: quality.score,
                                description: quality.description
                            });
                        }
                    });
                });
                
                // 计算各阶段平均分
                Object.keys(lifePeriods).forEach(period => {
                    const periodData = lifePeriods[period];
                    if (periodData.dayuns.length > 0) {
                        periodData.avgScore = periodData.dayuns.reduce((sum, d) => sum + d.score, 0) / periodData.dayuns.length;
                    }
                });
                
                // 计算生命周期平衡度
                const scores = Object.values(lifePeriods).map(p => p.avgScore).filter(s => s > 0);
                const avgScore = scores.reduce((sum, s) => sum + s, 0) / scores.length;
                const variance = scores.reduce((sum, s) => sum + Math.pow(s - avgScore, 2), 0) / scores.length;
                const balanceScore = Math.max(0, 1 - variance); // 方差越小，平衡度越高
                
                return {
                    balanceScore,
                    lifePeriods,
                    description: `人生各阶段大运平衡度: ${(balanceScore * 100).toFixed(1)}%`,
                    bestPeriod: Object.keys(lifePeriods).reduce((best, current) => 
                        lifePeriods[current].avgScore > lifePeriods[best].avgScore ? current : best
                    ),
                    worstPeriod: Object.keys(lifePeriods).reduce((worst, current) => 
                        lifePeriods[current].avgScore < lifePeriods[worst].avgScore ? current : worst
                    )
                };
            } catch (e) {
                console.error('分析大运生命周期失败:', e);
                return { balanceScore: 0.5, description: '分析失败' };
            }
        }

        // 识别关键大运期
        function identifyCriticalDayunPeriods(pillars) {
            try {
                const luckTiming = window.currentBaziData?.luckTiming;
                if (!luckTiming) {
                    return { managementScore: 0.5, description: '无法获取起运信息' };
                }
                
                const monthGanZhi = window.eightChar?.getMonth();
                if (!monthGanZhi) {
                    return { managementScore: 0.5, description: '无法获取月柱信息' };
                }
                
                const isForward = luckTiming.direction === '顺排';
                const startAge = luckTiming.age;
                const dayunList = calculateDayunSequence(monthGanZhi, isForward, startAge);
                
                const criticalPeriods = [];
                const transitionPeriods = [];
                
                // 识别关键期：极好或极差的大运
                dayunList.forEach((dayun, index) => {
                    const quality = analyzeSingleDayunQuality(dayun.ganZhi, pillars);
                    
                    if (quality.score >= 0.8) {
                        criticalPeriods.push({
                            type: '黄金期',
                            ganZhi: dayun.ganZhi,
                            ageRange: `${dayun.startAge}-${dayun.endAge}岁`,
                            score: quality.score,
                            description: `极佳大运，${quality.description}`
                        });
                    } else if (quality.score <= 0.3) {
                        criticalPeriods.push({
                            type: '困难期',
                            ganZhi: dayun.ganZhi,
                            ageRange: `${dayun.startAge}-${dayun.endAge}岁`,
                            score: quality.score,
                            description: `困难大运，${quality.description}`
                        });
                    }
                    
                    // 识别大运交接期（相邻大运质量差异大）
                    if (index > 0) {
                        const prevQuality = analyzeSingleDayunQuality(dayunList[index - 1].ganZhi, pillars);
                        const qualityDiff = Math.abs(quality.score - prevQuality.score);
                        
                        if (qualityDiff >= 0.4) {
                            transitionPeriods.push({
                                fromDayun: dayunList[index - 1].ganZhi,
                                toDayun: dayun.ganZhi,
                                transitionAge: dayun.startAge,
                                qualityChange: quality.score - prevQuality.score,
                                description: quality.score > prevQuality.score ? '运势上升转折' : '运势下降转折'
                            });
                        }
                    }
                });
                
                // 计算关键期管理分数
                const totalCritical = criticalPeriods.length;
                const goodPeriods = criticalPeriods.filter(p => p.type === '黄金期').length;
                const badPeriods = criticalPeriods.filter(p => p.type === '困难期').length;
                
                let managementScore = 0.5;
                if (totalCritical > 0) {
                    managementScore = (goodPeriods - badPeriods * 0.5) / Math.max(1, totalCritical) + 0.5;
                }
                managementScore = Math.max(0, Math.min(1, managementScore));
                
                return {
                    managementScore,
                    criticalPeriods,
                    transitionPeriods,
                    description: `关键期管理: ${criticalPeriods.length}个关键期，${transitionPeriods.length}个转折点`
                };
            } catch (e) {
                console.error('识别关键大运期失败:', e);
                return { managementScore: 0.5, description: '分析失败' };
            }
        }

        // 计算贵人助力分数 (0~6分)
        function calculateNoblesSupportScore(pillars) {
            const dayStem = pillars.day.charAt(0);
            const dayBranch = pillars.day.charAt(1);
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            let score = 0;
            
            // 天乙贵人
            const tianYiNobles = getTianYiNoble(dayStem);
            if (branches.some(branch => tianYiNobles.includes(branch))) score += 2;
            
            // 文昌贵人
            const wenChangNoble = getWenChangNoble(dayStem);
            if (branches.includes(wenChangNoble)) score += 1.5;
            
            // 天德贵人
            const tianDeNoble = getTianDeNoble(pillars.month.charAt(1));
            if ([pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)].includes(tianDeNoble)) score += 1.5;
            
            // 月德贵人
            const yueDeNoble = getYueDeNoble(pillars.month.charAt(1));
            if ([pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)].includes(yueDeNoble)) score += 1;
            
            return Math.min(6, score);
        }

        // 计算大运内部干支配合度 (0-1分)
        function calculateDayunInternalHarmony(dayunStem, dayunBranch) {
            try {
                const stemElement = getStemElement(dayunStem);
                const branchElement = getBranchElement(dayunBranch);
                
                // 检查干支五行关系
                if (stemElement === branchElement) {
                    return 1.0; // 干支同五行，最佳配合
                }
                
                // 检查生克关系
                if (isElementSupporting(branchElement, stemElement)) {
                    return 0.8; // 地支生天干，良好配合
                }
                
                if (isElementSupporting(stemElement, branchElement)) {
                    return 0.7; // 天干生地支，较好配合
                }
                
                if (isElementWeakening(stemElement, branchElement) || 
                    isElementWeakening(branchElement, stemElement)) {
                    return 0.3; // 相克关系，配合较差
                }
                
                return 0.5; // 中性关系
            } catch (e) {
                return 0.5;
            }
        }

        // 计算大运与命局互动分数 (0-1分)
        function calculateDayunCommandInteraction(dayunGanZhi, pillars) {
            try {
                const dayunStem = dayunGanZhi.charAt(0);
                const dayunBranch = dayunGanZhi.charAt(1);
                
                let interactionScore = 0.5;
                let positiveInteractions = 0;
                let negativeInteractions = 0;
                
                // 检查与四柱的天干合化
                const allStems = [pillars.year.charAt(0), pillars.month.charAt(0), 
                                pillars.day.charAt(0), pillars.hour.charAt(0)];
                
                allStems.forEach(stem => {
                    if (checkTianGanHeHua(dayunStem, stem)) {
                        positiveInteractions += 1;
                    }
                });
                
                // 检查与四柱的地支关系
                const allBranches = [pillars.year.charAt(1), pillars.month.charAt(1), 
                                   pillars.day.charAt(1), pillars.hour.charAt(1)];
                
                allBranches.forEach(branch => {
                    // 检查六合
                    if (checkDiZhiLiuHe(dayunBranch, branch)) {
                        positiveInteractions += 1;
                    }
                    
                    // 检查三合（简化检查）
                    if (checkDiZhiSanHeSimple(dayunBranch, branch)) {
                        positiveInteractions += 0.5;
                    }
                    
                    // 检查相冲
                    if (checkDiZhiChong(dayunBranch, branch)) {
                        negativeInteractions += 1;
                    }
                    
                    // 检查相刑
                    if (checkDiZhiXing(dayunBranch, branch)) {
                        negativeInteractions += 0.5;
                    }
                    
                    // 检查相害
                    if (checkDiZhiHai(dayunBranch, branch)) {
                        negativeInteractions += 0.3;
                    }
                });
                
                // 计算最终互动分数
                const netInteraction = positiveInteractions - negativeInteractions;
                interactionScore = 0.5 + (netInteraction * 0.1);
                
                return Math.max(0, Math.min(1, interactionScore));
            } catch (e) {
                return 0.5;
            }
        }

        // 获取天干对应五行
        function getStemElement(stem) {
            const stemElementMap = {
                '甲': '木', '乙': '木', '丙': '火', '丁': '火', '戊': '土',
                '己': '土', '庚': '金', '辛': '金', '壬': '水', '癸': '水'
            };
            return stemElementMap[stem] || '未知';
        }

        // 获取地支对应五行
        function getBranchElement(branch) {
            const branchElementMap = {
                '子': '水', '丑': '土', '寅': '木', '卯': '木', '辰': '土', '巳': '火',
                '午': '火', '未': '土', '申': '金', '酉': '金', '戌': '土', '亥': '水'
            };
            return branchElementMap[branch] || '未知';
        }

        // 检查天干合化（简化版）
        function checkTianGanHeHua(stem1, stem2) {
            const hehuaPairs = {
                '甲己': '土', '乙庚': '金', '丙辛': '水', '丁壬': '木', '戊癸': '火'
            };
            const pair1 = stem1 + stem2;
            const pair2 = stem2 + stem1;
            return hehuaPairs[pair1] || hehuaPairs[pair2];
        }

        // 检查地支六合（简化版）
        function checkDiZhiLiuHe(branch1, branch2) {
            const liuHePairs = {
                '子丑': '土', '寅亥': '木', '卯戌': '火', '辰酉': '金', '巳申': '水', '午未': '土'
            };
            const pair1 = branch1 + branch2;
            const pair2 = branch2 + branch1;
            return liuHePairs[pair1] || liuHePairs[pair2];
        }

        // 检查地支三合（简化版）
        function checkDiZhiSanHeSimple(branch1, branch2) {
            const sanHeGroups = [
                ['申', '子', '辰'], // 水局
                ['亥', '卯', '未'], // 木局
                ['寅', '午', '戌'], // 火局
                ['巳', '酉', '丑']  // 金局
            ];
            
            return sanHeGroups.some(group => 
                group.includes(branch1) && group.includes(branch2)
            );
        }

        // 检查地支相冲
        function checkDiZhiChong(branch1, branch2) {
            const chongPairs = {
                '子午': true, '丑未': true, '寅申': true, '卯酉': true, '辰戌': true, '巳亥': true
            };
            const pair1 = branch1 + branch2;
            const pair2 = branch2 + branch1;
            return chongPairs[pair1] || chongPairs[pair2];
        }

        // 检查地支相刑
        function checkDiZhiXing(branch1, branch2) {
            const xingGroups = [
                ['寅', '巳', '申'], // 无恩之刑
                ['丑', '戌', '未'], // 恃势之刑
                ['子', '卯']       // 无礼之刑
            ];
            
            return xingGroups.some(group => 
                group.includes(branch1) && group.includes(branch2) && branch1 !== branch2
            );
        }

        // 检查地支相害
        function checkDiZhiHai(branch1, branch2) {
            const haiPairs = {
                '子未': true, '丑午': true, '寅巳': true, '卯辰': true, '申亥': true, '酉戌': true
            };
            const pair1 = branch1 + branch2;
            const pair2 = branch2 + branch1;
            return haiPairs[pair1] || haiPairs[pair2];
        }

        // 分析大运转换期影响 (0-1分)
        function analyzeDayunTransitionPeriod(currentAge, dayunList) {
            try {
                let transitionScore = 1.0;
                
                // 查找当前大运在列表中的位置
                let currentDayunIndex = -1;
                for (let i = 0; i < dayunList.length; i++) {
                    const dayun = dayunList[i];
                    if (currentAge >= dayun.startAge && currentAge < dayun.startAge + 10) {
                        currentDayunIndex = i;
                        break;
                    }
                }
                
                if (currentDayunIndex === -1) return 1.0;
                
                const currentDayun = dayunList[currentDayunIndex];
                const ageInDayun = currentAge - currentDayun.startAge;
                
                // 检查是否在大运转换期（前后各1年）
                if (ageInDayun <= 1) {
                    // 大运初期，检查与上一个大运的差异
                    if (currentDayunIndex > 0) {
                        const prevDayun = dayunList[currentDayunIndex - 1];
                        const qualityDiff = Math.abs(
                            analyzeSingleDayunQuality(currentDayun.ganZhi) - 
                            analyzeSingleDayunQuality(prevDayun.ganZhi)
                        );
                        
                        // 质量差异越大，转换期影响越大
                        transitionScore = Math.max(0.3, 1.0 - qualityDiff * 0.5);
                    }
                } else if (ageInDayun >= 8) {
                    // 大运末期，检查与下一个大运的差异
                    if (currentDayunIndex < dayunList.length - 1) {
                        const nextDayun = dayunList[currentDayunIndex + 1];
                        const qualityDiff = Math.abs(
                            analyzeSingleDayunQuality(nextDayun.ganZhi) - 
                            analyzeSingleDayunQuality(currentDayun.ganZhi)
                        );
                        
                        transitionScore = Math.max(0.3, 1.0 - qualityDiff * 0.5);
                    }
                }
                
                return transitionScore;
            } catch (e) {
                return 1.0;
            }
        }

        // 计算大运与流年互动分数 (0-1分)
        function calculateDayunLiunianInteraction(dayunGanZhi, liunianGanZhi) {
            try {
                const dayunStem = dayunGanZhi.charAt(0);
                const dayunBranch = dayunGanZhi.charAt(1);
                const liunianStem = liunianGanZhi.charAt(0);
                const liunianBranch = liunianGanZhi.charAt(1);
                
                let interactionScore = 0.5;
                
                // 检查天干关系
                if (checkTianGanHeHua(dayunStem, liunianStem)) {
                    interactionScore += 0.2; // 天干合化，增加吉利
                } else if (dayunStem === liunianStem) {
                    interactionScore += 0.1; // 天干相同，增强力量
                } else if (isElementWeakening(getStemElement(dayunStem), getStemElement(liunianStem))) {
                    interactionScore -= 0.1; // 天干相克，减少吉利
                }
                
                // 检查地支关系
                if (checkDiZhiLiuHe(dayunBranch, liunianBranch)) {
                    interactionScore += 0.2; // 地支六合
                } else if (checkDiZhiSanHeSimple(dayunBranch, liunianBranch)) {
                    interactionScore += 0.15; // 地支三合
                } else if (checkDiZhiChong(dayunBranch, liunianBranch)) {
                    interactionScore -= 0.2; // 地支相冲
                } else if (checkDiZhiXing(dayunBranch, liunianBranch)) {
                    interactionScore -= 0.15; // 地支相刑
                } else if (checkDiZhiHai(dayunBranch, liunianBranch)) {
                    interactionScore -= 0.1; // 地支相害
                } else if (dayunBranch === liunianBranch) {
                    interactionScore += 0.1; // 地支相同，增强力量
                }
                
                return Math.max(0, Math.min(1, interactionScore));
            } catch (e) {
                return 0.5;
            }
        }

        // 评估大运五行平衡贡献 (0-1分)
        function evaluateDayunElementBalance(dayunGanZhi, pillars) {
            try {
                const dayunStem = dayunGanZhi.charAt(0);
                const dayunBranch = dayunGanZhi.charAt(1);
                const dayunStemElement = getStemElement(dayunStem);
                const dayunBranchElement = getBranchElement(dayunBranch);
                
                // 计算命局五行分布
                const elementCounts = { '木': 0, '火': 0, '土': 0, '金': 0, '水': 0 };
                
                // 统计四柱天干地支五行
                const allGanZhi = [pillars.year, pillars.month, pillars.day, pillars.hour];
                allGanZhi.forEach(ganZhi => {
                    const stem = ganZhi.charAt(0);
                    const branch = ganZhi.charAt(1);
                    elementCounts[getStemElement(stem)]++;
                    elementCounts[getBranchElement(branch)]++;
                });
                
                // 找出最弱和最强的五行
                const elements = Object.keys(elementCounts);
                const minCount = Math.min(...Object.values(elementCounts));
                const maxCount = Math.max(...Object.values(elementCounts));
                
                const weakestElements = elements.filter(el => elementCounts[el] === minCount);
                const strongestElements = elements.filter(el => elementCounts[el] === maxCount);
                
                let balanceScore = 0.5;
                
                // 如果大运补充最弱五行，加分
                if (weakestElements.includes(dayunStemElement) || weakestElements.includes(dayunBranchElement)) {
                    balanceScore += 0.3;
                }
                
                // 如果大运进一步加强最强五行，减分
                if (strongestElements.includes(dayunStemElement) || strongestElements.includes(dayunBranchElement)) {
                    balanceScore -= 0.2;
                }
                
                // 检查大运是否有助于五行流通
                const dayMasterElement = getStemElement(pillars.day.charAt(0));
                if (isElementSupporting(dayunStemElement, dayMasterElement) || 
                    isElementSupporting(dayunBranchElement, dayMasterElement)) {
                    balanceScore += 0.2;
                }
                
                return Math.max(0, Math.min(1, balanceScore));
            } catch (e) {
                return 0.5;
            }
        }

        // 计算大运对十神的影响 (0-1分)
        function calculateDayunTenGodsImpact(dayunGanZhi, pillars) {
            try {
                const dayMaster = pillars.day.charAt(0);
                const dayunStem = dayunGanZhi.charAt(0);
                const dayunBranch = dayunGanZhi.charAt(1);
                
                // 计算大运天干对应的十神
                const dayunStemTenGod = calculateTenGod(dayMaster, dayunStem);
                
                // 计算大运地支藏干的十神影响
                const hiddenStems = getHiddenStems(dayunBranch);
                let tenGodScore = 0.5;
                
                // 评估大运天干十神的吉凶
                const favorableTenGods = ['正财', '偏财', '正官', '偏官', '正印', '偏印'];
                const unfavorableTenGods = ['劫财', '比肩'];
                
                if (favorableTenGods.includes(dayunStemTenGod)) {
                    tenGodScore += 0.2;
                } else if (unfavorableTenGods.includes(dayunStemTenGod)) {
                    tenGodScore -= 0.1;
                }
                
                // 评估地支藏干十神影响
                if (hiddenStems && hiddenStems.length > 0) {
                    hiddenStems.forEach(hiddenStem => {
                        const hiddenTenGod = calculateTenGod(dayMaster, hiddenStem.stem);
                        const weight = hiddenStem.strength || 0.3;
                        
                        if (favorableTenGods.includes(hiddenTenGod)) {
                            tenGodScore += 0.1 * weight;
                        } else if (unfavorableTenGods.includes(hiddenTenGod)) {
                            tenGodScore -= 0.05 * weight;
                        }
                    });
                }
                
                return Math.max(0, Math.min(1, tenGodScore));
            } catch (e) {
                return 0.5;
            }
        }

        // 计算特殊格局加分 (0~30分) - 直接调用八字排盘的特殊格局计算结果
        function calculateSpecialPatternBonus(pillars) {
            // 直接调用八字排盘中的特殊格局检测函数
            const baziData = window.currentBaziData || {};
            const specialPattern = detectSpecialPattern(pillars, baziData);
            
            let bonus = 0;
            
            if (specialPattern && specialPattern !== '无') {
                // 重新设计特殊格局加分体系，突出高贵格局的价值
                if (specialPattern.includes('日贵')) {
                    bonus += 25; // 日贵格 - 最高贵格局之一
                } else if (specialPattern.includes('魁罡')) {
                    bonus += 22; // 魁罡格 - 刚强贵格
                } else if (specialPattern.includes('专旺')) {
                    bonus += 20; // 专旺格 - 专一成格
                } else if (specialPattern.includes('从强')) {
                    bonus += 18; // 从强格
                } else if (specialPattern.includes('化气')) {
                    bonus += 16; // 化气格 - 五行化合成格
                } else if (specialPattern.includes('从财')) {
                    bonus += 15; // 从财格 - 从弱格中最佳
                } else if (specialPattern.includes('从弱') || specialPattern.includes('从杀') || specialPattern.includes('从儿')) {
                    bonus += 12; // 其他从弱格系列
                } else if (specialPattern.includes('金神')) {
                    bonus += 14; // 金神格 - 特殊贵格
                } else if (specialPattern.includes('三奇')) {
                    bonus += 10; // 三奇贵人格
                } else if (specialPattern.includes('六秀') || specialPattern.includes('井栏')) {
                    bonus += 8; // 六秀日、井栏叉格等
                } else {
                    bonus += 6; // 其他特殊格局
                }
            }
            
            return Math.min(30, bonus); // 最高30分
        }

        // 计算命格层次加分 (0~15分)
        function calculateLevelBonus(pillars) {
            let bonus = 0;
            const dayElement = getStemElement(pillars.day.charAt(0));
            const tenGodsCount = countTenGods(pillars);
            
            // 三奇贵人格局
            if (hasSanQi(pillars)) bonus += 8;
            
            // 官印相生格局
            if (tenGodsCount.正官 > 0 && tenGodsCount.正印 > 0) bonus += 6;
            
            // 食神制杀格局
            if (tenGodsCount.食神 > 0 && tenGodsCount.七杀 > 0) bonus += 5;
            
            // 财官双美格局
            if (tenGodsCount.正财 > 0 && tenGodsCount.正官 > 0) bonus += 4;
            
            // 印绶格高层次
            if (tenGodsCount.正印 >= 2) bonus += 3;
            
            return Math.min(15, bonus);
        }

        // 增强寒暖燥湿调候算法 (0~12分)
        function calculateSeasonalAdjustmentScore(pillars) {
            const monthBranch = pillars.month.charAt(1);
            const dayElement = getStemElement(pillars.day.charAt(0));
            const dayStem = pillars.day.charAt(0);
            let score = 0;
            
            // 1. 基础调候需求评估
            const seasonalNeed = assessSeasonalNeed(dayStem, monthBranch);
            score += seasonalNeed.baseScore;
            
            // 2. 调候用神配置评分
            score += evaluateSeasonalGods(pillars, seasonalNeed);
            
            // 3. 寒暖燥湿平衡评分
            score += evaluateTemperatureHumidityBalance(pillars);
            
            // 4. 特殊调候格局加分
            score += evaluateSpecialSeasonalPatterns(pillars);
            
            return Math.min(12, Math.max(0, score));
        }
        
        // 评估季节调候需求
        function assessSeasonalNeed(dayStem, monthBranch) {
            const dayElement = getStemElement(dayStem);
            let baseScore = 0;
            let needType = '';
            let intensity = 0;
            
            // 冬季寒冷，需要暖局
            if (['子', '丑', '亥'].includes(monthBranch)) {
                needType = '暖';
                if (dayElement === '水') {
                    intensity = 3; // 水日主冬生最需要火暖
                    baseScore = 1;
                } else if (dayElement === '木') {
                    intensity = 2; // 木日主冬生需要火暖
                    baseScore = 1;
                } else if (dayElement === '金') {
                    intensity = 2; // 金日主冬生需要火暖
                    baseScore = 1;
                } else {
                    intensity = 1;
                }
            }
            // 夏季炎热，需要润燥
            else if (['午', '未', '巳'].includes(monthBranch)) {
                needType = '润';
                if (dayElement === '火') {
                    intensity = 3; // 火日主夏生最需要水润
                    baseScore = 1;
                } else if (dayElement === '土') {
                    intensity = 3; // 土日主夏生需要水润
                    baseScore = 1;
                } else if (dayElement === '金') {
                    intensity = 2; // 金日主夏生需要水润
                    baseScore = 1;
                } else {
                    intensity = 1;
                }
            }
            // 春季温和偏燥
            else if (['寅', '卯', '辰'].includes(monthBranch)) {
                needType = '润';
                intensity = 1;
                if (dayElement === '木' && monthBranch === '辰') {
                    intensity = 2; // 木日主春末需要水润
                }
            }
            // 秋季凉燥
            else if (['申', '酉', '戌'].includes(monthBranch)) {
                needType = '润';
                intensity = 1;
                if (dayElement === '金') {
                    intensity = 2; // 金日主秋生需要水润
                }
            }
            
            return { baseScore, needType, intensity };
        }
        
        // 评估调候用神配置
        function evaluateSeasonalGods(pillars, seasonalNeed) {
            let score = 0;
            const tenGodsCount = countTenGods(pillars);
            const dayStem = pillars.day.charAt(0);
            const dayElement = getStemElement(dayStem);
            
            if (seasonalNeed.needType === '暖') {
                // 需要火暖局
                if (dayElement === '水') {
                    // 水日主需要木火
                    if (tenGodsCount.食神 > 0 || tenGodsCount.伤官 > 0) {
                        score += 4; // 水生木，木生火
                    }
                    if (tenGodsCount.正财 > 0 || tenGodsCount.偏财 > 0) {
                        score += 3; // 水克火，但财星有用
                    }
                } else if (dayElement === '木') {
                    // 木日主需要火
                    if (tenGodsCount.食神 > 0 || tenGodsCount.伤官 > 0) {
                        score += 5; // 木火通明
                    }
                } else if (dayElement === '金') {
                    // 金日主需要火炼金
                    if (tenGodsCount.正官 > 0 || tenGodsCount.七杀 > 0) {
                        score += 4; // 火炼金成器
                    }
                }
                
                // 检查是否有火元素透干或藏支
                if (hasFireElement(pillars)) {
                    score += seasonalNeed.intensity;
                }
            } else if (seasonalNeed.needType === '润') {
                // 需要水润燥
                if (dayElement === '火') {
                    // 火日主需要水
                    if (tenGodsCount.正官 > 0 || tenGodsCount.七杀 > 0) {
                        score += 4; // 水制火
                    }
                    if (tenGodsCount.正财 > 0 || tenGodsCount.偏财 > 0) {
                        score += 3; // 火生土生金生水
                    }
                } else if (dayElement === '土') {
                    // 土日主需要水
                    if (tenGodsCount.正官 > 0 || tenGodsCount.七杀 > 0) {
                        score += 5; // 水润土
                    }
                } else if (dayElement === '金') {
                    // 金日主需要水
                    if (tenGodsCount.食神 > 0 || tenGodsCount.伤官 > 0) {
                        score += 4; // 金水相涵
                    }
                }
                
                // 检查是否有水元素透干或藏支
                if (hasWaterElement(pillars)) {
                    score += seasonalNeed.intensity;
                }
            }
            
            return score;
        }
        
        // 评估寒暖燥湿平衡
        function evaluateTemperatureHumidityBalance(pillars) {
            let score = 0;
            const monthBranch = pillars.month.charAt(1);
            
            // 统计寒暖燥湿元素
            const temperatureHumidity = analyzeTemperatureHumidity(pillars);
            
            // 冬季需要暖，检查暖元素配置
            if (['子', '丑', '亥'].includes(monthBranch)) {
                if (temperatureHumidity.warm >= 2) {
                    score += 3; // 有足够暖元素
                } else if (temperatureHumidity.warm >= 1) {
                    score += 1; // 有部分暖元素
                }
                
                // 过湿需要燥土调节
                if (temperatureHumidity.wet >= 3 && temperatureHumidity.dry >= 1) {
                    score += 1; // 湿燥平衡
                }
            }
            // 夏季需要润，检查润元素配置
            else if (['午', '未', '巳'].includes(monthBranch)) {
                if (temperatureHumidity.cool >= 2) {
                    score += 3; // 有足够润元素
                } else if (temperatureHumidity.cool >= 1) {
                    score += 1; // 有部分润元素
                }
                
                // 过燥需要湿润调节
                if (temperatureHumidity.dry >= 3 && temperatureHumidity.wet >= 1) {
                    score += 1; // 燥湿平衡
                }
            }
            
            return score;
        }
        
        // 评估特殊调候格局
        function evaluateSpecialSeasonalPatterns(pillars) {
            let score = 0;
            const monthBranch = pillars.month.charAt(1);
            const dayStem = pillars.day.charAt(0);
            const dayElement = getStemElement(dayStem);
            
            // 木火通明格（春夏木火相生）
            if (dayElement === '木' && ['寅', '卯', '辰', '巳', '午'].includes(monthBranch)) {
                if (hasFireElement(pillars) && checkWoodFireFlow(pillars)) {
                    score += 2;
                }
            }
            
            // 金水相涵格（秋冬金水相生）
            if (dayElement === '金' && ['申', '酉', '戌', '亥', '子'].includes(monthBranch)) {
                if (hasWaterElement(pillars) && checkMetalWaterFlow(pillars)) {
                    score += 2;
                }
            }
            
            // 水火既济格（水火平衡）
            if (hasFireElement(pillars) && hasWaterElement(pillars)) {
                const fireWaterBalance = checkFireWaterBalance(pillars);
                if (fireWaterBalance.isBalanced) {
                    score += 3;
                }
            }
            
            // 土润金生格（土湿润生金）
            if (dayElement === '土' && ['丑', '辰', '未', '戌'].includes(monthBranch)) {
                if (hasWaterElement(pillars) && hasMetalElement(pillars)) {
                    score += 1;
                }
            }
            
            return score;
        }
        
        // 检查是否有火元素
        function hasFireElement(pillars) {
            const fireStems = ['丙', '丁'];
            const fireBranches = ['巳', '午'];
            
            // 检查天干
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                if (fireStems.includes(pillar.charAt(0))) return true;
                if (fireBranches.includes(pillar.charAt(1))) return true;
            }
            
            // 检查地支藏干
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                const hiddenStems = getHiddenStems(pillar.charAt(1));
                for (let stem of hiddenStems) {
                    if (fireStems.includes(stem)) return true;
                }
            }
            
            return false;
        }
        
        // 检查是否有水元素
        function hasWaterElement(pillars) {
            const waterStems = ['壬', '癸'];
            const waterBranches = ['亥', '子'];
            
            // 检查天干
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                if (waterStems.includes(pillar.charAt(0))) return true;
                if (waterBranches.includes(pillar.charAt(1))) return true;
            }
            
            // 检查地支藏干
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                const hiddenStems = getHiddenStems(pillar.charAt(1));
                for (let stem of hiddenStems) {
                    if (waterStems.includes(stem)) return true;
                }
            }
            
            return false;
        }
        
        // 检查是否有金元素
        function hasMetalElement(pillars) {
            const metalStems = ['庚', '辛'];
            const metalBranches = ['申', '酉'];
            
            // 检查天干
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                if (metalStems.includes(pillar.charAt(0))) return true;
                if (metalBranches.includes(pillar.charAt(1))) return true;
            }
            
            // 检查地支藏干
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                const hiddenStems = getHiddenStems(pillar.charAt(1));
                for (let stem of hiddenStems) {
                    if (metalStems.includes(stem)) return true;
                }
            }
            
            return false;
        }
        
        // 分析寒暖燥湿
        function analyzeTemperatureHumidity(pillars) {
            let warm = 0, cool = 0, dry = 0, wet = 0;
            
            // 暖元素：火、阳土
            const warmElements = ['丙', '丁', '戊', '巳', '午', '未'];
            // 凉元素：水、金
            const coolElements = ['壬', '癸', '庚', '辛', '亥', '子', '申', '酉'];
            // 燥元素：火、燥土
            const dryElements = ['丙', '丁', '戊', '巳', '午', '戌', '未'];
            // 湿元素：水、湿土
            const wetElements = ['壬', '癸', '己', '亥', '子', '丑', '辰'];
            
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                const stem = pillar.charAt(0);
                const branch = pillar.charAt(1);
                
                if (warmElements.includes(stem) || warmElements.includes(branch)) warm++;
                if (coolElements.includes(stem) || coolElements.includes(branch)) cool++;
                if (dryElements.includes(stem) || dryElements.includes(branch)) dry++;
                if (wetElements.includes(stem) || wetElements.includes(branch)) wet++;
            }
            
            return { warm, cool, dry, wet };
        }
        
        // 检查木火流通
        function checkWoodFireFlow(pillars) {
            const woodStems = ['甲', '乙'];
            const fireStems = ['丙', '丁'];
            const woodBranches = ['寅', '卯'];
            const fireBranches = ['巳', '午'];
            
            let hasWood = false, hasFire = false;
            
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                const stem = pillar.charAt(0);
                const branch = pillar.charAt(1);
                
                if (woodStems.includes(stem) || woodBranches.includes(branch)) hasWood = true;
                if (fireStems.includes(stem) || fireBranches.includes(branch)) hasFire = true;
            }
            
            return hasWood && hasFire;
        }
        
        // 检查金水流通
        function checkMetalWaterFlow(pillars) {
            const metalStems = ['庚', '辛'];
            const waterStems = ['壬', '癸'];
            const metalBranches = ['申', '酉'];
            const waterBranches = ['亥', '子'];
            
            let hasMetal = false, hasWater = false;
            
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                const stem = pillar.charAt(0);
                const branch = pillar.charAt(1);
                
                if (metalStems.includes(stem) || metalBranches.includes(branch)) hasMetal = true;
                if (waterStems.includes(stem) || waterBranches.includes(branch)) hasWater = true;
            }
            
            return hasMetal && hasWater;
        }
        
        // 检查水火平衡
        function checkFireWaterBalance(pillars) {
            let fireCount = 0, waterCount = 0;
            const fireElements = ['丙', '丁', '巳', '午'];
            const waterElements = ['壬', '癸', '亥', '子'];
            
            for (let pillar of [pillars.year, pillars.month, pillars.day, pillars.hour]) {
                const stem = pillar.charAt(0);
                const branch = pillar.charAt(1);
                
                if (fireElements.includes(stem) || fireElements.includes(branch)) fireCount++;
                if (waterElements.includes(stem) || waterElements.includes(branch)) waterCount++;
            }
            
            const isBalanced = Math.abs(fireCount - waterCount) <= 1 && fireCount > 0 && waterCount > 0;
            return { isBalanced, fireCount, waterCount };
        }

        // 天乙贵人查法
        function getTianYiNoble(dayStem) {
            const tianYiMap = {
                '甲': ['丑', '未'], '乙': ['子', '申'], '丙': ['亥', '酉'], '丁': ['亥', '酉'],
                '戊': ['丑', '未'], '己': ['子', '申'], '庚': ['丑', '未'], '辛': ['午', '寅'],
                '壬': ['卯', '巳'], '癸': ['卯', '巳']
            };
            return tianYiMap[dayStem] || [];
        }

        // 文昌贵人查法
        function getWenChangNoble(dayStem) {
            const wenChangMap = {
                '甲': '巳', '乙': '午', '丙': '申', '丁': '酉', '戊': '申',
                '己': '酉', '庚': '亥', '辛': '子', '壬': '寅', '癸': '卯'
            };
            return wenChangMap[dayStem] || '巳';
        }

        // 天德贵人查法（按月支）
        function getTianDeNoble(monthBranch) {
            const tianDeMap = {
                '子': '丁', '丑': '丁', '寅': '丙', '卯': '甲', '辰': '甲',
                '巳': '癸', '午': '壬', '未': '壬', '申': '辛', '酉': '庚',
                '戌': '庚', '亥': '乙'
            };
            return tianDeMap[monthBranch] || '丁';
        }

        // 月德贵人查法（按月支）
        function getYueDeNoble(monthBranch) {
            const yueDeMap = {
                '子': '丙', '丑': '甲', '寅': '壬', '卯': '庚', '辰': '丙',
                '巳': '甲', '午': '壬', '未': '庚', '申': '丁', '酉': '乙',
                '戌': '癸', '亥': '己'
            };
            return yueDeMap[monthBranch] || '丙';
        }

        // 检查三奇格局
        function hasSanQi(pillars) {
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.day.charAt(0), pillars.hour.charAt(0)];
            
            // 乙丙丁三奇
            const hasYi = stems.includes('乙');
            const hasBing = stems.includes('丙');
            const hasDing = stems.includes('丁');
            if (hasYi && hasBing && hasDing) return true;
            
            // 甲戊庚三奇
            const hasJia = stems.includes('甲');
            const hasWu = stems.includes('戊');
            const hasGeng = stems.includes('庚');
            if (hasJia && hasWu && hasGeng) return true;
            
            return false;
        }
        
        // 专业八字：否决条款（传统版）
        function applyTraditionalVetoRules(score, pillars) {
            let adjusted = score;
            const details = [];
            const dayElement = getStemElement(pillars.day.charAt(0));
            const dayStrength = calculateSimpleDayStrength(pillars);
            
            // 财多身弱不担财
            let wealthCount = 0;
            ['year', 'month', 'hour'].forEach(pos => {
                const stem = pillars[pos].charAt(0);
                if (isWealth(dayElement, getStemElement(stem))) wealthCount++;
            });
            const biJieCount = countBiJieStars(pillars);
            const yinCount = countYinStars(pillars);
            if (dayStrength < 40 && wealthCount >= 3 && (biJieCount + yinCount) === 0) {
                const before = adjusted;
                adjusted = Math.min(adjusted, 70);
                details.push({ name: '财多身弱不担财', type: 'cap', from: before, to: adjusted, note: '日主<40且财星≥3且无印比' });
            }
            
            // 比劫夺财无制
            if (biJieCount >= 2 && wealthCount >= 1) {
                const hasOfficerControl = ['year', 'month', 'hour'].some(pos => {
                    const stem = pillars[pos].charAt(0);
                    return isOfficer(dayElement, getStemElement(stem));
                });
                if (!hasOfficerControl) {
                    const before = adjusted;
                    adjusted = adjusted * 0.7;
                    details.push({ name: '比劫夺财无制', type: 'multiply', factor: 0.7, from: before, to: adjusted, note: '比劫≥2且财星≥1且无官杀制' });
                }
            }
            
            // 伤官见官
            let shiShangCount = 0, guanCount = 0;
            ['year', 'month', 'hour'].forEach(pos => {
                const stem = pillars[pos].charAt(0);
                const elem = getStemElement(stem);
                if (isShishang(dayElement, elem)) shiShangCount++;
                if (isOfficer(dayElement, elem)) guanCount++;
            });
            if (shiShangCount >= 1 && guanCount >= 1) {
                const before = adjusted;
                adjusted = adjusted * 0.8;
                details.push({ name: '伤官见官', type: 'multiply', factor: 0.8, from: before, to: adjusted });
            }
            
            // 全局无财库，封顶
            const hasWealthVault = ['year', 'month', 'day', 'hour'].some(pos => ['辰', '戌', '丑', '未'].includes(pillars[pos].charAt(1)));
            if (!hasWealthVault && adjusted > 80) {
                const before = adjusted;
                adjusted = Math.min(adjusted, 80);
                details.push({ name: '全局无财库封顶', type: 'cap', from: before, to: adjusted });
            }
            
            return { adjustedScore: Math.max(0, Math.round(adjusted)), details };
        }
        
        // 获取财星
        function getWealthStars(dayStem) {
            const wealthMap = {
                '甲': ['戊', '己', '辰', '戌', '丑', '未'], // 木克土
                '乙': ['戊', '己', '辰', '戌', '丑', '未'],
                '丙': ['庚', '辛', '申', '酉'], // 火克金
                '丁': ['庚', '辛', '申', '酉'],
                '戊': ['壬', '癸', '子', '亥'], // 土克水
                '己': ['壬', '癸', '子', '亥'],
                '庚': ['甲', '乙', '寅', '卯'], // 金克木
                '辛': ['甲', '乙', '寅', '卯'],
                '壬': ['丙', '丁', '午', '巳'], // 水克火
                '癸': ['丙', '丁', '午', '巳']
            };
            return wealthMap[dayStem] || [];
        }
        
        // 获取印星
        function getYinStars(dayStem) {
            const yinMap = {
                '甲': ['壬', '癸', '子', '亥'], // 水生木
                '乙': ['壬', '癸', '子', '亥'],
                '丙': ['甲', '乙', '寅', '卯'], // 木生火
                '丁': ['甲', '乙', '寅', '卯'],
                '戊': ['丙', '丁', '午', '巳'], // 火生土
                '己': ['丙', '丁', '午', '巳'],
                '庚': ['戊', '己', '辰', '戌', '丑', '未'], // 土生金
                '辛': ['戊', '己', '辰', '戌', '丑', '未'],
                '壬': ['庚', '辛', '申', '酉'], // 金生水
                '癸': ['庚', '辛', '申', '酉']
            };
            return yinMap[dayStem] || [];
        }
        
        // 获取食伤星
        function getShiShangStars(dayStem) {
            const shiShangMap = {
                '甲': ['丙', '丁', '午', '巳'], // 木生火
                '乙': ['丙', '丁', '午', '巳'],
                '丙': ['戊', '己', '辰', '戌', '丑', '未'], // 火生土
                '丁': ['戊', '己', '辰', '戌', '丑', '未'],
                '戊': ['庚', '辛', '申', '酉'], // 土生金
                '己': ['庚', '辛', '申', '酉'],
                '庚': ['壬', '癸', '子', '亥'], // 金生水
                '辛': ['壬', '癸', '子', '亥'],
                '壬': ['甲', '乙', '寅', '卯'], // 水生木
                '癸': ['甲', '乙', '寅', '卯']
            };
            return shiShangMap[dayStem] || [];
        }
        
        // 获取比劫星
        function getBiJieStars(dayStem) {
            const biJieMap = {
                '甲': ['甲', '乙', '寅', '卯'], // 同类五行
                '乙': ['甲', '乙', '寅', '卯'],
                '丙': ['丙', '丁', '午', '巳'],
                '丁': ['丙', '丁', '午', '巳'],
                '戊': ['戊', '己', '辰', '戌', '丑', '未'],
                '己': ['戊', '己', '辰', '戌', '丑', '未'],
                '庚': ['庚', '辛', '申', '酉'],
                '辛': ['庚', '辛', '申', '酉'],
                '壬': ['壬', '癸', '子', '亥'],
                '癸': ['壬', '癸', '子', '亥']
            };
            return biJieMap[dayStem] || [];
        }

        // calculateWealthFlowScore函数已被新的财富结构评分替代
        
        // 获取官杀星
        function getGuanShaStars(dayStem) {
            const guanShaMap = {
                '甲': ['庚', '辛', '申', '酉'], // 金克木
                '乙': ['庚', '辛', '申', '酉'],
                '丙': ['壬', '癸', '子', '亥'], // 水克火
                '丁': ['壬', '癸', '子', '亥'],
                '戊': ['甲', '乙', '寅', '卯'], // 木克土
                '己': ['甲', '乙', '寅', '卯'],
                '庚': ['丙', '丁', '午', '巳'], // 火克金
                '辛': ['丙', '丁', '午', '巳'],
                '壬': ['戊', '己', '辰', '戌', '丑', '未'], // 土克水
                '癸': ['戊', '己', '辰', '戌', '丑', '未']
            };
            return guanShaMap[dayStem] || [];
        }
        
        // 计算五行流通分数
        function calculateFiveElementFlow(pillars) {
            const elements = {
                '甲': '木', '乙': '木', '寅': '木', '卯': '木',
                '丙': '火', '丁': '火', '午': '火', '巳': '火',
                '戊': '土', '己': '土', '辰': '土', '戌': '土', '丑': '土', '未': '土',
                '庚': '金', '辛': '金', '申': '金', '酉': '金',
                '壬': '水', '癸': '水', '子': '水', '亥': '水'
            };
            
            const allChars = [
                pillars.year.charAt(0), pillars.year.charAt(1),
                pillars.month.charAt(0), pillars.month.charAt(1),
                pillars.day.charAt(0), pillars.day.charAt(1),
                pillars.hour.charAt(0), pillars.hour.charAt(1)
            ];
            
            const elementSet = new Set();
            allChars.forEach(char => {
                if (elements[char]) {
                    elementSet.add(elements[char]);
                }
            });
            
            const elementCount = elementSet.size;
            
            // 五行齐全得6分，四行得4分，三行得2分
            if (elementCount >= 5) return 6;
            else if (elementCount === 4) return 4;
            else if (elementCount === 3) return 2;
            else return 0;
        }

        // calculateWealthTimingScore函数已被新的财富潜力评分替代

        // 获取财富等级 - 改为5星制，适配120分满分制度
        function getWealthLevel(score) {
            // 调整为5星制，分数区间更合理
            if (score >= 100) return { name: "超格富贵 ★★★★★", class: "legendary-rich" };   // 100+：五星
            if (score >= 80) return { name: "制度富贵 ★★★★☆", class: "ultra-rich" };        // 80-99：四星
            if (score >= 60) return { name: "技术致富 ★★★☆☆", class: "very-rich" };          // 60-79：三星
            if (score >= 40) return { name: "勤勉小富 ★★☆☆☆", class: "moderately-rich" };     // 40-59：二星
            if (score >= 20) return { name: "小康水平 ★☆☆☆☆", class: "somewhat-rich" };       // 20-39：一星
            return { name: "平常级别 ☆☆☆☆☆", class: "wealth-average" };                     // <20：零星
        }

        // 获取财富描述 - 基于优化后的专业命理理论，适配5星制
        function getWealthDescription(score) {
            if (score >= 100) return '超格富贵命局，财星格局完美，十神配合得当，具备顶级富豪潜质，财富可达亿级以上，适合大型产业投资或金融运作';
            if (score >= 80) return '制度富贵之命，财星旺盛且有利，格局上乘，日主有力承载，具备千万级富豪潜质，适合大型企业经营或高端投资';
            if (score >= 60) return '技术致富格局，财星强劲配合得当，善于创新发展，可通过专业技能或科技创业达到数百万级资产';
            if (score >= 40) return '勤勉小富之命，财星中等但稳定，格局平衡，通过持续努力可积累百万级财富，适合稳健经营';
            if (score >= 20) return '小康水平命局，财星尚可，需要努力经营和理财规划，可达到小康生活水平';
            if (score >= 10) return '基本温饱之命，财运一般，需通过勤奋工作维持稳定生活，建议加强技能提升和理财意识';
            return '财运平常，需注重开源节流，逐步改善财务状况，避免高风险投资，以稳为主';
        }

        // 显示结果
        function displayResults(baziData) {
            displayBasicInfo(baziData);
            displayBaziChart(baziData);
            displayElementsChartComplete(baziData);
            displayStrengthChart(baziData);
            
            // 计算并显示当前身强身弱分析
            try {
                const currentYear = new Date().getFullYear();
                const dayStem = baziData.pillars.day[0];
                const monthBranch = baziData.pillars.month[1];
                const currentStrengthData = calculateCurrentStrength(dayStem, baziData.elements, monthBranch, currentYear);
                displayCurrentStrengthChart(currentStrengthData);
            } catch (error) {
                console.error('计算当前身强身弱分析失败:', error);
                // 显示错误信息
                const description = document.getElementById('current-strength-description');
                if (description) {
                    description.innerHTML = `
                        <h4><i class="fas fa-clock"></i> 当前身强身弱分析</h4>
                        <div style="background-color: #f8d7da; padding: 15px; border-radius: 8px; border: 1px solid #f5c6cb; color: #721c24;">
                            <p><i class="fas fa-exclamation-triangle"></i> 计算当前身强身弱分析时出现错误，请稍后重试。</p>
                        </div>
                    `;
                }
            }
            
            displayLuckTiming(baziData);
            displayFateLevel(baziData);
            displayWealthLevel(baziData);
            
            // 为年命纳音、日主、特殊格局容器添加CSS类名
            setTimeout(() => {
                addBaziInfoClasses();
            }, 100);
        }

        // 显示基本信息
        function displayBasicInfo(baziData) {
            const userInfoTitle = document.getElementById('user-info-title');
            const basicInfoContent = document.getElementById('basic-info-content');
            
            userInfoTitle.textContent = `${baziData.name} - ${baziData.gender === 'male' ? '男' : '女'}`;
            
            const solarDate = baziData.solar.toYmd();
            const lunarDate = baziData.lunar.toString();
            
            basicInfoContent.innerHTML = `
                <div class="info-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                    <div class="info-item">
                        <strong>阳历：</strong>${solarDate}
                    </div>
                    <div class="info-item">
                        <strong>农历：</strong>${lunarDate}
                    </div>
                    <div class="info-item">
                        <strong>性别：</strong>${baziData.gender === 'male' ? '男' : '女'}
                    </div>
                    <div class="info-item">
                        <strong>时辰：</strong>${baziData.birthTime}
                    </div>
                </div>
            `;
        }

        // 显示八字排盘
        function displayBaziChart(baziData) {
            const baziChart = document.getElementById('bazi-chart');
            const { pillars, hiddenStems } = baziData;
            const dayStem = pillars.day[0]; // 日主天干
            
            // 五行颜色映射
            const elementColors = {
                '木': '#27ae60', // 绿色
                '火': '#e74c3c', // 红色
                '土': '#f39c12', // 黄色
                '金': '#95a5a6', // 银色
                '水': '#3498db'  // 蓝色
            };
            
            // 天干地支五行映射
            const elementMap = {
                '甲': '木', '乙': '木',
                '丙': '火', '丁': '火',
                '戊': '土', '己': '土',
                '庚': '金', '辛': '金',
                '壬': '水', '癸': '水',
                '寅': '木', '卯': '木',
                '巳': '火', '午': '火',
                '辰': '土', '戌': '土', '丑': '土', '未': '土',
                '申': '金', '酉': '金',
                '子': '水', '亥': '水'
            };
            
            // 生成带颜色和十神的天干
                function coloredStem(stem, isDay = false) {
                    const element = elementMap[stem] || '';
                    const color = elementColors[element] || '#000';
                    const tenGod = isDay ? '' : getTenGod(dayStem, stem);
                    const tenGodText = isDay ? '' : `<small style="display:block;font-size:0.5em;color:#666;margin-top:2px;text-align:center;">${tenGod}</small>`;
                    const bgColor = isDay ? `background:linear-gradient(135deg, rgba(${getElementRGB(element)}, 0.15), rgba(${getElementRGB(element)}, 0.05));` : '';
                    return `<div style="display:inline-block;${bgColor}border-radius:6px;padding:3px 8px;">
                        <span style="color:${color};font-weight:bold;font-size:1.6em;font-family:'SimHei','黑体',sans-serif;text-shadow:0 1px 2px rgba(0,0,0,0.1);">${stem}</span>
                        ${tenGodText}
                    </div>`;
                }
                
                // 生成带颜色和十神的地支
                function coloredBranch(branch) {
                    const element = elementMap[branch] || '';
                    const color = elementColors[element] || '#000';
                    const tenGod = getTenGod(dayStem, branch);
                    return `<div style="display:inline-block;border-radius:6px;padding:3px 8px;">
                        <span style="color:${color};font-weight:bold;font-size:1.6em;font-family:'SimHei','黑体',sans-serif;text-shadow:0 1px 2px rgba(0,0,0,0.1);">${branch}</span>
                        <small style="display:block;font-size:0.5em;color:#666;margin-top:2px;text-align:center;">${tenGod}</small>
                    </div>`;
                }
                
                // 生成带颜色和十神的藏干
                function coloredHiddenStems(stems) {
                    return stems.map((stem, index) => {
                        const element = elementMap[stem] || '';
                        const color = elementColors[element] || '#000';
                        const tenGod = getTenGod(dayStem, stem);
                        return `<div style="display:inline-block;margin:0 1px;border-radius:4px;padding:2px 4px;background:rgba(${getElementRGB(element)}, 0.05);">
                            <span style="color:${color};font-size:1.1em;font-family:'SimHei','黑体',sans-serif;text-shadow:0 1px 1px rgba(0,0,0,0.05);">${stem}</span>
                            <small style="display:block;font-size:0.45em;color:#666;margin-top:1px;text-align:center;">${tenGod}</small>
                        </div>`;
                    }).join('');
                }
                
                // 获取五行对应的RGB值
                function getElementRGB(element) {
                    switch(element) {
                        case '木': return '39, 174, 96'; // 绿色
                        case '火': return '231, 76, 60'; // 红色
                        case '土': return '243, 156, 18'; // 黄色
                        case '金': return '149, 165, 166'; // 银色
                        case '水': return '52, 152, 219'; // 蓝色
                        default: return '0, 0, 0';
                    }
                }
            
            baziChart.innerHTML = `
                <table class="bazi-table">
                    <thead>
                        <tr>
                            <th>四柱</th>
                            <th class="pillar-header">年柱</th>
                            <th class="pillar-header">月柱</th>
                            <th class="pillar-header">日柱</th>
                            <th class="pillar-header">时柱</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>天干</strong></td>
                            <td class="stem">${coloredStem(pillars.year[0])}</td>
                            <td class="stem">${coloredStem(pillars.month[0])}</td>
                            <td class="stem">${coloredStem(pillars.day[0], true)}</td>
                            <td class="stem">${coloredStem(pillars.hour[0])}</td>
                        </tr>
                        <tr>
                            <td><strong>地支</strong></td>
                            <td class="branch">${coloredBranch(pillars.year[1])}</td>
                            <td class="branch">${coloredBranch(pillars.month[1])}</td>
                            <td class="branch">${coloredBranch(pillars.day[1])}</td>
                            <td class="branch">${coloredBranch(pillars.hour[1])}</td>
                        </tr>
                        <tr>
                            <td><strong>藏干</strong></td>
                            <td>${coloredHiddenStems(hiddenStems.year)}</td>
                            <td>${coloredHiddenStems(hiddenStems.month)}</td>
                            <td>${coloredHiddenStems(hiddenStems.day)}</td>
                            <td>${coloredHiddenStems(hiddenStems.hour)}</td>
                        </tr>
                    </tbody>
                </table>
                
                <!-- 大运流年信息表格 -->
                <div style="margin-top: 12px;">
                    <table class="bazi-table">
                        <thead>
                            <tr>
                                <th>运程</th>
                                <th class="pillar-header">当前大运</th>
                                <th class="pillar-header">流年</th>
                                <th class="pillar-header">流月</th>
                                <th class="pillar-header">流日</th>
                                <th class="pillar-header">运程信息</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${(() => {
                                const currentYear = new Date().getFullYear();
                                const currentDayun = getCurrentDayun();
                                const yearGanZhi = getYearGanZhi(currentYear);
                                
                                // 获取当前月份和日期干支
                                const today = new Date();
                                const currentSolar = Solar.fromDate(today);
                                const currentLunar = currentSolar.getLunar();
                                const monthGanZhi = currentLunar.getMonthInGanZhiExact();
                                const dayGanZhi = currentLunar.getDayInGanZhiExact();
                                
                                return `
                                <tr>
                                    <td><strong>干支</strong></td>
                                    <td class="stem">${coloredStem(currentDayun.ganZhi[0])}${coloredBranch(currentDayun.ganZhi[1])}</td>
                                    <td class="stem">${coloredStem(yearGanZhi[0])}${coloredBranch(yearGanZhi[1])}</td>
                                    <td class="stem">${coloredStem(monthGanZhi[0])}${coloredBranch(monthGanZhi[1])}</td>
                                    <td class="stem">${coloredStem(dayGanZhi[0])}${coloredBranch(dayGanZhi[1])}</td>
                                    <td style="text-align: left; padding: 10px;">
                                        <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">大运: ${currentDayun.startAge}-${currentDayun.endAge}岁</div>
                                        <div style="font-size: 0.9em; color: #666;">当前: ${currentDayun.currentAge}岁 (${currentYear}年${today.getMonth() + 1}月${today.getDate()}日)</div>
                                    </td>
                                </tr>
                                `;
                            })()} 
                        </tbody>
                    </table>
                </div>
                
                <div class="bazi-info-grid" style="margin-top: 20px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                    <div class="bazi-info-card" style="padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 16px; box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3); text-align: center; color: white; position: relative; overflow: hidden;">
                        <div style="position: absolute; top: -20px; right: -20px; width: 60px; height: 60px; background: rgba(255,255,255,0.1); border-radius: 50%; opacity: 0.6;"></div>
                        <div style="font-size: 0.9rem; margin-bottom: 8px; opacity: 0.9; font-weight: 500;">年命纳音</div>
                        <div style="font-size: 1.3rem; font-weight: 700; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">${baziData.lunar.getYearNaYin()}</div>
                    </div>
                    
                    <div class="bazi-info-card" style="padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 16px; box-shadow: 0 8px 25px rgba(240, 147, 251, 0.3); text-align: center; color: white; position: relative; overflow: hidden;">
                        <div style="position: absolute; top: -20px; right: -20px; width: 60px; height: 60px; background: rgba(255,255,255,0.1); border-radius: 50%; opacity: 0.6;"></div>
                        <div style="font-size: 0.9rem; margin-bottom: 8px; opacity: 0.9; font-weight: 500;">日主</div>
                        <div style="font-size: 1.3rem; font-weight: 700; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                            ${pillars.day[0]}${getElementName(pillars.day[0])}命
                        </div>
                    </div>
                    
                    <div class="bazi-info-card" style="padding: 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius: 16px; box-shadow: 0 8px 25px rgba(79, 172, 254, 0.3); text-align: center; color: white; position: relative; overflow: hidden;">
                        <div style="position: absolute; top: -20px; right: -20px; width: 60px; height: 60px; background: rgba(255,255,255,0.1); border-radius: 50%; opacity: 0.6;"></div>
                        <div style="font-size: 0.9rem; margin-bottom: 8px; opacity: 0.9; font-weight: 500;">特殊格局</div>
                        <div style="font-size: 1.3rem; font-weight: 700; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                            ${(() => {
                                const specialPattern = detectSpecialPattern(pillars, baziData);
                                return specialPattern || '无';
                            })()}
                        </div>
                    </div>
                </div>
                

                
                <!-- 命格神煞板块 -->
                <div style="margin-top: 20px; padding: 20px; background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(248,249,250,0.9)); border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); backdrop-filter: blur(10px);">
                    <div style="display: flex; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid rgba(138, 43, 226, 0.2);">
                        <i class="fas fa-star" style="color: #8a2be2; font-size: 1.3em; margin-right: 10px;"></i>
                        <h3 style="margin: 0; color: #2c3e50; font-size: 1.4em; font-weight: 600;">命格神煞</h3>
                    </div>
                    ${generateShenshaDisplay(pillars, baziData)}
                </div>
            `;
        }

        // 神煞计算函数（使用lunar.js库）
        function calculateShensha(pillars, baziData) {
            const shensha = {
                year: [],
                month: [],
                day: [],
                hour: []
            };
            
            try {
                // 直接使用baziData中的lunar对象
                const lunar = baziData.lunar;
                if (!lunar) {
                    console.error('baziData.lunar is undefined');
                    return shensha;
                }
                const eightChar = baziData.lunar.getEightChar();
                
                // 获取农历月份和日柱干支
                const lunarMonth = baziData.lunar.getMonth();
                const dayGanZhi = eightChar.getDay();
                
                // 定义常用的传统神煞列表
                const commonShensha = [
                    '天乙贵人', '太极贵人', '天德贵人', '月德贵人', '三奇贵人',
                    '将星', '华盖', '文昌', '学堂', '词馆', '国印贵人',
                    '天喜', '红鸾', '咸池', '桃花', '驿马', '禄神',
                    '羊刃', '飞刃', '劫煞', '亡神', '灾煞', '天罗地网',
                    '孤辰', '寡宿', '空亡', '十恶大败', '魁罡', '金神',
                    '天医', '月德合', '天德合', '福星贵人', '天厨贵人',
                    '披麻', '吊客', '丧门', '白虎', '天狗', '病符',
                    '文昌贵人', '学堂贵人', '词馆贵人', '金匮', '玉堂',
                    '司命', '勾陈', '青龙', '朱雀', '玄武', '天刑',
                    '天德', '月德', '天恩', '母仓', '时阳', '生气'
                ];
                
                // 使用lunar.js的神煞计算方法
                const dayJiShen = LunarUtil.getDayJiShen(lunarMonth, dayGanZhi);
                const dayXiongSha = LunarUtil.getDayXiongSha(lunarMonth, dayGanZhi);
                
                // 将吉神添加到日柱（过滤不常见的神煞）
                dayJiShen.forEach(shen => {
                    if (shen && shen !== '无' && commonShensha.includes(shen)) {
                        shensha.day.push({ name: shen, type: 'auspicious' });
                    }
                });
                
                // 将凶煞添加到日柱（过滤不常见的神煞）
                dayXiongSha.forEach(sha => {
                    if (sha && sha !== '无' && commonShensha.includes(sha)) {
                        shensha.day.push({ name: sha, type: 'inauspicious' });
                    }
                });
                
            } catch (error) {
                console.error('lunar.js神煞计算错误:', error);
            }
            
            // 补充手动计算的重要神煞
            const dayMaster = pillars.day[0]; // 日主天干
            const yearBranch = pillars.year[1]; // 年支
            const monthBranch = pillars.month[1]; // 月支
            const dayBranch = pillars.day[1]; // 日支
            const hourBranch = pillars.hour[1]; // 时支
            
            // 补充重要神煞（lunar.js未覆盖的）
            // 天乙贵人（甲戊兼牛羊，乙己鼠猴乡，丙丁猪鸡位，壬癸兔蛇藏，庚辛逢马虎）
            const tianYiMap = {
                '甲': ['丑', '未'], '戊': ['丑', '未'],                    // 甲戊兼牛羊
                '乙': ['子', '申'], '己': ['子', '申'],                    // 乙己鼠猴乡
                '丙': ['亥', '酉'], '丁': ['亥', '酉'],                    // 丙丁猪鸡位
                '壬': ['巳', '卯'], '癸': ['巳', '卯'],                    // 壬癸兔蛇藏
                '庚': ['午', '寅'], '辛': ['午', '寅']                    // 庚辛逢马虎
            };
            
            // 将星
            const jiangXingMap = {
                '寅午戌': '午', '申子辰': '子', '巳酉丑': '酉', '亥卯未': '卯'
            };
            
            // 魁罡
            const kuiGangList = ['庚戌', '庚辰', '壬辰', '戊戌'];
            
            // 获取地支三合局分组
            function getDayBranchGroup(branch) {
                if (['寅', '午', '戌'].includes(branch)) return '寅午戌';
                if (['申', '子', '辰'].includes(branch)) return '申子辰';
                if (['巳', '酉', '丑'].includes(branch)) return '巳酉丑';
                if (['亥', '卯', '未'].includes(branch)) return '亥卯未';
                return null;
            }
            
            
            // 简化的神煞计算逻辑
            
            const branches = [yearBranch, monthBranch, dayBranch, hourBranch];
            const pillarsArray = ['year', 'month', 'day', 'hour'];
            
            // 补充重要神煞计算
            branches.forEach((branch, index) => {
                const pillar = pillarsArray[index];
                const stem = pillars[pillarsArray[index]][0]; // 当前柱的天干
                
                // 天乙贵人（以日干查四柱地支，同时以年干查四柱地支）
            // 日干查法
            if (tianYiMap[dayMaster] && tianYiMap[dayMaster].includes(branch)) {
                shensha[pillar].push({ name: '天乙贵人', type: 'auspicious' });
            }
            // 年干查法（补充）
            const yearMaster = pillars.year[0]; // 年干
            if (tianYiMap[yearMaster] && tianYiMap[yearMaster].includes(branch)) {
                shensha[pillar].push({ name: '天乙贵人', type: 'auspicious' });
            }
            // 当前柱天干查法（补充）
            if (tianYiMap[stem] && tianYiMap[stem].includes(branch)) {
                shensha[pillar].push({ name: '天乙贵人', type: 'auspicious' });
            }
                
                // 将星（基于年支三合局）
                const yearBranchGroup = getDayBranchGroup(yearBranch);
                if (yearBranchGroup && jiangXingMap[yearBranchGroup] === branch) {
                    shensha[pillar].push({ name: '将星', type: 'auspicious' });
                }
                
                // 将星（基于日支三合局）
                const dayBranchGroup = getDayBranchGroup(dayBranch);
                if (dayBranchGroup && jiangXingMap[dayBranchGroup] === branch) {
                    shensha[pillar].push({ name: '将星', type: 'auspicious' });
                }
                
                // 桃花（基于年支三合局）
                const taoHuaMap = {
                    '寅午戌': '卯', '申子辰': '酉', '巳酉丑': '午', '亥卯未': '子'
                };
                if (yearBranchGroup && taoHuaMap[yearBranchGroup] === branch) {
                    shensha[pillar].push({ name: '桃花', type: 'neutral' });
                }
                
                // 桃花（基于日支三合局）
                if (dayBranchGroup && taoHuaMap[dayBranchGroup] === branch) {
                    shensha[pillar].push({ name: '桃花', type: 'neutral' });
                }
                
                // 驿马（基于年支三合局）
                const yiMaMap = {
                    '寅午戌': '申', '申子辰': '寅', '巳酉丑': '亥', '亥卯未': '巳'
                };
                if (yearBranchGroup && yiMaMap[yearBranchGroup] === branch) {
                    shensha[pillar].push({ name: '驿马', type: 'neutral' });
                }
                
                // 驿马（基于日支三合局）
                if (dayBranchGroup && yiMaMap[dayBranchGroup] === branch) {
                    shensha[pillar].push({ name: '驿马', type: 'neutral' });
                }
                
                // 华盖（基于年支三合局）
                const huaGaiMap = {
                    '寅午戌': '戌', '申子辰': '辰', '巳酉丑': '丑', '亥卯未': '未'
                };
                if (yearBranchGroup && huaGaiMap[yearBranchGroup] === branch) {
                    shensha[pillar].push({ name: '华盖', type: 'neutral' });
                }
                
                // 华盖（基于日支三合局）
                if (dayBranchGroup && huaGaiMap[dayBranchGroup] === branch) {
                    shensha[pillar].push({ name: '华盖', type: 'neutral' });
                }
                
                // 文昌贵人（基于日主）
                const wenChangMap = {
                    '甲': '巳', '乙': '午', '丙': '申', '丁': '酉', '戊': '申',
                    '己': '酉', '庚': '亥', '辛': '子', '壬': '寅', '癸': '卯'
                };
                if (wenChangMap[dayMaster] === branch) {
                    shensha[pillar].push({ name: '文昌贵人', type: 'auspicious' });
                }
                
                // 禄神（基于当前柱天干）
                const luShenMap = {
                    '甲': '寅', '乙': '卯', '丙': '巳', '丁': '午', '戊': '巳',
                    '己': '午', '庚': '申', '辛': '酉', '壬': '亥', '癸': '子'
                };
                if (luShenMap[stem] === branch) {
                    shensha[pillar].push({ name: '禄神', type: 'auspicious' });
                }
                
                // 羊刃（基于日主）
                const yangRenMap = {
                    '甲': '卯', '乙': '寅', '丙': '午', '丁': '巳', '戊': '午',
                    '己': '巳', '庚': '酉', '辛': '申', '壬': '子', '癸': '亥'
                };
                if (yangRenMap[dayMaster] === branch) {
                    shensha[pillar].push({ name: '羊刃', type: 'inauspicious' });
                }
                
                // 太极贵人（基于日主）
                const taiJiMap = {
                    '甲': ['子', '午'], '乙': ['子', '午'], '丙': ['卯', '酉'], '丁': ['卯', '酉'],
                    '戊': ['辰', '戌', '丑', '未'], '己': ['辰', '戌', '丑', '未'], 
                    '庚': ['寅', '亥'], '辛': ['寅', '亥'], '壬': ['巳', '申'], '癸': ['巳', '申']
                };
                if (taiJiMap[dayMaster] && taiJiMap[dayMaster].includes(branch)) {
                    shensha[pillar].push({ name: '太极贵人', type: 'auspicious' });
                }
                
                // 福星贵人（基于日主）
                const fuXingMap = {
                    '甲': '寅', '乙': '卯', '丙': '巳', '丁': '午', '戊': '巳',
                    '己': '午', '庚': '申', '辛': '酉', '壬': '亥', '癸': '子'
                };
                if (fuXingMap[dayMaster] === branch) {
                    shensha[pillar].push({ name: '福星贵人', type: 'auspicious' });
                }
                
                // 金神（特殊组合）
                const jinShenList = ['乙丑', '己巳', '癸酉'];
                const currentGanZhi = stem + branch;
                if (jinShenList.includes(currentGanZhi)) {
                    shensha[pillar].push({ name: '金神', type: 'neutral' });
                }
                
                // 天喜（基于年支）
                const tianXiMap = {
                    '子': '卯', '丑': '寅', '寅': '丑', '卯': '子', '辰': '亥', '巳': '戌',
                    '午': '酉', '未': '申', '申': '未', '酉': '午', '戌': '巳', '亥': '辰'
                };
                if (tianXiMap[yearBranch] === branch) {
                    shensha[pillar].push({ name: '天喜', type: 'auspicious' });
                }
                
                // 天厨贵人（基于日主）
                const tianChuMap = {
                    '甲': '巳', '乙': '巳', '丙': '未', '丁': '未', '戊': '酉',
                    '己': '酉', '庚': '亥', '辛': '亥', '壬': '丑', '癸': '丑'
                };
                if (tianChuMap[dayMaster] === branch) {
                    shensha[pillar].push({ name: '天厨贵人', type: 'auspicious' });
                }
                
                // 红鸾（基于年支）
                const hongLuanMap = {
                    '子': '卯', '丑': '寅', '寅': '丑', '卯': '子', '辰': '亥', '巳': '戌',
                    '午': '酉', '未': '申', '申': '未', '酉': '午', '戌': '巳', '亥': '辰'
                };
                if (hongLuanMap[yearBranch] === branch) {
                    shensha[pillar].push({ name: '红鸾', type: 'auspicious' });
                }
                
                // 咸池（基于年支三合局）
                const xianChiMap = {
                    '寅午戌': '卯', '申子辰': '酉', '巳酉丑': '午', '亥卯未': '子'
                };
                if (yearBranchGroup && xianChiMap[yearBranchGroup] === branch) {
                    shensha[pillar].push({ name: '咸池', type: 'neutral' });
                }
                
                // 孤辰寡宿（基于年支）
                const guChenMap = {
                    '寅卯辰': '寅', '巳午未': '巳', '申酉戌': '申', '亥子丑': '亥'
                };
                const guaXuMap = {
                    '寅卯辰': '戌', '巳午未': '丑', '申酉戌': '未', '亥子丑': '辰'
                };
                
                let yearGroup = null;
                if (['寅', '卯', '辰'].includes(yearBranch)) yearGroup = '寅卯辰';
                else if (['巳', '午', '未'].includes(yearBranch)) yearGroup = '巳午未';
                else if (['申', '酉', '戌'].includes(yearBranch)) yearGroup = '申酉戌';
                else if (['亥', '子', '丑'].includes(yearBranch)) yearGroup = '亥子丑';
                
                if (yearGroup) {
                    if (guChenMap[yearGroup] === branch) {
                        shensha[pillar].push({ name: '孤辰', type: 'inauspicious' });
                    }
                    if (guaXuMap[yearGroup] === branch) {
                        shensha[pillar].push({ name: '寡宿', type: 'inauspicious' });
                    }
                }
                
                // 亡神（基于年支三合局）
                const wangShenMap = {
                    '寅午戌': '亥', '申子辰': '巳', '巳酉丑': '寅', '亥卯未': '申'
                };
                if (yearBranchGroup && wangShenMap[yearBranchGroup] === branch) {
                    shensha[pillar].push({ name: '亡神', type: 'inauspicious' });
                }
                
                // 劫煞（基于年支三合局）
                const jieShaMap = {
                    '寅午戌': '巳', '申子辰': '亥', '巳酉丑': '申', '亥卯未': '寅'
                };
                if (yearBranchGroup && jieShaMap[yearBranchGroup] === branch) {
                    shensha[pillar].push({ name: '劫煞', type: 'inauspicious' });
                }
                
                // 灾煞（基于年支三合局）
                const zaiShaMap = {
                    '寅午戌': '酉', '申子辰': '卯', '巳酉丑': '子', '亥卯未': '午'
                };
                if (yearBranchGroup && zaiShaMap[yearBranchGroup] === branch) {
                    shensha[pillar].push({ name: '灾煞', type: 'inauspicious' });
                }
                
                // 空亡（基于日柱查）
                const kongWangMap = {
                    '甲子': ['戌', '亥'], '甲戌': ['申', '酉'], '甲申': ['午', '未'],
                    '甲午': ['辰', '巳'], '甲辰': ['寅', '卯'], '甲寅': ['子', '丑'],
                    '乙丑': ['戌', '亥'], '乙亥': ['申', '酉'], '乙酉': ['午', '未'],
                    '乙未': ['辰', '巳'], '乙巳': ['寅', '卯'], '乙卯': ['子', '丑'],
                    '丙寅': ['戌', '亥'], '丙子': ['申', '酉'], '丙戌': ['午', '未'],
                    '丙申': ['辰', '巳'], '丙午': ['寅', '卯'], '丙辰': ['子', '丑'],
                    '丁卯': ['戌', '亥'], '丁丑': ['申', '酉'], '丁亥': ['午', '未'],
                    '丁酉': ['辰', '巳'], '丁未': ['寅', '卯'], '丁巳': ['子', '丑'],
                    '戊辰': ['戌', '亥'], '戊寅': ['申', '酉'], '戊子': ['午', '未'],
                    '戊戌': ['辰', '巳'], '戊申': ['寅', '卯'], '戊午': ['子', '丑'],
                    '己巳': ['戌', '亥'], '己卯': ['申', '酉'], '己丑': ['午', '未'],
                    '己亥': ['辰', '巳'], '己酉': ['寅', '卯'], '己未': ['子', '丑'],
                    '庚午': ['戌', '亥'], '庚辰': ['申', '酉'], '庚寅': ['午', '未'],
                    '庚子': ['辰', '巳'], '庚戌': ['寅', '卯'], '庚申': ['子', '丑'],
                    '辛未': ['戌', '亥'], '辛巳': ['申', '酉'], '辛卯': ['午', '未'],
                    '辛丑': ['辰', '巳'], '辛亥': ['寅', '卯'], '辛酉': ['子', '丑'],
                    '壬申': ['戌', '亥'], '壬午': ['申', '酉'], '壬辰': ['午', '未'],
                    '壬寅': ['辰', '巳'], '壬子': ['寅', '卯'], '壬戌': ['子', '丑'],
                    '癸酉': ['戌', '亥'], '癸未': ['申', '酉'], '癸巳': ['午', '未'],
                    '癸卯': ['辰', '巳'], '癸丑': ['寅', '卯'], '癸亥': ['子', '丑']
                };
                const dayPillarGanZhi = pillars.day[0] + pillars.day[1];
                const kongWangBranches = kongWangMap[dayPillarGanZhi];
                if (kongWangBranches && kongWangBranches.includes(branch)) {
                    shensha[pillar].push({ name: '空亡', type: 'inauspicious' });
                }
            });
            
            // 检查魁罡（日柱干支组合）
            const dayPillar = pillars.day[0] + pillars.day[1];
            if (kuiGangList.includes(dayPillar)) {
                shensha.day.push({ name: '魁罡', type: 'neutral' });
            }
            
            // 天德贵人（基于月支查天干）
            const tianDeMap = {
                '正月': '丁', '二月': '申', '三月': '壬', '四月': '辛', '五月': '亥', '六月': '甲',
                '七月': '癸', '八月': '寅', '九月': '丙', '十月': '乙', '十一月': '巳', '十二月': '庚'
            };
            const currentMonthName = getMonthName(baziData.lunar.getMonth());
            if (currentMonthName && tianDeMap[currentMonthName]) {
                const tianDeStem = tianDeMap[currentMonthName];
                branches.forEach((branch, index) => {
                    const pillar = pillarsArray[index];
                    const stem = pillars[pillarsArray[index]][0];
                    if (stem === tianDeStem) {
                        shensha[pillar].push({ name: '天德贵人', type: 'auspicious' });
                    }
                });
            }
            
            // 月德贵人（基于月支查天干）
            const yueDeMap = {
                '寅': '丙', '卯': '甲', '辰': '壬', '巳': '庚', '午': '戊', '未': '丙',
                '申': '壬', '酉': '庚', '戌': '戊', '亥': '甲', '子': '壬', '丑': '庚'
            };
            if (yueDeMap[monthBranch]) {
                const yueDeStem = yueDeMap[monthBranch];
                branches.forEach((branch, index) => {
                    const pillar = pillarsArray[index];
                    const stem = pillars[pillarsArray[index]][0];
                    if (stem === yueDeStem) {
                        shensha[pillar].push({ name: '月德贵人', type: 'auspicious' });
                    }
                });
            }
            
            // 国印贵人（基于日主）
            const guoYinMap = {
                '甲': '戌', '乙': '亥', '丙': '丑', '丁': '寅', '戊': '丑',
                '己': '寅', '庚': '辰', '辛': '巳', '壬': '未', '癸': '申'
            };
            branches.forEach((branch, index) => {
                const pillar = pillarsArray[index];
                if (guoYinMap[dayMaster] === branch) {
                    shensha[pillar].push({ name: '国印贵人', type: 'auspicious' });
                }
            });
            
            // 金舆（基于日主）
            const jinYuMap = {
                '甲': '辰', '乙': '巳', '丙': '未', '丁': '申', '戊': '未',
                '己': '申', '庚': '戌', '辛': '亥', '壬': '丑', '癸': '寅'
            };
            branches.forEach((branch, index) => {
                const pillar = pillarsArray[index];
                if (jinYuMap[dayMaster] === branch) {
                    shensha[pillar].push({ name: '金舆', type: 'auspicious' });
                }
            });
            
            // 学堂（基于年支）
            const xueTangMap = {
                '寅': '亥', '卯': '申', '辰': '巳', '巳': '寅', '午': '亥', '未': '申',
                '申': '巳', '酉': '寅', '戌': '亥', '亥': '申', '子': '巳', '丑': '寅'
            };
            branches.forEach((branch, index) => {
                const pillar = pillarsArray[index];
                if (xueTangMap[yearBranch] === branch) {
                    shensha[pillar].push({ name: '学堂', type: 'auspicious' });
                }
            });
            
            // 词馆（基于年支）
            const ciGuanMap = {
                '寅': '丁', '卯': '戊', '辰': '辛', '巳': '庚', '午': '癸', '未': '壬',
                '申': '乙', '酉': '甲', '戌': '丁', '亥': '丙', '子': '己', '丑': '戊'
            };
            branches.forEach((branch, index) => {
                const pillar = pillarsArray[index];
                const stem = pillars[pillarsArray[index]][0];
                if (ciGuanMap[yearBranch] === stem) {
                    shensha[pillar].push({ name: '词馆', type: 'auspicious' });
                }
            });
            
            // 天罗地网（基于日主）
            const tianLuoDiWangMap = {
                '甲乙': ['戌', '辰'], '丙丁': ['戌', '辰'], '戊己': ['辰', '戌'],
                '庚辛': ['辰', '戌'], '壬癸': ['辰', '戌']
            };
            const dayMasterGroup = getStemGroup(dayMaster);
            if (dayMasterGroup && tianLuoDiWangMap[dayMasterGroup]) {
                branches.forEach((branch, index) => {
                    const pillar = pillarsArray[index];
                    if (tianLuoDiWangMap[dayMasterGroup].includes(branch)) {
                        if (branch === '戌') {
                            shensha[pillar].push({ name: '天罗', type: 'inauspicious' });
                        } else if (branch === '辰') {
                            shensha[pillar].push({ name: '地网', type: 'inauspicious' });
                        }
                    }
                });
            }
            
            return shensha;
        }
        
        function getDayBranchGroup(dayBranch) {
            if (['寅', '午', '戌'].includes(dayBranch)) return '寅午戌';
            if (['申', '子', '辰'].includes(dayBranch)) return '申子辰';
            if (['巳', '酉', '丑'].includes(dayBranch)) return '巳酉丑';
            if (['亥', '卯', '未'].includes(dayBranch)) return '亥卯未';
            return null;
        }
        
        function getStemGroup(stem) {
            if (['甲', '乙'].includes(stem)) return '甲乙';
            if (['丙', '丁'].includes(stem)) return '丙丁';
            if (['戊', '己'].includes(stem)) return '戊己';
            if (['庚', '辛'].includes(stem)) return '庚辛';
            if (['壬', '癸'].includes(stem)) return '壬癸';
            return null;
        }
        
        function getMonthName(month) {
            const monthNames = {
                1: '正月', 2: '二月', 3: '三月', 4: '四月',
                5: '五月', 6: '六月', 7: '七月', 8: '八月',
                9: '九月', 10: '十月', 11: '十一月', 12: '十二月'
            };
            return monthNames[month] || null;
        }
        
        function generateShenshaDisplay(pillars, baziData) {
            const shensha = calculateShensha(pillars, baziData);
            
            const getShenshaColor = (type) => {
                switch (type) {
                    case 'auspicious': return '#28a745'; // 绿色 - 吉神
                    case 'inauspicious': return '#dc3545'; // 红色 - 凶神
                    case 'neutral': return '#6c757d'; // 灰色 - 中性
                    default: return '#6c757d';
                }
            };
            
            const getShenshaIcon = (type) => {
                switch (type) {
                    case 'auspicious': return '✓';
                    case 'inauspicious': return '✗';
                    case 'neutral': return '◐';
                    default: return '◐';
                }
            };
            
            const pillarsArray = ['year', 'month', 'day', 'hour'];
            const pillarNames = ['年柱', '月柱', '日柱', '时柱'];
            
            let pillarsHtml = '';
            
            pillarsArray.forEach((pillar, index) => {
                const pillarShensha = shensha[pillar];
                let shenshaHtml = '';
                
                if (pillarShensha.length > 0) {
                    pillarShensha.forEach(item => {
                        const isAuspicious = item.type === 'auspicious';
                        shenshaHtml += `
                            <div class="shensha-tag" style="
                                display: inline-flex;
                                align-items: center;
                                gap: 4px;
                                margin: 3px;
                                padding: 6px 12px;
                                background: ${isAuspicious ? 'linear-gradient(135deg, #10b981, #059669)' : 'linear-gradient(135deg, #ef4444, #dc2626)'};
                                color: white;
                                border-radius: 20px;
                                font-size: 0.75em;
                                font-weight: 600;
                                box-shadow: 0 3px 8px ${isAuspicious ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)'};
                                transition: all 0.2s ease;
                                border: 1px solid ${isAuspicious ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)'};
                            " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 5px 15px ${isAuspicious ? 'rgba(16, 185, 129, 0.4)' : 'rgba(239, 68, 68, 0.4)'}'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 8px ${isAuspicious ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)'}'">
                                <span class="shensha-icon" style="font-size: 1.1em;">${getShenshaIcon(item.type)}</span>
                                <span class="shensha-name">${item.name}</span>
                            </div>
                        `;
                    });
                } else {
                    shenshaHtml = `
                        <div style="
                            color: #94a3b8;
                            font-size: 0.85em;
                            text-align: center;
                            padding: 15px;
                            background: linear-gradient(135deg, rgba(148, 163, 184, 0.1), rgba(203, 213, 225, 0.05));
                            border-radius: 12px;
                            border: 1px dashed rgba(148, 163, 184, 0.3);
                            font-style: italic;
                        ">
                            <span style="font-size: 1.2em; margin-right: 5px;">🌙</span>
                            暂无神煞
                        </div>
                    `;
                }
                
                // 为每个柱子定义不同的主题色彩
                const pillarThemes = [
                    {
                        gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                        shadow: 'rgba(102, 126, 234, 0.3)',
                        icon: '🌸',
                        accent: '#667eea'
                    }, // 年柱 - 优雅紫蓝
                    {
                        gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                        shadow: 'rgba(240, 147, 251, 0.3)',
                        icon: '🌿',
                        accent: '#f093fb'
                    }, // 月柱 - 粉紫渐变
                    {
                        gradient: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                        shadow: 'rgba(79, 172, 254, 0.3)',
                        icon: '☀️',
                        accent: '#4facfe'
                    }, // 日柱 - 清新蓝色
                    {
                        gradient: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                        shadow: 'rgba(67, 233, 123, 0.3)',
                        icon: '⭐',
                        accent: '#43e97b'
                    }  // 时柱 - 青绿渐变
                ];
                
                const theme = pillarThemes[index];
                
                pillarsHtml += `
                    <div style="
                        background: white;
                        border-radius: 20px;
                        padding: 0;
                        border: 2px solid transparent;
                        background-clip: padding-box;
                        box-shadow: 0 10px 30px ${theme.shadow}, 0 4px 15px rgba(0,0,0,0.1);
                        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                        position: relative;
                        overflow: hidden;
                    " onmouseover="this.style.transform='translateY(-8px) scale(1.03)'; this.style.boxShadow='0 20px 50px ${theme.shadow}, 0 8px 25px rgba(0,0,0,0.15)'" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 10px 30px ${theme.shadow}, 0 4px 15px rgba(0,0,0,0.1)'">
                        <!-- 顶部装饰条 -->
                        <div style="
                            background: ${theme.gradient};
                            height: 6px;
                            width: 100%;
                            border-radius: 20px 20px 0 0;
                        "></div>
                        
                        <!-- 卡片头部 -->
                        <div class="shensha-card-header" style="
                            padding: 20px 20px 15px 20px;
                            text-align: center;
                            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(248,250,252,0.8));
                        ">
                            <div class="shensha-card-title" style="
                                display: inline-flex;
                                align-items: center;
                                gap: 8px;
                                font-weight: 700;
                                color: #1a202c;
                                font-size: 1.3em;
                                margin-bottom: 8px;
                            ">
                                <span style="font-size: 1.2em;">${theme.icon}</span>
                                ${pillarNames[index]}
                            </div>
                            <div style="
                                height: 3px;
                                width: 40px;
                                background: ${theme.gradient};
                                margin: 0 auto;
                                border-radius: 2px;
                            "></div>
                        </div>
                        
                        <!-- 神煞内容区域 -->
                        <div class="shensha-card-content" style="
                            padding: 15px 20px 25px 20px;
                            min-height: 80px;
                            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(248,250,252,0.9));
                        ">
                            ${shenshaHtml}
                        </div>
                    </div>
                `;
            });
            
            return `
                <div class="shensha-grid" style="
                    display: grid; 
                    grid-template-columns: repeat(4, 1fr); 
                    gap: 20px; 
                    margin-bottom: 20px;
                ">
                    ${pillarsHtml}
                </div>
                <style>
                    /* 命格神煞移动端响应式优化 */
                    @media (max-width: 768px) {
                        .shensha-grid {
                            grid-template-columns: repeat(2, 1fr) !important;
                            gap: 15px !important;
                        }
                    }
                    
                    @media (max-width: 480px) {
                         .shensha-grid {
                             grid-template-columns: 1fr !important;
                             gap: 12px !important;
                         }
                     }
                     
                     /* 神煞卡片移动端优化 */
                     @media (max-width: 768px) {
                         .shensha-card-header {
                             padding: 15px 15px 12px 15px !important;
                         }
                         
                         .shensha-card-title {
                             font-size: 1.1em !important;
                             gap: 6px !important;
                         }
                         
                         .shensha-card-content {
                             padding: 12px 15px 18px 15px !important;
                             min-height: 60px !important;
                         }
                     }
                     
                     @media (max-width: 480px) {
                         .shensha-card-header {
                             padding: 12px 12px 10px 12px !important;
                         }
                         
                         .shensha-card-title {
                             font-size: 1.0em !important;
                             gap: 4px !important;
                             margin-bottom: 6px !important;
                         }
                         
                         .shensha-card-content {
                              padding: 10px 12px 15px 12px !important;
                              min-height: 50px !important;
                          }
                      }
                      
                      /* 神煞标签移动端优化 */
                      @media (max-width: 768px) {
                          .shensha-tag {
                              margin: 2px !important;
                              padding: 5px 10px !important;
                              font-size: 0.7em !important;
                              gap: 3px !important;
                          }
                          
                          .shensha-icon {
                              font-size: 1.0em !important;
                          }
                      }
                      
                      @media (max-width: 480px) {
                          .shensha-tag {
                              margin: 1px !important;
                              padding: 4px 8px !important;
                              font-size: 0.65em !important;
                              gap: 2px !important;
                              border-radius: 15px !important;
                          }
                          
                          .shensha-icon {
                              font-size: 0.9em !important;
                          }
                          
                          .shensha-name {
                              white-space: nowrap;
                              overflow: hidden;
                              text-overflow: ellipsis;
                              max-width: 60px;
                          }
                      }
                  </style>
                <div style="
                    margin-top: 20px;
                    padding: 15px 20px;
                    background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(248,250,252,0.8));
                    border-radius: 15px;
                    border: 1px solid rgba(203, 213, 225, 0.3);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
                ">
                    <div style="
                        display: flex;
                        align-items: center;
                        gap: 25px;
                        justify-content: center;
                        font-size: 0.9em;
                        font-weight: 500;
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            color: #059669;
                        ">
                            <span style="
                                display: inline-flex;
                                align-items: center;
                                justify-content: center;
                                width: 20px;
                                height: 20px;
                                background: linear-gradient(135deg, #10b981, #059669);
                                color: white;
                                border-radius: 50%;
                                font-size: 0.8em;
                                font-weight: 600;
                            ">✓</span>
                            <span>吉神</span>
                        </div>
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            color: #dc2626;
                        ">
                            <span style="
                                display: inline-flex;
                                align-items: center;
                                justify-content: center;
                                width: 20px;
                                height: 20px;
                                background: linear-gradient(135deg, #ef4444, #dc2626);
                                color: white;
                                border-radius: 50%;
                                font-size: 0.8em;
                                font-weight: 600;
                            ">✗</span>
                            <span>凶神</span>
                        </div>
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            color: #6b7280;
                        ">
                            <span style="
                                display: inline-flex;
                                align-items: center;
                                justify-content: center;
                                width: 20px;
                                height: 20px;
                                background: linear-gradient(135deg, #9ca3af, #6b7280);
                                color: white;
                                border-radius: 50%;
                                font-size: 0.8em;
                                font-weight: 600;
                            ">◐</span>
                            <span>中性</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // 获取五行名称
        function getElementName(stem) {
            const elementMap = {
                '甲': '木', '乙': '木',
                '丙': '火', '丁': '火',
                '戊': '土', '己': '土',
                '庚': '金', '辛': '金',
                '壬': '水', '癸': '水'
            };
            return elementMap[stem] || '';
        }

        // 特殊格局检测函数
        function detectSpecialPattern(pillars, baziData) {
            try {
                const yearStem = pillars.year.charAt(0), yearBranch = pillars.year.charAt(1);
                const monthStem = pillars.month.charAt(0), monthBranch = pillars.month.charAt(1);
                const dayStem = pillars.day.charAt(0), dayBranch = pillars.day.charAt(1);
                const timeStem = pillars.hour.charAt(0), timeBranch = pillars.hour.charAt(1);
                
                const stems = [yearStem, monthStem, dayStem, timeStem];
                const branches = [yearBranch, monthBranch, dayBranch, timeBranch];
                
                // 1. 检测从格类
                const congPattern = detectCongPattern(stems, branches, dayStem);
                if (congPattern) return congPattern;
                
                // 2. 检测专旺格
                const zhuanwangPattern = detectZhuanwangPattern(stems, branches, dayStem);
                if (zhuanwangPattern) return zhuanwangPattern;
                
                // 3. 检测化气格
                const huaqiPattern = detectHuaqiPattern(stems, branches, dayStem, monthBranch);
                if (huaqiPattern) return huaqiPattern;
                
                // 4. 检测贵人格局
                const guirenPattern = detectGuirenPattern(stems, branches, dayStem, dayBranch);
                if (guirenPattern) return guirenPattern;
                
                // 5. 检测禄马格局
                const lumaPattern = detectLumaPattern(stems, branches, dayStem, dayBranch);
                if (lumaPattern) return lumaPattern;
                
                // 6. 检测特殊日时格局
                const specialDayPattern = detectSpecialDayPattern(dayStem, dayBranch, timeStem, timeBranch);
                if (specialDayPattern) return specialDayPattern;
                
                // 7. 检测神煞格局
                const shenshaPattern = detectShenshaPattern(stems, branches, dayStem, dayBranch);
                if (shenshaPattern) return shenshaPattern;
                
                return null; // 无特殊格局
            } catch (error) {
                console.error('特殊格局检测出错:', error);
                return null;
            }
        }
        
        // 检测从格类
        function detectCongPattern(stems, branches, dayStem) {
            // 直接调用现有的身强身弱分析结果，不重新计算
            console.log('=== 从格检测调试信息（使用现有身强身弱分析）===');
            console.log('八字:', stems.join(''), branches.join(''));
            console.log('日干:', dayStem);
            
            // 优先使用全局的身强身弱分析结果
            let strengthAnalysis = null;
            
            // 尝试从全局变量获取身强身弱分析结果
            if (window.currentBaziData && window.currentBaziData.strengthAnalysis) {
                strengthAnalysis = window.currentBaziData.strengthAnalysis;
                console.log('使用全局身强身弱分析结果:', strengthAnalysis);
                console.log('strengthAnalysis.type:', strengthAnalysis.type);
                console.log('strengthAnalysis.strengthType:', strengthAnalysis.strengthType);
            } else if (window.strengthAnalysisResult) {
                strengthAnalysis = window.strengthAnalysisResult;
                console.log('使用全局strengthAnalysisResult:', strengthAnalysis);
                console.log('strengthAnalysisResult.type:', strengthAnalysis.type);
                console.log('strengthAnalysisResult.strengthType:', strengthAnalysis.strengthType);
            } else {
                // 如果没有现成的结果，临时计算一次
                console.log('未找到现有身强身弱分析结果，进行临时计算');
                const dayElement = getElementFromStem(dayStem);
                const elementCounts = countElements(stems, branches);
                const monthBranch = branches[1]; // 月支
                
                try {
                    strengthAnalysis = calculateStrength(dayStem, elementCounts, monthBranch, branches, stems);
                    console.log('临时计算的身强身弱分析结果:', strengthAnalysis);
                } catch (error) {
                    console.error('临时计算身强身弱失败:', error);
                    return null;
                }
            }
            
            if (!strengthAnalysis) {
                console.log('无法获取身强身弱分析结果');
                return null;
            }
            
            const strengthType = strengthAnalysis.type;
            console.log('身强身弱类型:', strengthType);
            
            // 根据身强身弱分析结果判断从格
            if (strengthType === '从强' || strengthType === '极强（从强）') {
                console.log('判断结果: 从强格（基于身强身弱分析）');
                return '从强格';
            }
            
            if (strengthType === '从弱' || strengthType === '极弱（从弱）' || strengthType.includes('从弱')) {
                // 从弱格需要进一步细分为从财格、从杀格、从儿格等
                const dayElement = getElementFromStem(dayStem);
                const elementCounts = countElements(stems, branches);
                const dominantElement = Object.keys(elementCounts).reduce((a, b) => 
                    elementCounts[a] > elementCounts[b] ? a : b);
                
                console.log('日主五行:', dayElement, '主导五行:', dominantElement);
                
                // 从财格：财星力量最强（日主克的五行为财星）
                if ((dayElement === 'wood' && dominantElement === 'earth') ||
                    (dayElement === 'fire' && dominantElement === 'metal') ||
                    (dayElement === 'earth' && dominantElement === 'water') ||
                    (dayElement === 'metal' && dominantElement === 'wood') ||
                    (dayElement === 'water' && dominantElement === 'fire')) {
                    console.log('判断结果: 从财格（基于身强身弱分析）');
                    return '从财格';
                }
                
                // 从官杀格：克日主的五行为官杀
                if ((dayElement === 'wood' && dominantElement === 'metal') ||
                    (dayElement === 'fire' && dominantElement === 'water') ||
                    (dayElement === 'earth' && dominantElement === 'wood') ||
                    (dayElement === 'metal' && dominantElement === 'fire') ||
                    (dayElement === 'water' && dominantElement === 'earth')) {
                    console.log('判断结果: 从杀格（基于身强身弱分析）');
                    return '从杀格';
                }
                
                // 从食伤格：日主生的五行为食伤
                if ((dayElement === 'wood' && dominantElement === 'fire') ||
                    (dayElement === 'fire' && dominantElement === 'earth') ||
                    (dayElement === 'earth' && dominantElement === 'metal') ||
                    (dayElement === 'metal' && dominantElement === 'water') ||
                    (dayElement === 'water' && dominantElement === 'wood')) {
                    console.log('判断结果: 从儿格（基于身强身弱分析）');
                    return '从儿格';
                }
                
                // 其他从格（按主导五行命名）
                const elementNames = {
                    'wood': '从木格',
                    'fire': '从火格', 
                    'earth': '从土格',
                    'metal': '从金格',
                    'water': '从水格'
                };
                
                if (elementNames[dominantElement]) {
                    console.log('判断结果:', elementNames[dominantElement], '（基于身强身弱分析）');
                    return elementNames[dominantElement];
                }
                
                console.log('判断结果: 从弱格（基于身强身弱分析）');
                return '从弱格';
            }
            
            console.log('判断结果: 无特殊格局（基于身强身弱分析）');
            console.log('========================');
            return null;
        }
        
        // 检测专旺格
        function detectZhuanwangPattern(stems, branches, dayStem) {
            const dayElement = getElementFromStem(dayStem);
            const elementCounts = countElements(stems, branches);
            const totalStrength = Object.values(elementCounts).reduce((sum, val) => sum + val, 0);
            
            // 某一五行力量占90%以上
            for (const [element, strength] of Object.entries(elementCounts)) {
                if (strength / totalStrength >= 0.9) {
                    if (element === 'wood') return '曲直格';
                    if (element === 'fire') return '炎上格';
                    if (element === 'earth') return '稼穑格';
                    if (element === 'metal') return '从革格';
                    if (element === 'water') return '润下格';
                }
            }
            
            return null;
        }
        
        // 检测化气格
        function detectHuaqiPattern(stems, branches, dayStem, monthBranch) {
            const hehuaPairs = {
                '甲己': '土', '乙庚': '金', '丙辛': '水', '丁壬': '木', '戊癸': '火'
            };
            
            // 检查日干与其他天干的合化
            for (let i = 0; i < stems.length; i++) {
                if (i === 2) continue; // 跳过日干自己
                const pair1 = dayStem + stems[i];
                const pair2 = stems[i] + dayStem;
                
                if (hehuaPairs[pair1] || hehuaPairs[pair2]) {
                    const hehuaElement = hehuaPairs[pair1] || hehuaPairs[pair2];
                    // 检查月令是否支持化气
                    if (isSeasonSupport(hehuaElement, monthBranch)) {
                        return `${pair1 || pair2}化${getElementChinese(hehuaElement)}格`;
                    }
                }
            }
            
            return null;
        }
        
        // 检测贵人格局
        function detectGuirenPattern(stems, branches, dayStem, dayBranch) {
            // 日贵格
            const dayNobles = {
                '甲': ['丑', '未'], '戊': ['丑', '未'],
                '乙': ['子', '申'], '己': ['子', '申'],
                '丙': ['亥', '酉'], '丁': ['亥', '酉'],
                '庚': ['丑', '未'], '辛': ['寅', '午'],
                '壬': ['卯', '巳'], '癸': ['卯', '巳']
            };
            
            if (dayNobles[dayStem] && dayNobles[dayStem].includes(dayBranch)) {
                return '日贵格';
            }
            
            // 三奇贵人格
            const stemsStr = stems.join('');
            if (stemsStr.includes('甲戊庚') || stemsStr.includes('乙丙丁') || stemsStr.includes('壬癸辛')) {
                return '三奇贵人格';
            }
            
            return null;
        }
        
        // 检测禄马格局
        function detectLumaPattern(stems, branches, dayStem, dayBranch) {
            // 建禄格
            const luPositions = {
                '甲': '寅', '乙': '卯', '丙': '巳', '丁': '午',
                '戊': '巳', '己': '午', '庚': '申', '辛': '酉',
                '壬': '亥', '癸': '子'
            };
            
            if (luPositions[dayStem] === dayBranch) {
                return '建禄格';
            }
            
            // 禄元互换格
            const yearStem = stems[0], monthStem = stems[1], timeStem = stems[3];
            if ((luPositions[dayStem] === branches[0] && luPositions[yearStem] === dayBranch) ||
                (luPositions[dayStem] === branches[1] && luPositions[monthStem] === dayBranch) ||
                (luPositions[dayStem] === branches[3] && luPositions[timeStem] === dayBranch)) {
                return '禄元互换格';
            }
            
            return null;
        }
        
        // 检测特殊日时格局
        function detectSpecialDayPattern(dayStem, dayBranch, timeStem, timeBranch) {
            // 天元一气格
            if (dayStem === timeStem && dayBranch === timeBranch) {
                return '天元一气格';
            }
            
            // 魁罡格
            const kuigangDays = ['庚戌', '庚辰', '戊戌', '壬辰'];
            if (kuigangDays.includes(dayStem + dayBranch)) {
                return '魁罡格';
            }
            
            return null;
        }
        
        // 检测神煞格局
        function detectShenshaPattern(stems, branches, dayStem, dayBranch) {
            // 金神格
            const jinShenCombos = ['乙丑', '己巳', '癸酉'];
            for (let i = 0; i < stems.length; i++) {
                if (jinShenCombos.includes(stems[i] + branches[i])) {
                    return '金神格';
                }
            }
            
            return null;
        }
        
        // 辅助函数：获取天干对应的五行
        function getElementFromStem(stem) {
            const elementMap = {
                '甲': 'wood', '乙': 'wood',
                '丙': 'fire', '丁': 'fire',
                '戊': 'earth', '己': 'earth',
                '庚': 'metal', '辛': 'metal',
                '壬': 'water', '癸': 'water'
            };
            return elementMap[stem];
        }
        
        // 辅助函数：统计五行力量
        function countElements(stems, branches) {
            const counts = { wood: 0, fire: 0, earth: 0, metal: 0, water: 0 };
            
            // 统计天干
            stems.forEach(stem => {
                const element = getElementFromStem(stem);
                if (element) counts[element] += 1;
            });
            
            // 统计地支（简化版）
            const branchElements = {
                '子': 'water', '丑': 'earth', '寅': 'wood', '卯': 'wood',
                '辰': 'earth', '巳': 'fire', '午': 'fire', '未': 'earth',
                '申': 'metal', '酉': 'metal', '戌': 'earth', '亥': 'water'
            };
            
            branches.forEach(branch => {
                const element = branchElements[branch];
                if (element) counts[element] += 1;
            });
            
            return counts;
        }
        
        // 辅助函数：获取支持日主的五行
        function getSupportElements(dayElement) {
            const supportMap = {
                'wood': ['wood', 'water'],
                'fire': ['fire', 'wood'],
                'earth': ['earth', 'fire'],
                'metal': ['metal', 'earth'],
                'water': ['water', 'metal']
            };
            return supportMap[dayElement] || [];
        }
        
        // 辅助函数：检查季节是否支持化气
        function isSeasonSupport(element, monthBranch) {
            const seasonMap = {
                'wood': ['寅', '卯', '辰'],
                'fire': ['巳', '午', '未'],
                'earth': ['辰', '戌', '丑', '未'],
                'metal': ['申', '酉', '戌'],
                'water': ['亥', '子', '丑']
            };
            return seasonMap[element] && seasonMap[element].includes(monthBranch);
        }
        
        // 辅助函数：获取五行中文名称
        function getElementChinese(element) {
            const names = {
                'wood': '木', 'fire': '火', 'earth': '土', 'metal': '金', 'water': '水'
            };
            return names[element] || element;
        }

        // 显示五行图表（双图表版本）
        function displayElementsChart(baziData) {
            // 显示原命局五行分布
            displayOriginalElementsChart(baziData.elements);
            
            // 计算并显示当前五行分布（包含大运流年）
            const currentYear = new Date().getFullYear();
            const currentElements = calculateCurrentElements(baziData.elements, currentYear);
            displayCurrentElementsChart(currentElements, currentYear);
        }
        
        // 显示原命局五行分布图表
        function displayOriginalElementsChart(elements) {
            // 添加调试信息，查看接收到的数据
            console.log('=== displayOriginalElementsChart 接收到的数据 ===');
            console.log('elements 参数:', elements);
            const elementsTotal = Object.values(elements || {}).reduce((sum, val) => sum + (val || 0), 0);
            console.log('elements 总和:', elementsTotal);
            console.log('===============================================');
            
            // 检查 elements 参数是否有效
            if (!elements || typeof elements !== 'object') {
                console.error('displayOriginalElementsChart: elements 参数无效:', elements);
                const description = document.getElementById('elements-description');
                if (description) {
                    description.innerHTML = `
                        <div style="background-color: #f8d7da; padding: 15px; border-radius: 8px; border: 1px solid #f5c6cb; color: #721c24;">
                            <p><i class="fas fa-exclamation-triangle"></i> 五行数据无效，无法显示原命局五行分布。</p>
                        </div>
                    `;
                }
                return;
            }
            
            // 检查五行属性是否存在
            const requiredElements = ['wood', 'fire', 'earth', 'metal', 'water'];
            for (const element of requiredElements) {
                if (typeof elements[element] !== 'number') {
                    console.error(`displayOriginalElementsChart: 缺少或无效的五行属性 ${element}:`, elements[element]);
                    const description = document.getElementById('elements-description');
                    if (description) {
                        description.innerHTML = `
                            <div style="background-color: #f8d7da; padding: 15px; border-radius: 8px; border: 1px solid #f5c6cb; color: #721c24;">
                                <p><i class="fas fa-exclamation-triangle"></i> 五行数据结构不完整，缺少 ${element} 属性。</p>
                            </div>
                        `;
                    }
                    return;
                }
            }
            
            const ctx = document.getElementById('original-elements-chart').getContext('2d');
            
            if (window.originalElementsChart) {
                window.originalElementsChart.destroy();
            }
            
            // 增强的五行颜色 - 更专业的配色方案
            const elementColors = {
                wood: {
                    main: '#2ecc71',
                    light: 'rgba(46, 204, 113, 0.8)',
                    border: 'rgba(46, 204, 113, 1)',
                    gradient: ['rgba(46, 204, 113, 0.9)', 'rgba(39, 174, 96, 0.9)']
                },
                fire: {
                    main: '#e74c3c',
                    light: 'rgba(231, 76, 60, 0.8)',
                    border: 'rgba(231, 76, 60, 1)',
                    gradient: ['rgba(231, 76, 60, 0.9)', 'rgba(192, 57, 43, 0.9)']
                },
                earth: {
                    main: '#f39c12',
                    light: 'rgba(243, 156, 18, 0.8)',
                    border: 'rgba(243, 156, 18, 1)',
                    gradient: ['rgba(243, 156, 18, 0.9)', 'rgba(211, 84, 0, 0.9)']
                },
                metal: {
                    main: '#95a5a6',
                    light: 'rgba(149, 165, 166, 0.8)',
                    border: 'rgba(149, 165, 166, 1)',
                    gradient: ['rgba(149, 165, 166, 0.9)', 'rgba(127, 140, 141, 0.9)']
                },
                water: {
                    main: '#3498db',
                    light: 'rgba(52, 152, 219, 0.8)',
                    border: 'rgba(52, 152, 219, 1)',
                    gradient: ['rgba(52, 152, 219, 0.9)', 'rgba(41, 128, 185, 0.9)']
                }
            };
            
            // 注册Chart.js插件
            Chart.register(ChartDataLabels);
            
            // 计算总分
            const total = Object.values(elements).reduce((sum, val) => sum + val, 0);
            
            // 创建渐变背景
            const createGradient = (ctx, colors) => {
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, colors[0]);
                gradient.addColorStop(1, colors[1]);
                return gradient;
            };
            
            // 调试传递给Chart.js的数据
            const chartData = [elements.wood, elements.fire, elements.earth, elements.metal, elements.water];
            console.log('=== 传递给Chart.js的数据调试 ===');
            console.log('chartData:', chartData);
            console.log('chartData 各元素类型:', chartData.map(v => `${v} (${typeof v})`));
            console.log('elements对象:', elements);
            console.log('================================');
            
            // 创建原命局五行雷达图
            window.originalElementsChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['木', '火', '土', '金', '水'],
                    datasets: [{
                        label: '原命局五行力量',
                        data: chartData,
                        backgroundColor: [
                            elementColors.wood.light,
                            elementColors.fire.light,
                            elementColors.earth.light,
                            elementColors.metal.light,
                            elementColors.water.light
                        ],
                        borderColor: [
                            elementColors.wood.border,
                            elementColors.fire.border,
                            elementColors.earth.border,
                            elementColors.metal.border,
                            elementColors.water.border
                        ],
                        borderWidth: 3,
                        pointBackgroundColor: [
                            elementColors.wood.main,
                            elementColors.fire.main,
                            elementColors.earth.main,
                            elementColors.metal.main,
                            elementColors.water.main
                        ],
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointHoverBackgroundColor: [
                            elementColors.wood.light,
                            elementColors.fire.light,
                            elementColors.earth.light,
                            elementColors.metal.light,
                            elementColors.water.light
                        ],
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)',
                                lineWidth: 1
                            },
                            angleLines: {
                                color: 'rgba(0, 0, 0, 0.1)',
                                lineWidth: 1
                            },
                            pointLabels: {
                                font: {
                                    size: 16,
                                    weight: 'bold',
                                    family: "'Noto Serif SC', serif"
                                },
                                color: '#333'
                            },
                            ticks: {
                                display: true,
                                font: {
                                    size: 12,
                                    family: "'Noto Serif SC', serif"
                                },
                                color: '#666',
                                backdropColor: 'rgba(255, 255, 255, 0.8)',
                                backdropPadding: 2
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            titleColor: '#333',
                            bodyColor: '#333',
                            borderColor: '#ddd',
                            borderWidth: 1,
                            cornerRadius: 10,
                            padding: 15,
                            boxPadding: 8,
                            titleFont: {
                                size: 16,
                                weight: 'bold',
                                family: "'Noto Serif SC', serif"
                            },
                            bodyFont: {
                                size: 14,
                                family: "'Noto Serif SC', serif"
                            },
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                    const percentage = ((context.parsed.r / total) * 100).toFixed(2);
                                    return `${context.label}: ${context.parsed.r}点 (${percentage}%)`;
                                }
                            }
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    animation: {
                        duration: 2000,
                        easing: 'easeOutQuart'
                    }
                }
            });
            
            // 显示原命局五行概览
            const originalSummary = document.getElementById('original-elements-summary');
            const strongest = Object.keys(elements).reduce((a, b) => elements[a] > elements[b] ? a : b);
            const weakest = Object.keys(elements).reduce((a, b) => elements[a] < elements[b] ? a : b);
            
            // 获取第二强和第二弱的五行
            const sortedElements = Object.entries(elements).sort((a, b) => b[1] - a[1]);
            const secondStrongest = sortedElements[1][0];
            const secondWeakest = sortedElements[3][0];
            
            const elementNames = {
                wood: '木', fire: '火', earth: '土', metal: '金', water: '水'
            };
            
            // 中文五行名称到英文键名的映射
            const chineseToEnglishMap = {
                '木': 'wood', '火': 'fire', '土': 'earth', '金': 'metal', '水': 'water'
            };
            
            // strongest 和 weakest 已经是英文键名，直接使用
            const strongestKey = strongest;
            const weakestKey = weakest;
            const secondStrongestKey = secondStrongest;
            const secondWeakestKey = secondWeakest;
            
            // 增强的五行特性
            const elementProperties = {
                wood: {
                    nature: '生长、向上、扩展',
                    character: '仁爱、正直、进取、创新、灵活、善变',
                    career: '教育、文化、艺术、法律、环保、植物相关行业、创意设计、新兴产业',
                    health: '肝胆系统、眼睛、肌腱、神经、头部',
                    favorable: '东方、绿色环境、春季、清晨',
                    icon: 'fa-tree',
                    personality: '思维活跃，创新能力强，善于规划，有远见，但可能缺乏耐心，情绪波动较大',
                    career_detail: '适合需要创造力和变革的工作，不适合固定模式的工作',
                    health_advice: '注意情绪管理，避免过度紧张和压力，保持规律作息，多做舒缓运动'
                },
                fire: {
                    nature: '上升、扩张、热烈',
                    character: '热情、活力、直觉、表达力强、乐观、冲动',
                    career: '娱乐、餐饮、照明、能源、传媒、营销、表演、公关',
                    health: '心脏、血液循环、眼睛、面部、小肠',
                    favorable: '南方、阳光充足环境、夏季、中午',
                    icon: 'fa-fire',
                    personality: '热情洋溢，富有感染力，直觉敏锐，善于表达，但可能冲动，缺乏耐心',
                    career_detail: '适合需要热情和表现力的工作，不适合需要冷静分析的工作',
                    health_advice: '注意心脏健康，避免情绪过度激动，保持充足睡眠，适当控制饮食'
                },
                earth: {
                    nature: '稳定、中和、包容',
                    character: '踏实、稳重、包容、忠诚、保守、固执',
                    career: '房地产、农业、食品、保险、服务业、医疗、教育、行政管理',
                    health: '脾胃、消化系统、肌肉、口腔',
                    favorable: '中央位置、黄色环境、季节交替时期、下午',
                    icon: 'fa-mountain',
                    personality: '稳重踏实，责任感强，忠诚可靠，但可能固执，缺乏变通',
                    career_detail: '适合需要耐心和稳定的工作，不适合需要频繁变动的工作',
                    health_advice: '注意消化系统健康，保持规律饮食，避免过度思虑，适当运动'
                },
                metal: {
                    nature: '收敛、向内、坚硬',
                    character: '果断、公正、条理、自律、理性、刚毅',
                    career: '金融、IT、机械、汽车、珠宝、军警、法律、精密工业',
                    health: '肺部、大肠、皮肤、鼻子、呼吸系统',
                    favorable: '西方、白色环境、秋季、傍晚',
                    icon: 'fa-coins',
                    personality: '条理分明，做事果断，公正严明，但可能过于刚硬，缺乏柔性',
                    career_detail: '适合需要精确和规范的工作，不适合需要灵活变通的工作',
                    health_advice: '注意呼吸系统健康，保持环境清洁，避免过度压抑情绪，适当放松'
                },
                water: {
                    nature: '向下、流动、适应',
                    character: '智慧、灵活、交际、适应力强、深沉、多变',
                    career: '贸易、运输、旅游、水产、外交、销售、咨询、信息传播',
                    health: '肾脏、膀胱、耳朵、骨骼、生殖系统',
                    favorable: '北方、水域环境、冬季、夜晚',
                    icon: 'fa-water',
                    personality: '思维灵活，适应力强，善于沟通，但可能多虑，缺乏决断',
                    career_detail: '适合需要交流和变通的工作，不适合固定模式的工作',
                    health_advice: '注意肾脏健康，保持充足睡眠，避免过度疲劳，保持水分摄入'
                }
            };
            
            // 计算五行平衡度
            const avg = total / 5;
            const deviation = Object.values(elements).reduce((sum, val) => sum + Math.abs(val - avg), 0) / total;
            const balancePercentage = (1 - deviation) * 100;
            let balanceLevel;
            if (balancePercentage >= 85) balanceLevel = '极佳';
            else if (balancePercentage >= 70) balanceLevel = '良好';
            else if (balancePercentage >= 50) balanceLevel = '一般';
            else balanceLevel = '失衡';
            
            // 显示原命局五行分布概览
            originalSummary.innerHTML = `
                <div style="background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(240,240,240,0.7)); padding: 12px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.06);">
                    <div style="margin-bottom: 8px; font-size: 0.85rem;">
                        <span style="color: #2e7d32; font-weight: bold;">原命局：</span>
                        <span style="color: #1976d2;">先天五行分布</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; flex-wrap: wrap; margin-bottom: 8px;">
                        <div style="min-width: 100px; margin-bottom: 4px; font-size: 0.85rem;">
                            <span style="font-weight: bold; color: ${elementColors[strongestKey].main};">最强：</span>
                            <span style="background: ${elementColors[strongestKey].light}; padding: 2px 6px; border-radius: 12px; color: #fff; font-weight: bold; font-size: 0.8rem;">
                                ${elementNames[strongest]} ${((elements[strongest]/total)*100).toFixed(1)}%
                            </span>
                        </div>
                        <div style="min-width: 100px; margin-bottom: 4px; font-size: 0.85rem;">
                            <span style="font-weight: bold; color: ${elementColors[weakestKey].main};">最弱：</span>
                            <span style="background: ${elementColors[weakestKey].light}; padding: 2px 6px; border-radius: 12px; color: #fff; font-weight: bold; font-size: 0.8rem;">
                                ${elementNames[weakest]} ${((elements[weakest]/total)*100).toFixed(1)}%
                            </span>
                        </div>
                    </div>
                    <div style="font-size: 0.8rem; line-height: 1.4;">
                        <span style="color: #2c3e50;">五行分布：</span>
                        <span style="color: ${elementColors.wood.main};">木${elements.wood.toFixed(1)}</span> |
                        <span style="color: ${elementColors.fire.main};">火${elements.fire.toFixed(1)}</span> |
                        <span style="color: ${elementColors.earth.main};">土${elements.earth.toFixed(1)}</span> |
                        <span style="color: ${elementColors.metal.main};">金${elements.metal.toFixed(1)}</span> |
                        <span style="color: ${elementColors.water.main};">水${elements.water.toFixed(1)}</span>
                    </div>
                </div>
            `;
        }
        
        // 计算当前五行分布（包含大运流年）
        function calculateCurrentElements(originalElements, currentYear) {
            try {
                // 获取当前流年干支
                const today = new Date();
                const currentLunar = Lunar.fromDate(today);
                const currentYearGanZhi = currentLunar.getYearInGanZhi();
                const currentYearStem = currentYearGanZhi.charAt(0);
                const currentYearBranch = currentYearGanZhi.charAt(1);
                
                // 获取当前大运信息
                let currentDayunStem = '';
                let currentDayunBranch = '';
                
                try {
                    const currentDayunInfo = getCurrentDayun();
                    if (currentDayunInfo && currentDayunInfo.ganZhi && currentDayunInfo.ganZhi !== '未知' && currentDayunInfo.ganZhi !== '计算错误') {
                        currentDayunStem = currentDayunInfo.ganZhi.charAt(0);
                        currentDayunBranch = currentDayunInfo.ganZhi.charAt(1);
                    }
                } catch (e) {
                    console.log('获取大运信息失败:', e);
                }
                
                // 复制原始五行分布
                const currentElements = { ...originalElements };
                
                // 获取天干地支对应的五行
                const stemElementMap = {
                    '甲': 'wood', '乙': 'wood',
                    '丙': 'fire', '丁': 'fire',
                    '戊': 'earth', '己': 'earth',
                    '庚': 'metal', '辛': 'metal',
                    '壬': 'water', '癸': 'water'
                };
                
                const branchElementMap = {
                    '子': 'water', '丑': 'earth', '寅': 'wood', '卯': 'wood',
                    '辰': 'earth', '巳': 'fire', '午': 'fire', '未': 'earth',
                    '申': 'metal', '酉': 'metal', '戌': 'earth', '亥': 'water'
                };
                
                // 加入流年天干地支的五行力量
                const yearStemElement = stemElementMap[currentYearStem];
                const yearBranchElement = branchElementMap[currentYearBranch];
                
                if (yearStemElement) {
                    currentElements[yearStemElement] += 1.5; // 流年天干权重
                }
                if (yearBranchElement) {
                    currentElements[yearBranchElement] += 2.0; // 流年地支权重
                }
                
                // 加入大运天干地支的五行力量
                const dayunStemElement = stemElementMap[currentDayunStem];
                const dayunBranchElement = branchElementMap[currentDayunBranch];
                
                if (dayunStemElement) {
                    currentElements[dayunStemElement] += 1.2; // 大运天干权重
                }
                if (dayunBranchElement) {
                    currentElements[dayunBranchElement] += 1.8; // 大运地支权重
                }
                
                return {
                    elements: currentElements,
                    yearGanZhi: currentYearGanZhi,
                    dayunGanZhi: currentDayunStem + currentDayunBranch
                };
            } catch (error) {
                console.error('计算当前五行分布失败:', error);
                return {
                    elements: originalElements,
                    yearGanZhi: '',
                    dayunGanZhi: ''
                };
            }
        }
        
        // 显示当前五行分布图表
        function displayCurrentElementsChart(currentData, currentYear) {
            const ctx = document.getElementById('current-elements-chart').getContext('2d');
            const elements = currentData.elements;
            
            if (window.currentElementsChart) {
                window.currentElementsChart.destroy();
            }
            
            // 增强的五行颜色 - 更专业的配色方案
            const elementColors = {
                wood: {
                    main: '#2ecc71',
                    light: 'rgba(46, 204, 113, 0.8)',
                    border: 'rgba(46, 204, 113, 1)',
                    gradient: ['rgba(46, 204, 113, 0.9)', 'rgba(39, 174, 96, 0.9)']
                },
                fire: {
                    main: '#e74c3c',
                    light: 'rgba(231, 76, 60, 0.8)',
                    border: 'rgba(231, 76, 60, 1)',
                    gradient: ['rgba(231, 76, 60, 0.9)', 'rgba(192, 57, 43, 0.9)']
                },
                earth: {
                    main: '#f39c12',
                    light: 'rgba(243, 156, 18, 0.8)',
                    border: 'rgba(243, 156, 18, 1)',
                    gradient: ['rgba(243, 156, 18, 0.9)', 'rgba(211, 84, 0, 0.9)']
                },
                metal: {
                    main: '#95a5a6',
                    light: 'rgba(149, 165, 166, 0.8)',
                    border: 'rgba(149, 165, 166, 1)',
                    gradient: ['rgba(149, 165, 166, 0.9)', 'rgba(127, 140, 141, 0.9)']
                },
                water: {
                    main: '#3498db',
                    light: 'rgba(52, 152, 219, 0.8)',
                    border: 'rgba(52, 152, 219, 1)',
                    gradient: ['rgba(52, 152, 219, 0.9)', 'rgba(41, 128, 185, 0.9)']
                }
            };
            
            // 注册Chart.js插件
            Chart.register(ChartDataLabels);
            
            // 计算总分
            const total = Object.values(elements).reduce((sum, val) => sum + val, 0);
            
            // 创建渐变背景
            const createGradient = (ctx, colors) => {
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, colors[0]);
                gradient.addColorStop(1, colors[1]);
                return gradient;
            };
            
            // 创建当前五行雷达图
            window.currentElementsChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['木', '火', '土', '金', '水'],
                    datasets: [{
                        label: '当前五行力量',
                        data: [elements.wood, elements.fire, elements.earth, elements.metal, elements.water],
                        backgroundColor: [
                            elementColors.wood.light,
                            elementColors.fire.light,
                            elementColors.earth.light,
                            elementColors.metal.light,
                            elementColors.water.light
                        ],
                        borderColor: [
                            elementColors.wood.border,
                            elementColors.fire.border,
                            elementColors.earth.border,
                            elementColors.metal.border,
                            elementColors.water.border
                        ],
                        borderWidth: 3,
                        pointBackgroundColor: [
                            elementColors.wood.main,
                            elementColors.fire.main,
                            elementColors.earth.main,
                            elementColors.metal.main,
                            elementColors.water.main
                        ],
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointHoverBackgroundColor: [
                            elementColors.wood.light,
                            elementColors.fire.light,
                            elementColors.earth.light,
                            elementColors.metal.light,
                            elementColors.water.light
                        ],
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)',
                                lineWidth: 1
                            },
                            angleLines: {
                                color: 'rgba(0, 0, 0, 0.1)',
                                lineWidth: 1
                            },
                            pointLabels: {
                                font: {
                                    size: 16,
                                    weight: 'bold',
                                    family: "'Noto Serif SC', serif"
                                },
                                color: '#333'
                            },
                            ticks: {
                                display: true,
                                font: {
                                    size: 12,
                                    family: "'Noto Serif SC', serif"
                                },
                                color: '#666',
                                backdropColor: 'rgba(255, 255, 255, 0.8)',
                                backdropPadding: 2
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            titleColor: '#333',
                            bodyColor: '#333',
                            borderColor: '#ddd',
                            borderWidth: 1,
                            cornerRadius: 10,
                            padding: 15,
                            boxPadding: 8,
                            titleFont: {
                                size: 16,
                                weight: 'bold',
                                family: "'Noto Serif SC', serif"
                            },
                            bodyFont: {
                                size: 14,
                                family: "'Noto Serif SC', serif"
                            },
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                    const percentage = ((context.parsed.r / total) * 100).toFixed(2);
                                    return `${context.label}: ${context.parsed.r.toFixed(1)}点 (${percentage}%)`;
                                }
                            }
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    animation: {
                        duration: 2000,
                        easing: 'easeOutQuart'
                    }
                }
            });
            
            // 显示当前五行概览
            const currentSummary = document.getElementById('current-elements-summary');
            const strongest = Object.keys(elements).reduce((a, b) => elements[a] > elements[b] ? a : b);
            const weakest = Object.keys(elements).reduce((a, b) => elements[a] < elements[b] ? a : b);
            
            // 定义 strongestKey 和 weakestKey（在这个函数中，strongest 和 weakest 已经是英文键名）
            const strongestKey = strongest;
            const weakestKey = weakest;
            
            const elementNames = {
                wood: '木', fire: '火', earth: '土', metal: '金', water: '水'
            };
            
            // 计算五行平衡度
            const avg = total / 5;
            const deviation = Object.values(elements).reduce((sum, val) => sum + Math.abs(val - avg), 0) / total;
            const balancePercentage = (1 - deviation) * 100;
            let balanceLevel;
            if (balancePercentage >= 85) balanceLevel = '极佳';
            else if (balancePercentage >= 70) balanceLevel = '良好';
            else if (balancePercentage >= 50) balanceLevel = '一般';
            else balanceLevel = '失衡';
            
            currentSummary.innerHTML = `
                <div style="background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(240,240,240,0.7)); padding: 12px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.06);">
                    <div style="margin-bottom: 8px; font-size: 0.85rem;">
                        <span style="color: #2e7d32; font-weight: bold;">当前运势：</span>
                        <span style="color: #1976d2;">${currentYear}年${currentData.yearGanZhi}</span>
                        ${currentData.dayunGanZhi ? `<span style="margin-left: 8px; color: #388e3c;">大运${currentData.dayunGanZhi}</span>` : ''}
                    </div>
                    <div style="display: flex; justify-content: space-between; flex-wrap: wrap; margin-bottom: 8px;">
                        <div style="min-width: 100px; margin-bottom: 4px; font-size: 0.85rem;">
                            <span style="font-weight: bold; color: ${elementColors[strongestKey].main};">最强：</span>
                            <span style="background: ${elementColors[strongestKey].light}; padding: 2px 6px; border-radius: 12px; color: #fff; font-weight: bold; font-size: 0.8rem;">
                                ${elementNames[strongest]} ${((elements[strongest]/total)*100).toFixed(1)}%
                            </span>
                        </div>
                        <div style="min-width: 100px; margin-bottom: 4px; font-size: 0.85rem;">
                            <span style="font-weight: bold; color: ${elementColors[weakestKey].main};">最弱：</span>
                            <span style="background: ${elementColors[weakestKey].light}; padding: 2px 6px; border-radius: 12px; color: #fff; font-weight: bold; font-size: 0.8rem;">
                                ${elementNames[weakest]} ${((elements[weakest]/total)*100).toFixed(1)}%
                            </span>
                        </div>
                    </div>
                    <div style="font-size: 0.8rem; line-height: 1.4;">
                        <span style="color: #2c3e50;">五行分布：</span>
                        <span style="color: ${elementColors.wood.main};">木${elements.wood.toFixed(1)}</span> |
                        <span style="color: ${elementColors.fire.main};">火${elements.fire.toFixed(1)}</span> |
                        <span style="color: ${elementColors.earth.main};">土${elements.earth.toFixed(1)}</span> |
                        <span style="color: ${elementColors.metal.main};">金${elements.metal.toFixed(1)}</span> |
                        <span style="color: ${elementColors.water.main};">水${elements.water.toFixed(1)}</span>
                    </div>
                </div>
            `;
        }
        
        // 更新五行分析描述函数
        function updateElementsDescription(originalElements, currentElements) {
            const description = document.getElementById('elements-description');
            
            const elementNames = {
                wood: '木', fire: '火', earth: '土', metal: '金', water: '水'
            };
            
            // 检查 currentElements 是否有效
            if (!currentElements || !currentElements.elements) {
                console.error('currentElements 数据无效:', currentElements);
                description.innerHTML = `
                    <h4 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.1rem; border-bottom: 2px solid #e74c3c; padding-bottom: 8px;">
                        <i class="fas fa-exclamation-triangle"></i> 五行分析
                    </h4>
                    <div style="background-color: #f8d7da; padding: 15px; border-radius: 8px; border: 1px solid #f5c6cb; color: #721c24;">
                        <p><i class="fas fa-exclamation-triangle"></i> 五行数据加载失败，请刷新页面重试。</p>
                    </div>
                `;
                return;
            }
            
            // 计算变化
            const changes = {};
            Object.keys(originalElements).forEach(element => {
                changes[element] = currentElements.elements[element] - originalElements[element];
            });
            
            // 找出变化最大的五行
            const maxIncrease = Object.keys(changes).reduce((a, b) => changes[a] > changes[b] ? a : b);
            const maxDecrease = Object.keys(changes).reduce((a, b) => changes[a] < changes[b] ? a : b);
            
            description.innerHTML = `
                <h4 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.1rem; border-bottom: 2px solid #4caf50; padding-bottom: 8px;">
                    <i class="fas fa-chart-bar"></i> 五行力量对比分析
                </h4>
                
                <div style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05)); padding: 15px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.05); border-left: 4px solid #4caf50;">
                    <p style="margin: 0 0 10px 0; font-size: 0.95rem; line-height: 1.5;">
                        <strong>运势影响分析：</strong>当前大运和流年的加入，使您的五行力量发生了显著变化。
                        ${changes[maxIncrease] > 0 ? `<span style="color: #2e7d32; font-weight: bold;">${elementNames[maxIncrease]}力量增强最多（+${changes[maxIncrease].toFixed(1)}点）</span>` : ''}${changes[maxIncrease] > 0 && changes[maxDecrease] < 0 ? '，' : ''}${changes[maxDecrease] < 0 ? `<span style="color: #d32f2f; font-weight: bold;">${elementNames[maxDecrease]}力量减弱（${changes[maxDecrease].toFixed(1)}点）</span>` : ''}
                    </p>
                    
                    <p style="margin: 0 0 10px 0; font-size: 0.95rem; line-height: 1.5;">
                        <strong>当前运势特点：</strong>
                        ${currentElements.yearGanZhi ? `${new Date().getFullYear()}年${currentElements.yearGanZhi}年为您带来了${getYearInfluence(currentElements.yearGanZhi)}的能量。` : ''}
                        ${currentElements.dayunGanZhi ? `当前大运${currentElements.dayunGanZhi}进一步${getDayunInfluence(currentElements.dayunGanZhi)}。` : ''}
                    </p>
                    
                    <p style="margin: 0; font-size: 0.95rem; line-height: 1.5;">
                        <strong>运势建议：</strong>
                        ${getTimingAdvice(maxIncrease, maxDecrease, changes)}
                    </p>
                </div>
            `;
        }
        
        // 获取流年影响描述
        function getYearInfluence(yearGanZhi) {
            const yearStem = yearGanZhi.charAt(0);
            const yearBranch = yearGanZhi.charAt(1);
            
            const stemInfluence = {
                '甲': '积极进取', '乙': '温和包容',
                '丙': '热情活力', '丁': '细致温暖',
                '戊': '稳重踏实', '己': '谨慎细心',
                '庚': '果断坚毅', '辛': '精致优雅',
                '壬': '灵活变通', '癸': '深沉内敛'
            };
            
            return stemInfluence[yearStem] || '平衡';
        }
        
        // 获取大运影响描述
        function getDayunInfluence(dayunGanZhi) {
            const dayunStem = dayunGanZhi.charAt(0);
            
            const stemInfluence = {
                '甲': '增强了您的创新能力', '乙': '提升了您的适应性',
                '丙': '激发了您的表现力', '丁': '增进了您的人际关系',
                '戊': '稳固了您的基础', '己': '提高了您的执行力',
                '庚': '强化了您的决断力', '辛': '精进了您的技能',
                '壬': '拓展了您的视野', '癸': '深化了您的思考'
            };
            
            return stemInfluence[dayunStem] || '平衡了您的能量';
        }
        
        // 获取时机建议
        function getTimingAdvice(maxIncrease, maxDecrease, changes) {
            const elementNames = {
                wood: '木', fire: '火', earth: '土', metal: '金', water: '水'
            };
            
            const advice = {
                wood: '适合学习、创新、规划新项目',
                fire: '适合表现、社交、推广宣传',
                earth: '适合稳固基础、储蓄理财',
                metal: '适合整理、决策、执行计划',
                water: '适合思考、调研、灵活应变'
            };
            
            let result = '';
            if (changes[maxIncrease] > 1) {
                result += `当前${elementNames[maxIncrease]}力量强盛，${advice[maxIncrease]}。`;
            }
            if (changes[maxDecrease] < -0.5) {
                result += `需要注意${elementNames[maxDecrease]}力量不足，建议通过相应方式进行补充。`;
            }
            
            return result || '五行力量相对平衡，适合稳步发展。';
        }
        
        // 修改原有的displayElementsChart调用，添加描述更新
        function displayElementsChartComplete(baziData) {
            // 检查 baziData 和 elements 是否有效
            if (!baziData || !baziData.elements) {
                console.error('baziData 或 baziData.elements 无效:', baziData);
                const description = document.getElementById('elements-description');
                if (description) {
                    description.innerHTML = `
                        <div style="background-color: #f8d7da; padding: 15px; border-radius: 8px; border: 1px solid #f5c6cb; color: #721c24;">
                            <p><i class="fas fa-exclamation-triangle"></i> 五行数据无效，无法显示五行分析。</p>
                        </div>
                    `;
                }
                return;
            }
            
            // 显示原命局五行分布
            displayOriginalElementsChart(baziData.elements);
            
            // 计算并显示当前五行分布（包含大运流年）
            const currentYear = new Date().getFullYear();
            const currentElements = calculateCurrentElements(baziData.elements, currentYear);
            displayCurrentElementsChart(currentElements, currentYear);
            
            // 更新五行分析描述
            updateElementsDescription(baziData.elements, currentElements);
        }
        
        // 显示五行分析描述（保留原有功能）
        function displayOriginalElementsDescription(originalElements) {
            // 检查参数是否有效
            if (!originalElements) {
                console.error('originalElements 参数无效');
                const description = document.getElementById('elements-description');
                if (description) {
                    description.innerHTML = `
                        <h4 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.1rem; border-bottom: 2px solid #e74c3c; padding-bottom: 8px;">
                            <i class="fas fa-exclamation-triangle"></i> 五行分析
                        </h4>
                        <div style="background-color: #f8d7da; padding: 15px; border-radius: 8px; border: 1px solid #f5c6cb; color: #721c24;">
                            <p><i class="fas fa-exclamation-triangle"></i> 五行数据无效，请重新计算。</p>
                        </div>
                    `;
                }
                return;
            }
            
            // 获取原始五行数据
            const elements = originalElements;
            
            // 计算最强和最弱的五行
            const strongest = Object.keys(elements).reduce((a, b) => elements[a] > elements[b] ? a : b);
            const weakest = Object.keys(elements).reduce((a, b) => elements[a] < elements[b] ? a : b);
            
            // 获取第二强和第二弱的五行
            const sortedElements = Object.entries(elements).sort((a, b) => b[1] - a[1]);
            const secondStrongest = sortedElements[1][0];
            const secondWeakest = sortedElements[3][0];
            
            // 定义键名（strongest 和 weakest 已经是英文键名）
            const strongestKey = strongest;
            const weakestKey = weakest;
            const secondStrongestKey = secondStrongest;
            const secondWeakestKey = secondWeakest;
            
            // 定义五行颜色
            const elementColors = {
                wood: {
                    main: '#2ecc71',
                    light: 'rgba(46, 204, 113, 0.8)',
                    border: 'rgba(46, 204, 113, 1)',
                    gradient: ['rgba(46, 204, 113, 0.9)', 'rgba(39, 174, 96, 0.9)']
                },
                fire: {
                    main: '#e74c3c',
                    light: 'rgba(231, 76, 60, 0.8)',
                    border: 'rgba(231, 76, 60, 1)',
                    gradient: ['rgba(231, 76, 60, 0.9)', 'rgba(192, 57, 43, 0.9)']
                },
                earth: {
                    main: '#f39c12',
                    light: 'rgba(243, 156, 18, 0.8)',
                    border: 'rgba(243, 156, 18, 1)',
                    gradient: ['rgba(243, 156, 18, 0.9)', 'rgba(211, 84, 0, 0.9)']
                },
                metal: {
                    main: '#95a5a6',
                    light: 'rgba(149, 165, 166, 0.8)',
                    border: 'rgba(149, 165, 166, 1)',
                    gradient: ['rgba(149, 165, 166, 0.9)', 'rgba(127, 140, 141, 0.9)']
                },
                water: {
                    main: '#3498db',
                    light: 'rgba(52, 152, 219, 0.8)',
                    border: 'rgba(52, 152, 219, 1)',
                    gradient: ['rgba(52, 152, 219, 0.9)', 'rgba(41, 128, 185, 0.9)']
                }
            };
            
            // 定义五行特性
            const elementProperties = {
                wood: {
                    nature: '生长、向上、扩展',
                    character: '仁爱、正直、进取、创新、灵活、善变',
                    career: '教育、文化、艺术、法律、环保、植物相关行业、创意设计、新兴产业',
                    health: '肝胆系统、眼睛、肌腱、神经、头部',
                    favorable: '东方、绿色环境、春季、早晨',
                    icon: 'fa-tree',
                    personality: '富有创造力，善于变通，但可能缺乏持久力，容易三分钟热度',
                    career_detail: '适合需要创新和灵活思维的工作，不适合过于机械化的工作',
                    health_advice: '注意肝脏健康，保持规律作息，避免过度疲劳，多做户外运动'
                },
                fire: {
                    nature: '向上、光明、温暖',
                    character: '热情、活泼、积极、礼貌、文明、急躁',
                    career: '娱乐、广告、餐饮、能源、化工、电子、通讯、演艺、媒体',
                    health: '心脏、血管、小肠、舌头、面部',
                    favorable: '南方、红色环境、夏季、中午',
                    icon: 'fa-fire',
                    personality: '热情开朗，善于表达，但可能急躁冲动，缺乏耐心',
                    career_detail: '适合需要沟通和表现力的工作，不适合需要长期专注的工作',
                    health_advice: '注意心血管健康，控制情绪波动，避免过度兴奋，保持心态平和'
                },
                earth: {
                    nature: '承载、稳定、包容',
                    character: '诚实、守信、稳重、包容、勤劳、固执',
                    career: '房地产、建筑、农业、畜牧、土木、陶瓷、中介、管理、服务',
                    health: '脾胃、肌肉、四肢、口唇、消化系统',
                    favorable: '中央、黄色环境、季节交替、下午',
                    icon: 'fa-mountain',
                    personality: '踏实稳重，值得信赖，但可能过于保守，缺乏变通',
                    career_detail: '适合需要稳定和责任心的工作，不适合变化太快的工作',
                    health_advice: '注意脾胃健康，规律饮食，避免暴饮暴食，适当运动增强体质'
                },
                metal: {
                    nature: '收敛、向内、坚硬',
                    character: '果断、公正、条理、自律、理性、刚毅',
                    career: '金融、IT、机械、汽车、珠宝、军警、法律、精密工业',
                    health: '肺部、大肠、皮肤、鼻子、呼吸系统',
                    favorable: '西方、白色环境、秋季、傍晚',
                    icon: 'fa-coins',
                    personality: '条理分明，做事果断，公正严明，但可能过于刚硬，缺乏柔性',
                    career_detail: '适合需要精确和规范的工作，不适合需要灵活变通的工作',
                    health_advice: '注意呼吸系统健康，保持环境清洁，避免过度压抑情绪，适当放松'
                },
                water: {
                    nature: '向下、流动、适应',
                    character: '智慧、灵活、交际、适应力强、深沉、多变',
                    career: '贸易、运输、旅游、水产、外交、销售、咨询、信息传播',
                    health: '肾脏、膀胱、耳朵、骨骼、生殖系统',
                    favorable: '北方、水域环境、冬季、夜晚',
                    icon: 'fa-water',
                    personality: '思维灵活，适应力强，善于沟通，但可能多虑，缺乏决断',
                    career_detail: '适合需要交流和变通的工作，不适合固定模式的工作',
                    health_advice: '注意肾脏健康，保持充足睡眠，避免过度疲劳，保持水分摄入'
                }
             };
             
             // 定义五行中文名称映射
             const elementNames = {
                 wood: '木', fire: '火', earth: '土', metal: '金', water: '水'
             };
             
             const description = document.getElementById('elements-description');
            description.innerHTML = `
                <h4 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.2rem; border-bottom: 2px solid #3498db; padding-bottom: 8px;">
                    <i class="fas fa-chart-bar"></i> 五行分析
                </h4>
                
                <div style="margin-bottom: 18px;">
                    <h5 style="color: ${elementColors[strongestKey].main}; font-size: 1.1rem; margin-bottom: 10px; display: flex; align-items: center;">
                        <i class="fas ${elementProperties[strongestKey].icon}" style="margin-right: 8px;"></i> ${elementNames[strongest]}的特性与影响
                    </h5>
                    <div style="background: linear-gradient(135deg, rgba(${strongestKey === 'wood' ? '46, 204, 113, 0.15' : strongestKey === 'fire' ? '231, 76, 60, 0.15' : strongestKey === 'earth' ? '243, 156, 18, 0.15' : strongestKey === 'metal' ? '149, 165, 166, 0.15' : '52, 152, 219, 0.15'}, 1), rgba(${strongestKey === 'wood' ? '46, 204, 113, 0.05' : strongestKey === 'fire' ? '231, 76, 60, 0.05' : strongestKey === 'earth' ? '243, 156, 18, 0.05' : strongestKey === 'metal' ? '149, 165, 166, 0.05' : '52, 152, 219, 0.05'}, 1)); padding: 15px; border-radius: 10px; margin-bottom: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.05); border-left: 4px solid ${elementColors[strongestKey].main};">
                        <p style="margin: 0 0 8px 0; font-size: 0.95rem;"><strong>性质：</strong>${elementProperties[strongestKey].nature}</p>
                        <p style="margin: 0 0 8px 0; font-size: 0.95rem;"><strong>性格特点：</strong>${elementProperties[strongestKey].character}</p>
                        <p style="margin: 0 0 8px 0; font-size: 0.95rem;"><strong>性格分析：</strong>${elementProperties[strongestKey].personality}</p>
                        <p style="margin: 0 0 8px 0; font-size: 0.95rem;"><strong>事业方向：</strong>${elementProperties[strongestKey].career}</p>
                        <p style="margin: 0 0 8px 0; font-size: 0.95rem;"><strong>事业特点：</strong>${elementProperties[strongestKey].career_detail}</p>
                        <p style="margin: 0 0 8px 0; font-size: 0.95rem;"><strong>健康关注：</strong>${elementProperties[strongestKey].health}</p>
                        <p style="margin: 0 0 8px 0; font-size: 0.95rem;"><strong>健康建议：</strong>${elementProperties[strongestKey].health_advice}</p>
                        <p style="margin: 0; font-size: 0.95rem;"><strong>有利环境：</strong>${elementProperties[strongestKey].favorable}</p>
                    </div>
                </div>
                
                <div style="margin-bottom: 18px;">
                    <h5 style="color: #2c3e50; font-size: 1.1rem; margin-bottom: 10px; display: flex; align-items: center;">
                        <i class="fas fa-balance-scale" style="margin-right: 8px;"></i> 五行平衡建议
                    </h5>
                    <div style="background: linear-gradient(135deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.05)); padding: 15px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.05); border-left: 4px solid #3498db;">
                        <p style="margin: 0 0 10px 0; font-size: 0.95rem;">${getFiveElementsAdvice(strongest, weakest)}</p>
                        <p style="margin: 0 0 10px 0; font-size: 0.95rem;"><strong>五行组合特点：</strong>
                            ${elementNames[strongest]}${secondStrongest !== strongest ? `和${elementNames[secondStrongest]}` : ''}较强，表现为${elementProperties[strongestKey].character.split('、')[0]}${secondStrongest !== strongest ? `和${elementProperties[secondStrongestKey].character.split('、')[0]}` : ''}的特质突出。
                            ${weakest === strongest ? '' : `${elementNames[weakest]}较弱，可能缺乏${elementProperties[weakestKey].character.split('、')[0]}的特质。`}
                        </p>
                        <p style="margin: 0; font-size: 0.95rem;"><strong>补充${elementNames[weakest]}的方法：</strong>
                            ${weakestKey === 'wood' ? '多接触绿色植物，在东方位置活动，春季出行，佩戴绿色饰品，多吃绿色蔬菜' : 
                              weakestKey === 'fire' ? '增加红色装饰，在南方位置活动，夏季出行，佩戴红色饰品，适当晒太阳' : 
                              weakestKey === 'earth' ? '使用黄色、棕色物品，在中央位置活动，季节交替时多出门，多吃黄色食物' : 
                              weakestKey === 'metal' ? '佩戴金属饰品，在西方位置活动，秋季出行，使用白色物品，保持环境整洁' : 
                              '多喝水，在北方位置活动，冬季出行，使用蓝色或黑色物品，接触水域环境'}
                        </p>
                    </div>
                </div>
                

            `;
        }

        // 获取五行建议
        function getFiveElementsAdvice(strongest, weakest) {
            const adviceMap = {
                wood: '宜从事与木相关的行业，如林业、园艺、文教等',
                fire: '宜从事与火相关的行业，如能源、餐饮、娱乐等',
                earth: '宜从事与土相关的行业，如房地产、农业、建筑等',
                metal: '宜从事与金相关的行业，如金融、机械、汽车等',
                water: '宜从事与水相关的行业，如航运、水利、贸易等'
            };
            
            return `五行${strongest === 'wood' ? '木' : strongest === 'fire' ? '火' : strongest === 'earth' ? '土' : strongest === 'metal' ? '金' : '水'}最强，${adviceMap[strongest]}。需要补充${weakest === 'wood' ? '木' : weakest === 'fire' ? '火' : weakest === 'earth' ? '土' : weakest === 'metal' ? '金' : '水'}元素。`;
        }

        // 显示身强身弱图表
        function displayStrengthChart(baziData) {
            console.log('显示身强身弱分析，数据:', baziData.strengthAnalysis);
            
            // 使用window.combinedInfo获取最新的合化信息
            if (window.combinedInfo) {
                console.log('从window.combinedInfo获取合化信息:', window.combinedInfo);
                baziData.strengthAnalysis.combined = window.combinedInfo;
            } else {
                console.log('合化信息:', baziData.strengthAnalysis.combined);
            }
            
            // 打印完整的strengthAnalysis对象，用于调试
            console.log('完整的strengthAnalysis对象:', JSON.stringify(baziData.strengthAnalysis, null, 2));
            
            // 检查八字中是否有巳酉丑三合金局
            const branches = window.allBranches || [];
            console.log('当前八字地支:', branches);
            
            // 特别检查巳酉丑三合金局（已修复：添加相邻性检查）
            const metalCombo = ['巳', '酉', '丑'];
            const metalMatches = [];
            
            // 检查存在性
            metalCombo.forEach(branch => {
                const indices = branches.map((b, i) => b === branch ? i : -1).filter(i => i !== -1);
                if (indices.length > 0) {
                    metalMatches.push({branch, indices});
                }
            });
            
            console.log(`特别检查巳酉丑三合金局:`, {
                required: metalCombo,
                found: metalMatches.map(m => m.branch),
                allBranches: branches
            });
            
            if (baziData.strengthAnalysis.combined && baziData.strengthAnalysis.combined.sanhe) {
                console.log('三合局详情:', baziData.strengthAnalysis.combined.sanhe);
            } else {
                console.log('没有检测到三合局');
                
                // 如果系统没有检测到三合局，但实际上有巳酉丑三合金局
                if (metalMatches.length >= 2) {
                    // 检查相邻性
                    let isValidCombination = false;
                    
                    if (metalMatches.length === 3) {
                        // 全三合：检查是否有连续的三个位置
                        const allPositions = [];
                        metalMatches.forEach(match => {
                            allPositions.push(...match.indices);
                        });
                        allPositions.sort((a, b) => a - b);
                        
                        for (let i = 0; i <= allPositions.length - 3; i++) {
                            if (allPositions[i+1] === allPositions[i] + 1 && 
                                allPositions[i+2] === allPositions[i] + 2) {
                                isValidCombination = true;
                                break;
                            }
                        }
                        
                        console.log(`手动检查巳酉丑全三合: 位置${allPositions}, 连续性=${isValidCombination}`);
                    } else if (metalMatches.length === 2) {
                        // 半三合：检查两个地支是否相邻
                        const positions = [];
                        metalMatches.forEach(match => {
                            positions.push(...match.indices);
                        });
                        
                        for (let i = 0; i < positions.length; i++) {
                            for (let j = i + 1; j < positions.length; j++) {
                                if (Math.abs(positions[i] - positions[j]) === 1) {
                                    isValidCombination = true;
                                    break;
                                }
                            }
                            if (isValidCombination) break;
                        }
                        
                        console.log(`手动检查巳酉丑半三合: 位置${positions}, 相邻性=${isValidCombination}`);
                    }
                    
                    // 只有通过相邻性检查才手动添加
                    if (isValidCombination) {
                        console.log('✅ 手动检测到有效的巳酉丑三合金局:', metalMatches.map(m => m.branch).join(''));
                        
                        // 手动添加三合局信息
                        if (!baziData.strengthAnalysis.combined) {
                            baziData.strengthAnalysis.combined = {};
                        }
                        
                        if (!baziData.strengthAnalysis.combined.sanhe) {
                            baziData.strengthAnalysis.combined.sanhe = [];
                        }
                        
                        baziData.strengthAnalysis.combined.sanhe.push({
                            type: '巳酉丑',
                            element: 'metal',
                            count: metalMatches.length,
                            branches: metalMatches.map(m => m.branch).join(''),
                            isValid: true,
                            positions: metalMatches.flatMap(m => m.indices),
                            isManuallyAdded: true
                        });
                    } else {
                        console.log('❌ 手动检查巳酉丑三合金局失败: 地支不相邻，不能合化');
                    }
                } else {
                    console.log('❌ 手动检查巳酉丑三合金局失败: 缺少必要地支');
                }
            }
            
            const canvas = document.getElementById('strength-chart');
            const ctx = canvas.getContext('2d');
            const strengthAnalysis = baziData.strengthAnalysis;
            
            // 调试信息：检查数据值
            console.log('原命局图表数据:', {
                supportStrength: strengthAnalysis.supportStrength,
                weakenStrength: strengthAnalysis.weakenStrength,
                canvasWidth: canvas.clientWidth,
                canvasHeight: canvas.clientHeight
            });
            
            // 强制重置canvas尺寸
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            if (strengthChart) {
                strengthChart.destroy();
            }
            
            strengthChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['生扶力量', '克泄力量'],
                    datasets: [{
                        label: '力量对比',
                        data: [strengthAnalysis.supportStrength, strengthAnalysis.weakenStrength],
                        backgroundColor: [
                            '#27ae60', // 生扶 - 绿色
                            '#e74c3c'  // 克泄 - 红色
                        ],
                        borderWidth: 2,
                        borderColor: '#fff',
                        barThickness: 60,
                        maxBarThickness: 80
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                     const yVal = typeof context.parsed.y === 'number' ? context.parsed.y : parseFloat(context.parsed.y);
                                     return `${context.label}: ${yVal.toFixed(2)}点`;
                                 }
                             }
                         },
                         datalabels: {
                            anchor: 'end',
                            align: 'end',
                            formatter: (value) => Number(value).toFixed(2),
                            color: '#333',
                            font: {
                                size: 12,
                                weight: 'bold'
                            }
                        }
                     },
                     scales: {
                         x: {
                             grid: {
                                 display: false
                             },
                             ticks: {
                                 font: {
                                     size: 12
                                 }
                             }
                         },
                         y: {
                             beginAtZero: true,
                             grid: {
                                 color: 'rgba(0,0,0,0.1)'
                             },
                             title: {
                                 display: true,
                                 text: '力量值',
                                 font: {
                                     size: 12
                                 }
                             },
                             ticks: {
                                 font: {
                                     size: 11
                                 },
                                 callback: function(value) {
                                     return Number(value).toFixed(2);
                                 }
                             }
                         }
                     }
                 }
             });
             
             // 显示身强身弱分析描述
             const description = document.getElementById('strength-description');
             
             // 根据不同类型设置不同的图标和颜色（12级分类系统）
            let typeIcon, typeColor;
            switch(strengthAnalysis.type) {
                case '极弱（从弱）':
                case '从弱':
                    typeIcon = 'fa-arrow-down';
                    typeColor = '#2c3e50';
                    break;
                case '很弱':
                case '较弱':
                    typeIcon = 'fa-snowflake';
                    typeColor = '#3498db';
                    break;
                case '稍弱':
                case '微弱':
                    typeIcon = 'fa-thermometer-quarter';
                    typeColor = '#5dade2';
                    break;
                case '中和偏弱':
                    typeIcon = 'fa-balance-scale';
                    typeColor = '#85c1e9';
                    break;
                case '真正中和':
                    typeIcon = 'fa-yin-yang';
                    typeColor = '#f39c12';
                    break;
                case '中和偏强':
                    typeIcon = 'fa-balance-scale';
                    typeColor = '#f8c471';
                    break;
                case '微强':
                case '稍强':
                    typeIcon = 'fa-thermometer-three-quarters';
                    typeColor = '#f7dc6f';
                    break;
                case '较强':
                    typeIcon = 'fa-fire';
                    typeColor = '#e74c3c';
                    break;
                case '极强（专旺）':
                case '从强':
                    typeIcon = 'fa-arrow-up';
                    typeColor = '#9b59b6';
                    break;
                // 兼容旧版本
                case '身强':
                    typeIcon = 'fa-fire';
                    typeColor = '#e74c3c';
                    break;
                case '身弱':
                    typeIcon = 'fa-snowflake';
                    typeColor = '#3498db';
                    break;
                case '均衡':
                    typeIcon = 'fa-balance-scale';
                    typeColor = '#f39c12';
                    break;
                case '从强':
                    typeIcon = 'fa-arrow-up';
                     typeColor = '#9b59b6';
                     break;
                 case '从弱':
                     typeIcon = 'fa-arrow-down';
                     typeColor = '#2ecc71';
                     break;
                 default:
                     typeIcon = 'fa-balance-scale';
                     typeColor = '#7f8c8d';
             }
             
             description.innerHTML = `
                 <h4><i class="fas fa-balance-scale"></i> 身强身弱分析</h4>
                 <div style="display: flex; align-items: center; margin-bottom: 10px;">
                     <div style="background-color: ${typeColor}; color: white; padding: 5px 10px; border-radius: 5px; margin-right: 10px;">
                         <i class="fas ${typeIcon}"></i> ${strengthAnalysis.type}
                     </div>
                     <div>力量比例: ${(strengthAnalysis.ratio * 100).toFixed(2)}%</div>
                 </div>
                 <p><strong>生扶力量:</strong> ${strengthAnalysis.supportStrength.toFixed(2)}点</p>
                 <p><strong>克泄力量:</strong> ${strengthAnalysis.weakenStrength.toFixed(2)}点</p>
                 ${strengthAnalysis.monthScore ? `<p><strong>月令得分:</strong> ${strengthAnalysis.monthScore}点</p>` : ''}
                 ${strengthAnalysis.combined && strengthAnalysis.combined.effect ? `<p><strong>合化影响:</strong> ${strengthAnalysis.combined.effect === 'strengthen' ? '增强日主' : '削弱日主'}</p>` : ''}
                 ${strengthAnalysis.combined && strengthAnalysis.combined.deduction ? `<p><strong>合化扣分:</strong> <span style="color: #e74c3c; font-weight: bold;">${strengthAnalysis.combined.deduction}点</span></p>` : ''}
                 <div class="hehua-info">
                 ${strengthAnalysis.combined && (strengthAnalysis.combined.tianGanWuHe.length > 0 || strengthAnalysis.combined.diZhiLiuHe.length > 0 || strengthAnalysis.combined.diZhiSanHe.length > 0) ? 
                    `<div style="background-color: #e8f4fc; padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid #3498db; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                        <h5 style="color: #3498db; margin-top: 0; font-size: 16px;"><i class="fas fa-link"></i> 合化信息</h5>
                        ${strengthAnalysis.combined.tianGanWuHe.length > 0 ? 
                            `<div style="margin-bottom: 10px;">
                                <p><strong>天干五合:</strong> ${strengthAnalysis.combined.tianGanWuHe.map(h => {
                                    const elementName = h.element === 'wood' ? '木' : h.element === 'fire' ? '火' : h.element === 'earth' ? '土' : h.element === 'metal' ? '金' : '水';
                                    if (h.onlyBind) {
                                        return `${h.gan1}${h.gan2}绊合(${h.bindReason || '只合不化'})`;
                                    } else {
                                        return `${h.gan1}${h.gan2}合${elementName}`;
                                    }
                                }).join('、')}</p>
                            </div>` : ''}
                        ${strengthAnalysis.combined.diZhiLiuHe.length > 0 ? 
                            `<div style="margin-bottom: 10px;">
                                <p><strong>地支六合:</strong> ${strengthAnalysis.combined.diZhiLiuHe.map(h => `${h.zhi1}${h.zhi2}合${h.element === 'wood' ? '木' : h.element === 'fire' ? '火' : h.element === 'earth' ? '土' : h.element === 'metal' ? '金' : '水'}`).join('、')}</p>
                            </div>` : ''}
                        ${strengthAnalysis.combined.diZhiSanHe.length > 0 ? 
                            `<div style="margin-bottom: 10px;">
                                <p><strong>地支三合:</strong> ${strengthAnalysis.combined.diZhiSanHe.map(h => `${h.type}三合${h.element === 'wood' ? '木' : h.element === 'fire' ? '火' : h.element === 'earth' ? '土' : h.element === 'metal' ? '金' : '水'}(${h.count === 3 ? '全三合' : '半三合'})`).join('、')}</p>
                            </div>` : ''}
                        <p><strong>对日主影响:</strong> <span style="color: ${strengthAnalysis.combined.effect === 'strengthen' ? '#27ae60' : strengthAnalysis.combined.effect === 'weaken' ? '#e74c3c' : '#7f8c8d'}; font-weight: bold;">${strengthAnalysis.combined.effect === 'strengthen' ? '增强日主' : strengthAnalysis.combined.effect === 'weaken' ? '削弱日主' : '影响中性'}</span></p>
                        ${strengthAnalysis.combined.deduction ? `<p><strong>力量扣减:</strong> <span style="color: #e74c3c; font-weight: bold;">${strengthAnalysis.combined.deduction}点</span> (合化影响)</p>` : ''}
                    </div>` : `<div style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; border: 1px dashed #ccc;">
                        <p style="color: #7f8c8d; margin: 0;"><i class="fas fa-info-circle"></i> 未检测到合化</p>
                    </div>`}
                 </div>
                 ${strengthAnalysis.earthTransformation ? 
                    `<div style="background-color: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid #ffc107; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                        <h5 style="color: #856404; margin-top: 0; font-size: 16px;"><i class="fas fa-mountain"></i> 土性变化分析</h5>
                        ${strengthAnalysis.earthTransformation.wetEarthChanges.length > 0 ? 
                            `<div style="margin-bottom: 10px;">
                                <p><strong>湿土变化:</strong> ${strengthAnalysis.earthTransformation.wetEarthChanges.map(change => 
                                    `${change.earthBranch}${change.reason}做${change.newElement === 'water' ? '水' : change.newElement === 'fire' ? '火' : change.newElement === 'earth' ? '土' : change.newElement === 'metal' ? '金' : '木'}看(${change.reason})`
                                ).join('、')}</p>
                            </div>` : ''}
                        ${strengthAnalysis.earthTransformation.dryEarthChanges.length > 0 ? 
                            `<div style="margin-bottom: 10px;">
                                <p><strong>燥土变化:</strong> ${strengthAnalysis.earthTransformation.dryEarthChanges.map(change => 
                                    `${change.earthBranch}${change.reason}做${change.newElement === 'water' ? '水' : change.newElement === 'fire' ? '火' : change.newElement === 'earth' ? '土' : change.newElement === 'metal' ? '金' : '木'}看(${change.reason})`
                                ).join('、')}</p>
                            </div>` : ''}
                        ${strengthAnalysis.earthTransformation.wetEarthChanges.length === 0 && strengthAnalysis.earthTransformation.dryEarthChanges.length === 0 ? 
                            `<p style="color: #856404; margin: 0;"><i class="fas fa-info-circle"></i> 未检测到土性变化</p>` : 
                            `<p><strong>变化影响:</strong> <span style="color: #856404; font-weight: bold;">已应用到五行力量计算中</span></p>`}
                    </div>` : ''}
                 <p><strong>分析说明:</strong> ${strengthAnalysis.description}</p>
                 

             `;
             
             // 调整图表容器和描述容器的样式，确保左右并排显示
             const strengthAnalysisFrame = document.querySelector('.strength-analysis-frame');
             const chartContainer = document.querySelector('.chart-container');
             const descriptionContainer = document.getElementById('strength-description');
             
             if (strengthAnalysisFrame && chartContainer && descriptionContainer) {
                 // 确保上下排列显示
                strengthAnalysisFrame.style.display = 'flex';
                strengthAnalysisFrame.style.flexDirection = 'column';
                strengthAnalysisFrame.style.gap = '15px';
                strengthAnalysisFrame.style.flexWrap = 'nowrap';
                 
                 // 设置图表容器样式 - 注释掉以避免覆盖CSS样式
                // chartContainer.style.flex = 'none';
                // chartContainer.style.width = '100%';
                // chartContainer.style.height = '250px';
                 // chartContainer.style.backgroundColor = '#ffffff';
                 // chartContainer.style.padding = '15px';
                 // chartContainer.style.borderRadius = '8px';
                 // chartContainer.style.boxShadow = '0 2px 4px rgba(0,0,0,0.05)';
                 
                 // 设置描述容器样式
                descriptionContainer.style.flex = 'none';
                descriptionContainer.style.width = '100%';
                 descriptionContainer.style.padding = '15px';
                 descriptionContainer.style.backgroundColor = '#f9f9f9';
                 descriptionContainer.style.borderRadius = '8px';
                 descriptionContainer.style.boxShadow = '0 2px 4px rgba(0,0,0,0.05)';
             }
         }

         // 显示起运时间
         function displayLuckTiming(baziData) {
             const luckTiming = document.getElementById('luck-timing');
             const timing = baziData.luckTiming;
             
             // 获取当前大运信息
             const currentDayun = getCurrentDayun();
             
             // 获取日主天干和当前年龄
             const dayStem = baziData.pillars?.day?.charAt(0) || '甲'; // 获取日主天干，默认为甲
             const currentAge = currentDayun?.currentAge || 25; // 默认年龄25岁
             
             // 动态计算12长生状态数据
             const twelveStages = calculateTwelveStages(dayStem, timing, currentAge);
             
             luckTiming.innerHTML = `
                 <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 25px;">
                     <div class="analysis-card">
                         <h4><i class="fas fa-clock"></i> 起运年龄</h4>
                         <p style="font-size: 1.6rem; font-weight: bold; color: var(--secondary-color); margin: 6px 0;">
                             ${timing.age}岁${timing.months}个月
                         </p>
                         <p style="color: var(--primary-color); font-weight: 600; margin: 4px 0;">${timing.description}</p>
                         <div style="margin-top: 6px; font-size: 0.85rem; color: var(--text-secondary); line-height: 1.3;">
                             <p style="margin: 2px 0;"><strong>排列方式：</strong>${timing.direction}</p>
                             <p style="margin: 2px 0;"><strong>节气天数：</strong>${timing.daysDiff}天</p>
                             <p style="margin: 2px 0;"><strong>当前大运：</strong><span style="color: var(--primary-color); font-weight: bold;">${currentDayun.ganZhi}</span> (${currentDayun.startAge}-${currentDayun.endAge}岁，当前${currentDayun.currentAge}岁)</p>
                         </div>
                     </div>
                     <div class="analysis-card">
                         <h4><i class="fas fa-info-circle"></i> 起运说明</h4>
                         <p>起运时间是命理学中的重要概念，标志着人生运势的正式开始。</p>
                         <p>计算方法：根据年柱天干阴阳和性别确定顺排或逆排，然后计算出生日到最近节气的天数，3天折合1岁。</p>
                         <p>在起运之前，主要受父母和家庭环境影响；起运之后，个人运势开始发挥主导作用。</p>
                     </div>
                 </div>
                 
                 <!-- 12长生分析容器 -->
                 <div class="analysis-card" style="margin-top: 20px;">
                     <h4 style="margin-bottom: 20px; color: var(--primary-color); display: flex; align-items: center; gap: 8px;">
                         <i class="fas fa-yin-yang"></i> 十二长生运势分析
                     </h4>
                     <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                         ${twelveStages.map(stage => `
                             <div style="
                                 background: linear-gradient(135deg, ${stage.color}15, ${stage.color}08);
                                 border: ${stage.isCurrent ? `2px solid ${stage.color}` : `1px solid ${stage.color}30`};
                                 border-radius: 6px;
                                 padding: 8px;
                                 text-align: left;
                                 transition: all 0.3s ease;
                                 position: relative;
                                 overflow: hidden;
                                 ${stage.isCurrent ? `box-shadow: 0 2px 8px ${stage.color}40; transform: scale(1.01);` : ''}
                             " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px ${stage.color}25'" onmouseout="this.style.transform='${stage.isCurrent ? 'scale(1.01)' : 'translateY(0)'}'; this.style.boxShadow='${stage.isCurrent ? `0 2px 8px ${stage.color}40` : 'none'}'">
                                 <div style="
                                     position: absolute;
                                     top: 0;
                                     left: 0;
                                     right: 0;
                                     height: 3px;
                                     background: linear-gradient(90deg, ${stage.color}, ${stage.color}80);
                                 "></div>
                                 <div style="
                                     font-size: 0.95rem;
                                     font-weight: bold;
                                     color: ${stage.color};
                                     margin-bottom: 4px;
                                     display: flex;
                                     justify-content: space-between;
                                     align-items: center;
                                 ">
                                     <span>${stage.name}</span>
                                     ${stage.isCurrent ? '<span style="color: var(--gold-color); font-size: 0.7rem;">●当前</span>' : ''}
                                 </div>
                                 <div style="
                                     display: flex;
                                     justify-content: space-between;
                                     margin-bottom: 3px;
                                     font-size: 0.75rem;
                                 ">
                                     <span style="color: var(--text-secondary);">大运: <span style="color: var(--primary-color); font-weight: 600;">${stage.dayun}</span></span>
                                     <span style="color: ${stage.color}; font-weight: 600;">能量: ${stage.energy}</span>
                                 </div>
                                 <div style="
                                     display: flex;
                                     justify-content: space-between;
                                     margin-bottom: 4px;
                                     font-size: 0.75rem;
                                 ">
                                     <span style="color: var(--primary-color); font-weight: 600;">年龄: ${stage.ageRange}</span>
                                 </div>
                                 <div style="
                                     font-size: 0.7rem;
                                     color: var(--text-secondary);
                                     line-height: 1.2;
                                 ">${stage.description}</div>
                             </div>
                         `).join('')}
                     </div>
                     <div style="
                         margin-top: 15px;
                         padding: 12px;
                         background: rgba(var(--primary-color-rgb), 0.08);
                         border-radius: 8px;
                         border-left: 4px solid var(--primary-color);
                     ">
                         <p style="margin: 0; font-size: 0.85rem; color: var(--text-secondary); line-height: 1.4;">
                             <i class="fas fa-lightbulb" style="color: var(--gold-color); margin-right: 5px;"></i>
                             十二长生代表生命力的循环变化，从长生到死再到养，体现了事物发展的自然规律。了解当前所处的长生阶段，有助于把握人生节奏，顺势而为。
                         </p>
                     </div>
                 </div>
             `;
         }

         // 显示命格等级
         function displayFateLevel(baziData) {
             const fateLevelContent = document.getElementById('fate-level-content');
             const fateLevel = baziData.fateLevel;
             const fateTitleEl = document.getElementById('fate-level-title');
             if (fateTitleEl) {
                 const displayName = (baziData && baziData.name) ? baziData.name : '用户';
                 fateTitleEl.innerHTML = `<i class="fas fa-star"></i> ${displayName}的命格等级`;
             }
             
             fateLevelContent.innerHTML = `
                 <div style="text-align: center; margin-bottom: 10px;">
                     <div style="font-size: 2.5rem; font-weight: bold; color: var(--gold-color); margin-bottom: 5px;">
                         ${Number(fateLevel.score || 0).toFixed(2)}分
                     </div>
                     <div style="font-size: 1.3rem; font-weight: 600; color: var(--primary-color); margin-bottom: 5px;">
                         ${fateLevel.level}
                     </div>
                     <div style="color: var(--text-secondary); font-size: 0.95rem;">
                         ${fateLevel.description}
                     </div>
                 </div>
                 <div style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 8px; padding: 15px; margin-top: 10px;">
                     <h4 style="color: var(--primary-color); margin-bottom: 12px;">
                         <i class="fas fa-calculator"></i> 命格等级评分构成
                     </h4>

                     <div style="margin-bottom: 15px;">
                         <h5 style="color: var(--primary-color); margin-bottom: 10px;">
                             <i class="fas fa-layer-group"></i> 基础模块评分
                         </h5>
                         <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                             <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #3498db;">季节助力：</strong> ${Number(fateLevel.details.seasonScore || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">月令得气、通根透干的力量</small>
                             </div>
                             <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #27ae60;">五行平衡：</strong> ${Number(fateLevel.details.balanceScore || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">八字五行分布的均衡性</small>
                             </div>
                             <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #9b59b6;">格局结构：</strong> ${Number(fateLevel.details.patternScore || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">特殊格局的识别与完整性</small>
                             </div>
                             <div style="background: rgba(230, 126, 34, 0.08); border: 1px solid rgba(230, 126, 34, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #e67e22;">十神影响：</strong> ${Number(fateLevel.details.godsScore || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">十神配置的协调性</small>
                             </div>
                             <div style="background: rgba(231, 76, 60, 0.08); border: 1px solid rgba(231, 76, 60, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #e74c3c;">组合刑冲：</strong> ${Number(fateLevel.details.combinationScore || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">地支组合关系的影响</small>
                             </div>
                             <div style="background: rgba(52, 73, 94, 0.08); border: 1px solid rgba(52, 73, 94, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #34495e;">调候用神：</strong> ${Number(fateLevel.details.adjustmentScore || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">调候用神的配置效果</small>
                             </div>
                                 </div>
                             </div>

                     <div style="margin-bottom: 15px;">
                         <h5 style="color: var(--warning-color); margin-bottom: 10px;">
                             <i class="fas fa-cogs"></i> 进阶与修正评分
                         </h5>
                         <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                             <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #3498db;">日主强弱：</strong> ${Number(fateLevel.details.dayMasterStrength || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">日主旺衰程度评估</small>
                             </div>
                             <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #27ae60;">用神得力：</strong> ${Number(fateLevel.details.usefulGodScore || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">用神在八字中的力量</small>
                             </div>
                             <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #9b59b6;">忌神制约：</strong> ${Number(fateLevel.details.tabooGodControl || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">忌神的制约程度</small>
                             </div>
                             <div style="background: rgba(230, 126, 34, 0.08); border: 1px solid rgba(230, 126, 34, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #e67e22;">空亡减分：</strong> -${Number(fateLevel.details.kongWangPenalty || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">空亡对命格的负面影响</small>
                             </div>
                             <div style="background: rgba(231, 76, 60, 0.08); border: 1px solid rgba(231, 76, 60, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #e74c3c;">流年助力：</strong> ${Number(fateLevel.details.luckSupport || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">当前流年的促进作用</small>
                             </div>
                             <div style="background: rgba(52, 73, 94, 0.08); border: 1px solid rgba(52, 73, 94, 0.15); border-radius: 4px; padding: 8px;">
                                 <strong style="color: #34495e;">大运配合：</strong> ${Number(fateLevel.details.dayunCoordination || 0).toFixed(2)} 分
                                 <br><small style="color: #666;">当前大运与命格的配合</small>
                             </div>
                                 </div>
                             </div>

                             <div style="margin-bottom: 15px;">
                                 <h5 style="color: var(--danger-color); margin-bottom: 10px;">
                                     <i class="fas fa-star"></i> 格局与特效评分
                                 </h5>
                                 <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                                     <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #3498db;">贵人助力：</strong> ${Number(fateLevel.details.noblesSupport || 0).toFixed(2)} 分
                                         <br><small style="color: #666;">天乙贵人等神煞的作用</small>
                                     </div>
                                     <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #27ae60;">特殊格局：</strong> ${Number(fateLevel.details.specialPatternBonus || 0).toFixed(2)} 分
                                         <br><small style="color: #666;">从格、化格等特殊格局加成</small>
                                     </div>
                                     <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #9b59b6;">命格层次：</strong> ${Number(fateLevel.details.levelBonus || 0).toFixed(2)} 分
                                         <br><small style="color: #666;">整体命格层次的评估</small>
                                     </div>
                                 </div>
                             </div>
                             
                             <div style="padding: 10px; background: rgba(52, 73, 94, 0.05); border-radius: 6px; border-left: 3px solid var(--primary-color);">
                                 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                     <h5 style="margin: 0; color: var(--primary-color);">
                                         <i class="fas fa-chart-line"></i> 命格评分汇总
                                     </h5>
                                     <div style="display: flex; gap: 12px;">
                                         <div style="text-align: center;">
                                             <div style="font-size: 0.85rem; color: #666;">基础合计</div>
                                             <div style="font-size: 1rem; font-weight: bold; color: var(--primary-color);">
                                                 ${Number(fateLevel.details.baseScore || 0).toFixed(2)} 分
                                             </div>
                                         </div>
                                         <div style="text-align: center;">
                                             <div style="font-size: 0.85rem; color: #666;">最终得分</div>
                                             <div style="font-size: 1.2rem; font-weight: bold; color: var(--gold-color);">
                                                 ${Number(fateLevel.details.total || 0).toFixed(2)} 分
                                             </div>
                                         </div>
                                     </div>
                                 </div>
                                 <p style="font-size: 0.9rem; color: #666; margin: 0; line-height: 1.5;">
                                     命格等级评分采用传统八字理论结合现代评分体系，从多个维度综合评估命格的优劣。分数越高表示命格层次越高，人生发展潜力越大。
                                 </p>
                             </div>
                         </div>
                     </div>
                 </div>
             `;
         }

         // 显示财富等级
         function displayWealthLevel(baziData) {
             const wealthLevelContent = document.getElementById('wealth-level-content');
             const wealthLevel = baziData.wealthLevel;
             const wealthTitleEl = document.getElementById('wealth-level-title');
             if (wealthTitleEl) {
                 const displayName = (baziData && baziData.name) ? baziData.name : '用户';
                 wealthTitleEl.innerHTML = `<i class=\"fas fa-coins\"></i> ${displayName}的财富等级`;
             }
             
             wealthLevelContent.innerHTML = `
                 <div style="text-align: center; margin-bottom: 10px;">
                     <div style="font-size: 2.5rem; font-weight: bold; color: var(--success-color); margin-bottom: 5px;">
                         ${wealthLevel.score}分
                     </div>
                     <div style="font-size: 1.3rem; font-weight: 600; color: var(--primary-color); margin-bottom: 5px;">
                         ${wealthLevel.level}
                     </div>
                     <div style="color: var(--text-secondary); font-size: 0.95rem;">
                         ${wealthLevel.description}
                     </div>
                 </div>
                 <div style="background: rgba(255,255,255,0.08); border-radius: 8px; padding: 12px; margin-top: 8px;">
                             <h4 style="color: var(--success-color); margin-bottom: 12px;">
                                 <i class="fas fa-calculator"></i> 财富等级评分构成
                             </h4>

                             <div style="margin-bottom: 15px;">
                                 <h5 style="color: var(--primary-color); margin-bottom: 10px;">
                                     <i class="fas fa-layer-group"></i> 基础模块评分
                                 </h5>
                                 <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                                     <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #3498db;">食伤生财：</strong> ${wealthLevel.details.shishangScore || 0} 分
                                         <br><small style="color: #666;">食神伤官生财星的能力</small>
                                     </div>
                                     <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #27ae60;">印绶护身：</strong> ${wealthLevel.details.yinshouScore || 0} 分
                                         <br><small style="color: #666;">印星保护日主的作用</small>
                                     </div>
                                     <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #9b59b6;">财星能量：</strong> ${wealthLevel.details.wealthStarScore || 0} 分
                                         <br><small style="color: #666;">财星在八字中的力量</small>
                                     </div>
                                     <div style="background: rgba(230, 126, 34, 0.08); border: 1px solid rgba(230, 126, 34, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #e67e22;">财星位置：</strong> ${wealthLevel.details.wealthPositionScore || 0} 分
                                         <br><small style="color: #666;">财星在四柱中的位置</small>
                                     </div>
                                     <div style="background: rgba(231, 76, 60, 0.08); border: 1px solid rgba(231, 76, 60, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #e74c3c;">财富库藏：</strong> ${wealthLevel.details.wealthVaultScore || 0} 分
                                         <br><small style="color: #666;">财库的聚财能力</small>
                                     </div>
                                     <div style="background: rgba(52, 73, 94, 0.08); border: 1px solid rgba(52, 73, 94, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #34495e;">自坐财库：</strong> ${wealthLevel.details.selfVaultScore || 0} 分
                                         <br><small style="color: #666;">日支为财库的情况</small>
                                     </div>
                                     <div style="background: rgba(26, 188, 156, 0.08); border: 1px solid rgba(26, 188, 156, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #1abc9c;">财气通门户：</strong> ${wealthLevel.details.portalScore || 0} 分
                                         <br><small style="color: #666;">财气流通的顺畅度</small>
                                     </div>
                                     <div style="background: rgba(142, 68, 173, 0.08); border: 1px solid rgba(142, 68, 173, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #8e44ad;">日主承载：</strong> ${wealthLevel.details.dayMasterCapacity || 0} 分
                                         <br><small style="color: #666;">日主承载财富的能力</small>
                                     </div>
                                 </div>
                             </div>

                             <div style="margin-bottom: 15px;">
                                 <h5 style="color: var(--warning-color); margin-bottom: 10px;">
                                     <i class="fas fa-cogs"></i> 进阶与修正评分
                                 </h5>
                                 <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                                     <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #3498db;">喜忌平衡：</strong> ${wealthLevel.details.favorableBalance || 0} 分
                                         <br><small style="color: #666;">喜用神与忌神的平衡</small>
                                     </div>
                                     <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #27ae60;">季节财运：</strong> ${wealthLevel.details.seasonalWealthPotential || 0} 分
                                         <br><small style="color: #666;">出生季节对财运的影响</small>
                                     </div>
                                     <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #9b59b6;">财星保护：</strong> ${wealthLevel.details.wealthProtectionScore || 0} 分
                                         <br><small style="color: #666;">财星的保护机制</small>
                                     </div>
                                     <div style="background: rgba(230, 126, 34, 0.08); border: 1px solid rgba(230, 126, 34, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #e67e22;">空亡扣分：</strong> -${wealthLevel.details.kongWangPenalty || 0} 分
                                         <br><small style="color: #666;">空亡对财运的负面影响</small>
                                     </div>
                                     <div style="background: rgba(231, 76, 60, 0.08); border: 1px solid rgba(231, 76, 60, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #e74c3c;">流年修正：</strong> ${wealthLevel.details.luckAdjustment || 0} 分
                                         <br><small style="color: #666;">当前流年的影响</small>
                                     </div>
                                     <div style="background: rgba(52, 73, 94, 0.08); border: 1px solid rgba(52, 73, 94, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #34495e;">大运强弱：</strong> ${wealthLevel.details.dayunStrength || 0} 分
                                         <br><small style="color: #666;">当前大运对财运的作用</small>
                                     </div>
                                 </div>
                             </div>

                             <div style="margin-bottom: 15px;">
                                 <h5 style="color: var(--danger-color); margin-bottom: 10px;">
                                     <i class="fas fa-star"></i> 格局与特效评分
                                 </h5>
                                 <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                                     <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #3498db;">十神特效：</strong> ${wealthLevel.details.tenGodsBonus || 0} 分
                                         <br><small style="color: #666;">十神配置的特殊效果</small>
                                     </div>
                                     <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #27ae60;">特殊格局：</strong> ${wealthLevel.details.specialBonus || 0} 分（识别到${(wealthLevel.details.specialPatterns && wealthLevel.details.specialPatterns.length) ? wealthLevel.details.specialPatterns.length : 0}项）
                                         <br><small style="color: #666;">格局带来的额外加成</small>
                                     </div>
                                     <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 4px; padding: 8px;">
                                         <strong style="color: #9b59b6;">身财平衡：</strong> ${wealthLevel.details.balanceAdjustment || 0} 分
                                         <br><small style="color: #666;">身强身弱与财星之间的协调</small>
                                     </div>
                                 </div>
                             </div>

                             <div style="padding: 10px; background: rgba(52, 73, 94, 0.05); border-radius: 6px; border-left: 3px solid var(--success-color);">
                                 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                     <h5 style="margin: 0; color: var(--success-color);">
                                         <i class="fas fa-chart-bar"></i> 财富评分汇总
                                     </h5>
                                     <div style="display: flex; gap: 12px;">
                                         <div style="text-align: center;">
                                             <div style="font-size: 0.85rem; color: #666;">基础合计</div>
                                             <div style="font-size: 1.05rem; font-weight: bold; color: var(--primary-color);">
                                                 ${wealthLevel.details.baseScore || 0} 分
                                             </div>
                                         </div>
                                         <div style="text-align: center;">
                                             <div style="font-size: 0.85rem; color: #666;">否决前</div>
                                             <div style="font-size: 1.05rem; font-weight: bold; color: #8e44ad;">
                                                 ${Math.round(wealthLevel.details.beforeVetoScore || 0)} 分
                                             </div>
                                         </div>
                                         <div style="text-align: center;">
                                             <div style="font-size: 0.85rem; color: #666;">最终得分</div>
                                             <div style="font-size: 1.2rem; font-weight: bold; color: var(--success-color);">
                                                 ${wealthLevel.score || 0} 分
                                             </div>
                                         </div>
                                     </div>
                                 </div>
                                 ${Array.isArray(wealthLevel.details.vetoDetails) && wealthLevel.details.vetoDetails.length > 0 ? `
                                 <div style="padding: 12px 12px 6px; background: rgba(231, 76, 60, 0.05); border-radius: 8px; border-left: 4px solid #e74c3c; margin-top: 10px;">
                                     <div style="font-weight: bold; color: #e74c3c; margin-bottom: 6px;"><i class="fas fa-ban"></i> 传统否决条款</div>
                                     ${wealthLevel.details.vetoDetails.map(item => {
                                         if (item.type === 'multiply') {
                                             return `<div style="color:#c0392b; font-size: 0.95rem; margin: 6px 0;">
                                                 ${item.name} × ${item.factor}：${Math.round(item.from)} → ${Math.round(item.to)} 分
                                             </div>`;
                                         } else if (item.type === 'cap') {
                                             return `<div style="color:#c0392b; font-size: 0.95rem; margin: 6px 0;">
                                                 ${item.name} 封顶：${Math.round(item.from)} → ${Math.round(item.to)} 分
                                             </div>`;
                                         } else {
                                             return `<div style="color:#c0392b; font-size: 0.95rem; margin: 6px 0;">
                                                 ${item.name}：${Math.round(item.from)} → ${Math.round(item.to)} 分
                                             </div>`;
                                         }
                                     }).join('')}
                                 </div>
                                 ` : ''}
                                 <p style="font-size: 0.9rem; color: #666; margin: 0; line-height: 1.5;">
                                     财富等级评分综合考虑八字中的财星配置、生财机制、库藏能力、流通状况等多个维度，结合传统命理与现代分析方法，为您提供专业的财运评估。
                                 </p>
                             </div>
                         </div>
                     </div>
                 </div>
             `;
         }

         // 获取分析内容（备用内容，当API调用失败时使用）
         function getAnalysisContent(analysisType) {
             const analysisData = {
                 'full-analysis': {
                     title: '命理全解',
                     content: `
                         <h4>八字命理全面解析</h4>
                         <div style="padding: 15px; margin-bottom: 15px; background: #f0f8ff; border-left: 4px solid #3498db; border-radius: 8px;">
                             <h5><i class="fas fa-user"></i> 性格特质</h5>
                             <p>性格温和稳重，做事认真负责，具有较强的责任感和使命感。思维缜密，善于分析问题，但有时过于追求完美。</p>
                         </div>
                         <div style="padding: 15px; margin-bottom: 15px; background: #fff5eb; border-left: 4px solid #e67e22; border-radius: 8px;">
                             <h5><i class="fas fa-briefcase"></i> 事业发展</h5>
                             <p>适合从事需要耐心和细致的工作，如教育、医疗、金融等领域。职业生涯中期将迎来重要转折点，有望获得晋升或创业机会。</p>
                         </div>
                         <div style="padding: 15px; margin-bottom: 15px; background: #f9f9f9; border-left: 4px solid #f1c40f; border-radius: 8px;">
                             <h5><i class="fas fa-coins"></i> 财富运势</h5>
                             <p>财运稳健，收入来源主要为工作薪资，中年后有机会获得额外财富。投资方面宜稳健为主，避免高风险投机。</p>
                         </div>
                         <div style="padding: 15px; margin-bottom: 15px; background: #ffebee; border-left: 4px solid #e74c3c; border-radius: 8px;">
                             <h5><i class="fas fa-heart"></i> 感情婚姻</h5>
                             <p>感情生活较为稳定，婚后家庭和睦。与伴侣相处需注重沟通，避免因工作忙碌而忽略家庭。</p>
                         </div>
                         <div style="padding: 15px; margin-bottom: 15px; background: #e8f5e9; border-left: 4px solid #27ae60; border-radius: 8px;">
                             <h5><i class="fas fa-heartbeat"></i> 健康状况</h5>
                             <p>体质中等，需要注意消化系统和呼吸系统的保养。建议保持规律作息，适当运动，避免过度劳累。</p>
                         </div>
                         <div style="padding: 15px; background: #e3f2fd; border-left: 4px solid #3498db; border-radius: 8px;">
                             <h5><i class="fas fa-star"></i> 人生建议</h5>
                             <p>1. 事业上保持稳健发展，同时不要错过关键机遇</p>
                             <p>2. 财务管理注重长期规划，建立多元化收入</p>
                             <p>3. 感情上增加沟通，平衡工作与家庭</p>
                             <p>4. 健康方面定期体检，保持良好生活习惯</p>
                         </div>
                     `
                 },
                 'annual-fortune': {
                     title: '流年分析',
                     content: `
                         <h4>当前流年运势分析</h4>
                         <p><strong>整体运势：</strong>今年运势较为平稳，有小幅上升趋势。甲木遇辰土，需要注意脾胃健康。</p>
                         <p><strong>事业运：</strong>工作上会有新的机遇出现，但需要谨慎把握，不宜冒进。</p>
                         <p><strong>财运：</strong>财运中等，正财稳定，偏财需谨慎。</p>
                         <p><strong>感情运：</strong>感情运势平稳，已婚者夫妻和睦，单身者有机会遇到合适对象。</p>
                         <p><strong>健康运：</strong>注意消化系统健康，适当运动，保持良好作息。</p>
                     `
                 },
                 'monthly-fortune': {
                     title: '流月分析',
                     content: `
                         <h4>当前年份各月运势预测</h4>
                         <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 15px;">
                             <div style="padding: 15px; background: #f8f9fa; border-radius: 8px;">
                                 <h5>春季（1-3月）</h5>
                                 <p>运势回升，适合开展新项目</p>
                             </div>
                             <div style="padding: 15px; background: #f8f9fa; border-radius: 8px;">
                                 <h5>夏季（4-6月）</h5>
                                 <p>运势旺盛，事业财运双丰收</p>
                             </div>
                             <div style="padding: 15px; background: #f8f9fa; border-radius: 8px;">
                                 <h5>秋季（7-9月）</h5>
                                 <p>运势平稳，需要稳扎稳打</p>
                             </div>
                             <div style="padding: 15px; background: #f8f9fa; border-radius: 8px;">
                                 <h5>冬季（10-12月）</h5>
                                 <p>运势略有下滑，宜保守行事</p>
                             </div>
                         </div>
                     `
                 },
                 'decade-fortune': {
                     title: '十年大运分析',
                     content: `
                         <h4>人生各阶段大运走势</h4>
                         <div style="margin-top: 15px;">
                             <div style="padding: 15px; margin-bottom: 15px; background: #e8f5e8; border-left: 4px solid #27ae60; border-radius: 8px;">
                                 <h5>青年期（20-30岁）</h5>
                                 <p>学业运佳，适合深造和技能提升。事业起步阶段，需要积累经验。</p>
                             </div>
                             <div style="padding: 15px; margin-bottom: 15px; background: #fff3cd; border-left: 4px solid #f39c12; border-radius: 8px;">
                                 <h5>壮年期（30-40岁）</h5>
                                 <p>事业发展的黄金期，财运逐渐好转，适合创业或投资。</p>
                             </div>
                             <div style="padding: 15px; margin-bottom: 15px; background: #d4edda; border-left: 4px solid #28a745; border-radius: 8px;">
                                 <h5>中年期（40-50岁）</h5>
                                 <p>运势达到顶峰，事业有成，财富积累丰厚，家庭和睦。</p>
                             </div>
                             <div style="padding: 15px; background: #cce5ff; border-left: 4px solid #007bff; border-radius: 8px;">
                                 <h5>晚年期（50岁以后）</h5>
                                 <p>运势平稳，享受人生，注重健康养生，子女孝顺。</p>
                             </div>
                         </div>
                     `
                 },
                 'personality': {
                     title: '性格分析',
                     content: `
                         <h4>性格特征分析</h4>
                         <p><strong>核心性格：</strong>性格温和，待人真诚，有责任心，做事认真负责。</p>
                         <p><strong>优点：</strong></p>
                         <ul>
                             <li>善良正直，品德高尚</li>
                             <li>勤奋努力，不怕吃苦</li>
                             <li>有耐心，能够坚持</li>
                             <li>重视家庭，孝顺父母</li>
                         </ul>
                         <p><strong>需要改进：</strong></p>
                         <ul>
                             <li>有时过于保守，缺乏冒险精神</li>
                             <li>容易犹豫不决，错失机会</li>
                             <li>对自己要求过高，压力较大</li>
                         </ul>
                         <p><strong>建议：</strong>适当增强自信心，勇于尝试新事物，学会适度放松。</p>
                     `
                 },
                 'career': {
                     title: '事业财富分析',
                     content: `
                         <h4>事业发展方向</h4>
                         <p><strong>适合行业：</strong>教育、文化、医疗、服务业、公务员等稳定性行业。</p>
                         <p><strong>职业特质：</strong>适合需要耐心和责任心的工作，不适合高风险高压力的行业。</p>
                         <p><strong>财富格局：</strong></p>
                         <ul>
                             <li>正财运较好，适合稳定收入的工作</li>
                             <li>偏财运一般，不宜投机取巧</li>
                             <li>理财能力强，善于积累财富</li>
                             <li>晚年财运更佳，越老越富</li>
                         </ul>
                         <p><strong>投资建议：</strong>选择稳健的投资方式，如定期存款、国债、蓝筹股等。</p>
                     `
                 },
                 'marriage': {
                     title: '婚姻分析',
                     content: `
                         <h4>婚姻感情分析</h4>
                         <p><strong>婚姻运势：</strong>婚姻运势较好，能够找到合适的伴侣，婚后生活和睦。</p>
                         <p><strong>配偶特征：</strong></p>
                         <ul>
                             <li>性格温和，善解人意</li>
                             <li>有一定的经济基础</li>
                             <li>重视家庭，顾家</li>
                             <li>可能从事稳定的职业</li>
                         </ul>
                         <p><strong>最佳结婚年龄：</strong>25-30岁之间，此时运势较好，容易遇到合适对象。</p>
                         <p><strong>婚姻建议：</strong>保持沟通，相互理解，共同经营家庭，避免因小事争吵。</p>
                     `
                 },
                 'children': {
                     title: '子女分析',
                     content: `
                         <h4>子女缘分分析</h4>
                         <p><strong>子女运：</strong>子女运较好，能够拥有健康聪明的孩子。</p>
                         <p><strong>子女特征：</strong></p>
                         <ul>
                             <li>聪明伶俐，学习能力强</li>
                             <li>性格活泼，富有创造力</li>
                             <li>孝顺懂事，与父母关系融洽</li>
                             <li>未来发展前景良好</li>
                         </ul>
                         <p><strong>教育建议：</strong></p>
                         <ul>
                             <li>注重品德教育，培养正确价值观</li>
                             <li>发掘孩子的兴趣爱好，因材施教</li>
                             <li>给予适当的自由空间，培养独立性</li>
                             <li>保持良好的亲子沟通</li>
                         </ul>
                     `
                 },
                 'health': {
                     title: '健康分析',
                     content: `
                         <h4>健康状况分析</h4>
                         <p><strong>整体健康：</strong>体质较好，但需要注意某些方面的保养。</p>
                         <p><strong>需要关注的健康问题：</strong></p>
                         <ul>
                             <li>消化系统：注意饮食规律，避免暴饮暴食</li>
                             <li>心血管：适当运动，控制情绪波动</li>
                             <li>呼吸系统：避免吸烟，注意空气质量</li>
                             <li>精神状态：学会放松，避免过度压力</li>
                         </ul>
                         <p><strong>养生建议：</strong></p>
                         <ul>
                             <li>保持规律作息，早睡早起</li>
                             <li>适当运动，如散步、太极等</li>
                             <li>饮食清淡，多吃蔬菜水果</li>
                             <li>定期体检，预防疾病</li>
                         </ul>
                     `
                 }
             };
             
             return analysisData[analysisType]?.content || '<p>分析内容正在生成中...</p>';
         }
         
         // Markdown内容格式化函数
         function formatMarkdownContent(content) {
             // 清理和预处理内容
             let formatted = content
                 .trim()
                 // 移除多余的空行，保留段落间距
                 .replace(/\n{3,}/g, '\n\n')
                 // 移除行首行尾空格
                 .replace(/^\s+|\s+$/gm, '')
                 // 移除所有#字符
                 .replace(/#/g, '');
             
             // 智能分段：按句号、问号、感叹号等结束符分段
             formatted = formatted
                 // 在句号、问号、感叹号后添加换行，但保留原有段落结构
                 .replace(/([。！？])([^\n])/g, '$1\n$2')
                 // 在冒号后如果跟着重要内容也分段
                 .replace(/([：:])([^\n]*[。！？])/g, '$1\n$2')
                 // 合并过短的行（少于10个字符）到前一行
                 .replace(/\n([^\n]{1,10})\n/g, ' $1\n');
             
             // 按段落分割处理
             const paragraphs = formatted.split(/\n\n+/);
             const processedParagraphs = [];
             
             for (let paragraph of paragraphs) {
                 if (!paragraph.trim()) continue;
                 
                 // 检测标题格式（扩展识别范围）
                 if (paragraph.match(/^[一二三四五六七八九十、]+[、.]/) || 
                     paragraph.match(/^\d+[、.]/) ||
                     paragraph.match(/^(总结|结论|建议|分析|概述|要点|重点|注意|提醒|性格|事业|财运|婚姻|健康|运势|命格|格局|用神|大运|流年|月令|日主|十神)[:：]?/) ||
                     paragraph.match(/^[【\[].*[】\]]/) ||
                     paragraph.length < 20 && paragraph.match(/[：:]$/)) {
                     processedParagraphs.push(`<div class="qa-section-title">${paragraph}</div>`);
                     continue;
                 }
                 
                 // 检测列表项
                 if (paragraph.match(/^[\s]*[-*]\s/) || paragraph.match(/^[\s]*\d+[.、]\s/)) {
                     const listItems = paragraph.split('\n')
                         .filter(line => line.trim())
                         .map(line => {
                             const cleanLine = line.replace(/^[\s]*[-*\d+.、]\s*/, '').trim();
                             return `<li class="qa-list-item">${cleanLine}</li>`;
                         })
                         .join('');
                     processedParagraphs.push(`<ul class="qa-list">${listItems}</ul>`);
                     continue;
                 }
                 
                 // 处理普通段落 - 按句子分行
                 let sentences = paragraph.split(/\n/).filter(s => s.trim());
                 let processedSentences = [];
                 
                 for (let sentence of sentences) {
                     let processedSentence = sentence.trim()
                         // 处理粗体
                         .replace(/\*\*(.*?)\*\*/g, '<strong class="qa-highlight">$1</strong>')
                         // 处理斜体
                         .replace(/\*(.*?)\*/g, '<em class="qa-emphasis">$1</em>')
                         // 处理关键词高亮
                         .replace(/(身强|身弱|喜用神|忌神|大运|流年|财运|事业|婚姻|健康|命格|格局|十神|月令|日主)/g, '<span class="qa-keyword">$1</span>');
                     
                     if (processedSentence) {
                         processedSentences.push(processedSentence);
                     }
                 }
                 
                 if (processedSentences.length > 0) {
                     // 将句子用<br>连接，形成紧凑但分明的段落
                     const paragraphContent = processedSentences.join('<br>');
                     processedParagraphs.push(`<p class="qa-paragraph">${paragraphContent}</p>`);
                 }
             }
             
             return processedParagraphs.join('');
         }
         
         // 显示命格评分详情弹窗
         function showFateScoreDetails() {
             const modal = document.getElementById('scoreDetailsModal');
             const title = document.getElementById('scoreDetailsTitle');
             const body = document.getElementById('scoreDetailsBody');
             
             title.innerHTML = '<i class="fas fa-star"></i> 命格等级评分详细依据';
             
             if (fateScoreDetails && Object.keys(fateScoreDetails).length > 0) {
                 body.innerHTML = `
                     <div style="background: rgba(248, 249, 250, 0.8); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                         <h4 style="color: var(--primary-color); margin-bottom: 12px;">
                             <i class="fas fa-calculator"></i> 命格等级评分构成
                         </h4>
                         <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 10px;">
                             <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 6px; padding: 10px;">
                                 <h6 style="color: #3498db; margin-bottom: 8px;">季节助力得分</h6>
                                 <div style="font-size: 1.3rem; font-weight: bold; color: #2c3e50; margin-bottom: 6px;">
                                     ${Number(fateScoreDetails.seasonScore || 0).toFixed(2)} 分
                                 </div>
                                 <p style="font-size: 0.9rem; color: #666; margin: 0;">
                                     月令得气、通根透干、调候等因素的综合评分，反映日主在出生月份的旺衰程度。
                                 </p>
                             </div>
                             
                             <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 6px; padding: 10px;">
                                 <h6 style="color: #27ae60; margin-bottom: 8px;">五行平衡得分</h6>
                                 <div style="font-size: 1.3rem; font-weight: bold; color: #2c3e50; margin-bottom: 6px;">
                                     ${Number(fateScoreDetails.balanceScore || 0).toFixed(2)} 分
                                 </div>
                                 <p style="font-size: 0.85rem; color: #666; margin: 0;">
                                     八字中五行分布的均衡性，考虑相生相克关系，评估命格的稳定性和协调度。
                                 </p>
                             </div>
                             
                             <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 6px; padding: 10px;">
                                 <h6 style="color: #9b59b6; margin-bottom: 8px;">格局结构得分</h6>
                                 <div style="font-size: 1.3rem; font-weight: bold; color: #2c3e50; margin-bottom: 6px;">
                                     ${Number(fateScoreDetails.patternScore || 0).toFixed(2)} 分
                                 </div>
                                 <p style="font-size: 0.85rem; color: #666; margin: 0;">
                                     识别特殊格局（如从格、化格等）及其完整性，评估命格层次的高低。
                                 </p>
                             </div>
                             
                             <div style="background: rgba(230, 126, 34, 0.08); border: 1px solid rgba(230, 126, 34, 0.15); border-radius: 6px; padding: 10px;">
                                 <h6 style="color: #e67e22; margin-bottom: 8px;">十神影响得分</h6>
                                 <div style="font-size: 1.3rem; font-weight: bold; color: #2c3e50; margin-bottom: 6px;">
                                     ${Number(fateScoreDetails.godsScore || 0).toFixed(2)} 分
                                 </div>
                                 <p style="font-size: 0.85rem; color: #666; margin: 0;">
                                     正官、七杀、正印、偏印、比肩、劫财、食神、伤官、正财、偏财的配置和作用。
                                 </p>
                             </div>
                             
                             <div style="background: rgba(231, 76, 60, 0.08); border: 1px solid rgba(231, 76, 60, 0.15); border-radius: 6px; padding: 10px;">
                                 <h6 style="color: #e74c3c; margin-bottom: 8px;">组合刑冲得分</h6>
                                 <div style="font-size: 1.3rem; font-weight: bold; color: #2c3e50; margin-bottom: 6px;">
                                     ${Number(fateScoreDetails.combinationScore || 0).toFixed(2)} 分
                                 </div>
                                 <p style="font-size: 0.85rem; color: #666; margin: 0;">
                                     地支三合、六合、相冲、相刑、相害等组合关系对命格的影响评估。
                                 </p>
                             </div>
                         </div>
                         
                         <div style="margin-top: 15px; padding: 10px; background: rgba(52, 73, 94, 0.05); border-radius: 6px; border-left: 3px solid var(--primary-color);">
                             <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                 <h5 style="margin: 0; color: var(--primary-color);">
                                     <i class="fas fa-chart-line"></i> 评分汇总
                                 </h5>
                                 <div style="font-size: 1.1rem; font-weight: bold; color: var(--gold-color);">
                                     总分：${Number(fateScoreDetails.total || 0).toFixed(2)} 分
                                 </div>
                             </div>
                             <p style="font-size: 0.85rem; color: #666; margin: 0; line-height: 1.4;">
                                 命格等级评分采用传统八字理论结合现代评分体系，从多个维度综合评估命格的优劣。
                                 分数越高表示命格层次越高，人生发展潜力越大。
                             </p>
                         </div>
                     </div>
                 `;
             } else {
                 body.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">暂无评分详情数据</p>';
             }
             
             modal.style.display = 'block';
         }
         
         // 显示财富评分详情弹窗
         function showWealthScoreDetails() {
             const modal = document.getElementById('scoreDetailsModal');
             const title = document.getElementById('scoreDetailsTitle');
             const body = document.getElementById('scoreDetailsBody');
             
             title.innerHTML = '<i class="fas fa-coins"></i> 财富等级评分详细依据';
             
             if (wealthScoreDetails && Object.keys(wealthScoreDetails).length > 0) {
                 body.innerHTML = `
                     <div style="background: rgba(248, 249, 250, 0.8); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                         <h4 style="color: var(--success-color); margin-bottom: 12px;">
                             <i class="fas fa-calculator"></i> 财富等级评分构成
                         </h4>
                         
                         <div style="margin-bottom: 15px;">
                             <h5 style="color: var(--primary-color); margin-bottom: 10px;">
                                 <i class="fas fa-layer-group"></i> 基础模块评分
                             </h5>
                             <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                                 <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 4px; padding: 8px;">
                                     <strong style="color: #3498db;">食伤生财：</strong> ${wealthScoreDetails.shishangScore || 0} 分
                                     <br><small style="color: #666;">食神伤官生财星的能力</small>
                                 </div>
                                 <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 4px; padding: 8px;">
                                     <strong style="color: #27ae60;">印绶护身：</strong> ${wealthScoreDetails.yinshouScore || 0} 分
                                     <br><small style="color: #666;">印星保护日主的作用</small>
                                 </div>
                                 <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 4px; padding: 8px;">
                                     <strong style="color: #9b59b6;">财星能量：</strong> ${wealthScoreDetails.wealthStarScore || 0} 分
                                     <br><small style="color: #666;">财星在八字中的力量</small>
                                 </div>
                                 <div style="background: rgba(230, 126, 34, 0.08); border: 1px solid rgba(230, 126, 34, 0.15); border-radius: 4px; padding: 8px;">
                                     <strong style="color: #e67e22;">财星位置：</strong> ${wealthScoreDetails.wealthPositionScore || 0} 分
                                     <br><small style="color: #666;">财星在四柱中的位置</small>
                                 </div>
                                 <div style="background: rgba(231, 76, 60, 0.08); border: 1px solid rgba(231, 76, 60, 0.15); border-radius: 4px; padding: 8px;">
                                     <strong style="color: #e74c3c;">财富库藏：</strong> ${wealthScoreDetails.wealthVaultScore || 0} 分
                                     <br><small style="color: #666;">财库的聚财能力</small>
                                 </div>
                                 <div style="background: rgba(52, 73, 94, 0.08); border: 1px solid rgba(52, 73, 94, 0.15); border-radius: 4px; padding: 8px;">
                                     <strong style="color: #34495e;">自坐财库：</strong> ${wealthScoreDetails.selfVaultScore || 0} 分
                                     <br><small style="color: #666;">日支为财库的情况</small>
                                 </div>
                                 <div style="background: rgba(26, 188, 156, 0.08); border: 1px solid rgba(26, 188, 156, 0.15); border-radius: 4px; padding: 8px;">
                                     <strong style="color: #1abc9c;">财气通门户：</strong> ${wealthScoreDetails.portalScore || 0} 分
                                     <br><small style="color: #666;">财气流通的顺畅度</small>
                                 </div>
                                 <div style="background: rgba(142, 68, 173, 0.08); border: 1px solid rgba(142, 68, 173, 0.15); border-radius: 4px; padding: 8px;">
                                     <strong style="color: #8e44ad;">日主承载：</strong> ${wealthScoreDetails.dayMasterCapacity || 0} 分
                                     <br><small style="color: #666;">日主承载财富的能力</small>
                                 </div>
                             </div>
                         </div>
                         
                         <div style="margin-bottom: 20px;">
                             <h5 style="color: var(--warning-color); margin-bottom: 12px;">
                                 <i class="fas fa-cogs"></i> 进阶与修正评分
                             </h5>
                             <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px;">
                                 <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #3498db;">喜忌平衡：</strong> ${wealthScoreDetails.favorableBalance || 0} 分
                                     <br><small style="color: #666;">喜用神与忌神的平衡</small>
                                 </div>
                                 <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #27ae60;">季节财运：</strong> ${wealthScoreDetails.seasonalWealthPotential || 0} 分
                                     <br><small style="color: #666;">出生季节对财运的影响</small>
                                 </div>
                                 <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #9b59b6;">财星保护：</strong> ${wealthScoreDetails.wealthProtectionScore || 0} 分
                                     <br><small style="color: #666;">财星的保护机制</small>
                                 </div>
                                 <div style="background: rgba(230, 126, 34, 0.08); border: 1px solid rgba(230, 126, 34, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #e67e22;">空亡扣分：</strong> -${wealthScoreDetails.kongWangPenalty || 0} 分
                                     <br><small style="color: #666;">空亡对财运的负面影响</small>
                                 </div>
                                 <div style="background: rgba(231, 76, 60, 0.08); border: 1px solid rgba(231, 76, 60, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #e74c3c;">流年修正：</strong> ${wealthScoreDetails.luckAdjustment || 0} 分
                                     <br><small style="color: #666;">当前流年的影响</small>
                                 </div>
                                 <div style="background: rgba(52, 73, 94, 0.08); border: 1px solid rgba(52, 73, 94, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #34495e;">大运强弱：</strong> ${wealthScoreDetails.dayunStrength || 0} 分
                                     <br><small style="color: #666;">当前大运对财运的作用</small>
                                 </div>
                             </div>
                         </div>
                         
                         <div style="margin-bottom: 20px;">
                             <h5 style="color: var(--danger-color); margin-bottom: 12px;">
                                 <i class="fas fa-star"></i> 格局与特效评分
                             </h5>
                             <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px;">
                                 <div style="background: rgba(52, 152, 219, 0.08); border: 1px solid rgba(52, 152, 219, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #3498db;">十神特效：</strong> ${wealthScoreDetails.tenGodsBonus || 0} 分
                                     <br><small style="color: #666;">十神配置的特殊效果</small>
                                 </div>
                                 <div style="background: rgba(39, 174, 96, 0.08); border: 1px solid rgba(39, 174, 96, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #27ae60;">特殊格局：</strong> ${wealthScoreDetails.specialBonus || 0} 分
                                     <br><small style="color: #666;">识别到的特殊财富格局</small>
                                 </div>
                                 <div style="background: rgba(155, 89, 182, 0.08); border: 1px solid rgba(155, 89, 182, 0.15); border-radius: 6px; padding: 12px;">
                                     <strong style="color: #9b59b6;">身财平衡：</strong> ${wealthScoreDetails.balanceAdjustment || 0} 分
                                     <br><small style="color: #666;">身强身弱与财星的平衡</small>
                                 </div>
                             </div>
                         </div>
                         
                         <div style="padding: 15px; background: rgba(52, 73, 94, 0.05); border-radius: 8px; border-left: 4px solid var(--success-color);">
                             <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                 <h5 style="margin: 0; color: var(--success-color);">
                                     <i class="fas fa-chart-bar"></i> 财富评分汇总
                                 </h5>
                                 <div style="display: flex; gap: 15px;">
                                     <div style="text-align: center;">
                                         <div style="font-size: 0.9rem; color: #666;">基础合计</div>
                                         <div style="font-size: 1.1rem; font-weight: bold; color: var(--primary-color);">
                                             ${wealthScoreDetails.baseScore || 0} 分
                                         </div>
                                     </div>
                                     <div style="text-align: center;">
                                         <div style="font-size: 0.9rem; color: #666;">否决前</div>
                                         <div style="font-size: 1.1rem; font-weight: bold; color: #8e44ad;">
                                             ${Math.round(wealthScoreDetails.beforeVetoScore || 0)} 分
                                         </div>
                                     </div>
                                     <div style="text-align: center;">
                                         <div style="font-size: 0.9rem; color: #666;">最终得分</div>
                                         <div style="font-size: 1.3rem; font-weight: bold; color: var(--success-color);">
                                             ${wealthScoreDetails.total || 0} 分
                                         </div>
                                     </div>
                                 </div>
                             </div>
                             ${Array.isArray(wealthScoreDetails.vetoDetails) && wealthScoreDetails.vetoDetails.length > 0 ? `
                             <div style="padding: 12px 12px 6px; background: rgba(231, 76, 60, 0.05); border-radius: 8px; border-left: 4px solid #e74c3c; margin-top: 10px;">
                                 <div style="font-weight: bold; color: #e74c3c; margin-bottom: 6px;"><i class="fas fa-ban"></i> 传统否决条款</div>
                                 ${wealthScoreDetails.vetoDetails.map(item => {
                                     if (item.type === 'multiply') {
                                         return `<div style="color:#c0392b; font-size: 0.95rem; margin: 6px 0;">
                                             ${item.name} × ${item.factor}：${Math.round(item.from)} → ${Math.round(item.to)} 分
                                         </div>`;
                                     } else if (item.type === 'cap') {
                                         return `<div style="color:#c0392b; font-size: 0.95rem; margin: 6px 0;">
                                             ${item.name} 封顶：${Math.round(item.from)} → ${Math.round(item.to)} 分
                                         </div>`;
                                     } else {
                                         return `<div style="color:#c0392b; font-size: 0.95rem; margin: 6px 0;">
                                             ${item.name}：${Math.round(item.from)} → ${Math.round(item.to)} 分
                                         </div>`;
                                     }
                                 }).join('')}
                             </div>
                             ` : ''}
                             <p style="font-size: 0.9rem; color: #666; margin: 0; line-height: 1.5;">
                                 财富等级评分综合考虑八字中的财星配置、生财机制、库藏能力、流通状况等多个维度，
                                 结合传统命理与现代分析方法，为您提供专业的财运评估。
                             </p>
                         </div>
                     </div>
                 `;
             } else {
                 body.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">暂无评分详情数据</p>';
             }
             
             modal.style.display = 'block';
         }
         
         // 关闭评分详情弹窗
         function closeScoreDetailsModal() {
             const modal = document.getElementById('scoreDetailsModal');
             modal.style.display = 'none';
         }
         
         // 点击弹窗外部关闭
         window.onclick = function(event) {
             const modal = document.getElementById('scoreDetailsModal');
             if (event.target === modal) {
                 modal.style.display = 'none';
             }
         }
         
         // 八字问答API调用
         async function callBaziQAAPI(question, data) {
             // 生成缓存键（处理中文字符）
             const questionHash = encodeURIComponent(question).slice(0, 50).replace(/%/g, '_');
             const cacheKey = `qa:${generateBaziHashKey(data)}:${questionHash}`;
             
             // 检查缓存
             const cachedResponse = localStorage.getItem(cacheKey);
             if (cachedResponse) {
                 return cachedResponse;
             }
             
             // 根据环境自动选择API URL
             const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
             const apiUrl = isLocalhost ? 'http://localhost:3001/api/deepseek' : 'https://deepseek-api-proxy.owenjass.workers.dev/api/deepseek';
             // 使用代理服务器，不直接暴露API Key
             const apiKey = 'placeholder_key_for_local_dev_only';
             
             // 获取当前日期和年份信息
             const today = new Date();
             const currentDateStr = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;
             const currentLunar = Lunar.fromDate(today);
             const currentYearGanZhi = currentLunar.getYearInGanZhi();
             const currentYear = today.getFullYear();
             
             // 从data对象中获取八字信息
             const userName = data.name || '用户';
             const genderStr = data.gender === 'male' ? '男' : (data.gender === 'female' ? '女' : '未知');
             const yearPillarStr = data.pillars?.year || '年柱未知';
             const monthPillarStr = data.pillars?.month || '月柱未知';
             const dayPillarStr = data.pillars?.day || '日柱未知';
             const hourPillarStr = data.pillars?.hour || '时柱未知';
             // 计算当前身强身弱（包含大运和流年影响）
             const currentStrengthData = calculateCurrentStrength(
                 data.pillars?.day?.charAt(0) || '',
                 data.elements || {},
                 data.pillars?.month?.charAt(1) || '',
                 new Date().getFullYear()
             );
             const strengthStr = currentStrengthData?.type || '身强身弱未知';
             const startingAgeStr = data.luckTiming?.description || '起运时间未知';
             
             // 构建prompt
             let prompt = `你是一位专业的八字命理大师，请基于以下准确的八字信息回答用户的问题。\n\n`;
             prompt += `【基本信息】\n`;
             prompt += `姓名：${userName}\n`;
             prompt += `性别：${genderStr}\n`;
             prompt += `当前日期：${currentDateStr}\n`;
             prompt += `当前流年：${currentYear}年${currentYearGanZhi}年\n\n`;
             
             prompt += `【八字信息】\n`;
             prompt += `年柱：${yearPillarStr}\n`;
             prompt += `月柱：${monthPillarStr}\n`;
             prompt += `日柱：${dayPillarStr}\n`;
             prompt += `时柱：${hourPillarStr}\n`;
             prompt += `当前身强身弱：${strengthStr}\n`;
             prompt += `起运时间：${startingAgeStr}\n\n`;
             
             prompt += `【用户问题】\n${question}\n\n`;
             
             prompt += `【回答要求】\n`;
             prompt += `1. 请基于以上准确的八字信息回答问题，不要重新计算八字\n`;
             prompt += `2. 回答要专业、准确、具体，避免模糊的表述\n`;
             prompt += `3. 如果问题涉及时间预测，请结合当前流年${currentYear}年${currentYearGanZhi}年进行分析\n`;
             prompt += `4. 用通俗易懂的语言解释，让普通人也能理解\n`;
             prompt += `5. 如果问题不是八字相关的，请礼貌地提醒用户只能回答八字命理相关问题\n`;
             prompt += `6. 回答应简洁明了，避免冗长\n`;
             
             try {
                 console.log('开始调用八字问答API...');
                 console.log('API URL:', apiUrl);
                 console.log('请求数据:', {
                     model: "deepseek-chat",
                     messages: [{ role: "user", content: prompt.substring(0, 200) + '...' }],
                     temperature: 0.7,
                     max_tokens: 1500
                 });
                 
                 const response = await fetch(apiUrl, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                         'Authorization': `Bearer ${apiKey}`
                     },
                     body: JSON.stringify({
                         model: "deepseek-chat",
                         messages: [
                             {
                                 role: "user",
                                 content: prompt
                             }
                         ],
                         temperature: 0.7,
                         max_tokens: 1500
                     })
                 });
                 
                 console.log('API响应状态:', response.status, response.statusText);
                 
                 if (!response.ok) {
                     const errorText = await response.text();
                     console.error('API错误响应:', errorText);
                     throw new Error(`API请求失败: ${response.status} - ${response.statusText}`);
                 }
                 
                 const responseData = await response.json();
                 console.log('API响应数据:', responseData);
                 
                 if (!responseData.choices || !responseData.choices[0] || !responseData.choices[0].message || !responseData.choices[0].message.content) {
                     console.error('API返回数据格式错误:', responseData);
                     throw new Error('API返回数据格式不正确');
                 }
                 
                 const answerContent = responseData.choices[0].message.content;
                 
                 if (!answerContent.trim()) {
                     throw new Error('API返回内容为空');
                 }
                 
                 console.log('API调用成功，返回内容长度:', answerContent.length);
                 
                 // 格式化回答内容（支持Markdown）
                 const formattedAnswer = `<div class="qa-answer">\n<h4><i class="fas fa-lightbulb"></i> 命理解答</h4>\n<div class="qa-content">${formatMarkdownContent(answerContent)}</div>\n</div>`;
                 
                 // 缓存结果（缓存时间较短，因为问答内容可能需要更新）
                 localStorage.setItem(cacheKey, formattedAnswer);
                 
                 return formattedAnswer;
             } catch (error) {
                 console.error('八字问答API调用失败 - 详细错误:', error);
                 console.error('错误堆栈:', error.stack);
                 throw error;
             }
         }
         
         // 通过DeepSeek API获取八字分析
         async function getBaziAnalysisFromDeepSeek(analysisType, data) {
             // 生成缓存键
             const cacheKey = `${generateBaziHashKey(data)}:${analysisType}`;
             
             // 检查缓存
             const cachedResponse = localStorage.getItem(cacheKey);
             if (cachedResponse) {
                 return cachedResponse;
             }
             
             // 使用本地代理服务器
             const apiUrl = 'https://deepseek-api-proxy.owenjass.workers.dev/api/deepseek'
             // 使用代理服务器，不直接暴露API Key
             const apiKey = 'placeholder_key_for_local_dev_only';
             
             // 获取当前日期
             const today = new Date();
             const currentDateStr = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;
             
             // 获取当前年份的天干地支
             const currentLunar = Lunar.fromDate(today);
             const currentYearGanZhi = currentLunar.getYearInGanZhi();
             const currentYear = today.getFullYear();
             
             // 从data对象中获取八字信息
             const userName = data.name || '用户';
             const genderStr = data.gender === 'male' ? '男' : (data.gender === 'female' ? '女' : '未知');
             const yearPillarStr = data.pillars?.year || '年柱未知';
             const monthPillarStr = data.pillars?.month || '月柱未知';
             const dayPillarStr = data.pillars?.day || '日柱未知';
             const hourPillarStr = data.pillars?.hour || '时柱未知';
             // 计算当前身强身弱（包含大运和流年影响）
             const currentStrengthData = calculateCurrentStrength(
                 data.pillars?.day?.charAt(0) || '',
                 data.elements || {},
                 data.pillars?.month?.charAt(1) || '',
                 new Date().getFullYear()
             );
             const strengthStr = currentStrengthData?.type || '身强身弱未知';
             const startingAgeStr = data.luckTiming?.description || '起运时间未知';
             
            const baziFullInfo = `${userName}，${genderStr}，八字信息是：${yearPillarStr}，${monthPillarStr}，${dayPillarStr}，${hourPillarStr}，当前身强身弱为${strengthStr}，${startingAgeStr}。`;
            const baziInfo = {
            baziFullInfo,
            yearPillar: yearPillarStr,
            monthPillar: monthPillarStr,
            dayPillar: dayPillarStr,
            hourPillar: hourPillarStr,
            strength: strengthStr,
            startingAge: startingAgeStr,
            elementsDistribution: data.elementsDistribution || {}
            };
             
             // 根据分析类型构建提示词
             let prompt = `请作为专业命理师，使用标准Markdown语法，基于以下本地计算的准确八字信息进行深度分析。当前日期：${currentDateStr}\n\n`;
             
             // 添加八字核心信息（使用完整的baziFullInfo）
             prompt += `### 八字信息\n`;
             prompt += `${baziFullInfo}\n\n`;
             
             // 添加五行分布信息
             if (baziInfo.elementsDistribution && Object.keys(baziInfo.elementsDistribution).length > 0) {
                 prompt += `- 五行分布：`;
                 Object.entries(baziInfo.elementsDistribution).forEach(([element, count]) => {
                     prompt += `${element}${count}个 `;
                 });
                 prompt += `\n\n`;
             }
             
             prompt += `**重要说明：以上八字、当前身强身弱判断（已包含大运和流年影响）和起运时间均为本地精确计算结果。您必须严格基于这些信息进行分析，绝对不要自行重新计算或使用其他值。**\n\n`;
             
             // 根据分析类型添加特定提示
             switch (analysisType) {
                 case 'full-analysis':
                     prompt += `请基于以上八字信息，进行全面的命理解析。分析内容应包括：\n`;
                     prompt += `1. 性格特质与天赋才能分析\n`;
                     prompt += `2. 事业发展方向与职业规划建议\n`;
                     prompt += `3. 财富运势与理财投资指导\n`;
                     prompt += `4. 感情婚姻状况与伴侣特征\n`;
                     prompt += `5. 健康状况评估与养生建议\n`;
                     prompt += `6. 人生各阶段重要转折点预测\n`;
                     prompt += `7. 提升运势的实用方法与建议\n`;
                     break;
                     
                 case 'annual-fortune':
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行详细的流年运势分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。分析内容应包括：\n`;
                     prompt += `1. ${currentYear}年${currentYearGanZhi}年整体运势概述\n`;
                     prompt += `2. 事业发展与工作机遇分析\n`;
                     prompt += `3. 财运分析（正财与偏财）\n`;
                     prompt += `4. 感情与人际关系运势\n`;
                     prompt += `5. 健康状况预警与建议\n`;
                     prompt += `6. 流年吉凶月份预测\n`;
                     prompt += `7. 化解不利因素的实用建议\n`;
                     break;
                     
                 case 'monthly-fortune':
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行详细的流月运势分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。分析内容应包括：\n`;
                     prompt += `1. ${currentYear}年各月运势总体趋势\n`;
                     prompt += `2. 按季节分析（春、夏、秋、冬）各月运势特点\n`;
                     prompt += `3. 重点月份的机遇与挑战\n`;
                     prompt += `4. 每月事业、财运、感情、健康关键点\n`;
                     prompt += `5. 月份吉凶日预测方法\n`;
                     prompt += `6. 不同月份的行动建议\n`;
                     break;
                     
                 case 'decade-fortune':
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行详细的十年大运分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。分析内容应包括：\n`;
                     prompt += `1. 人生各阶段大运走势概述\n`;
                     prompt += `2. 青年期（20-30岁）运势与发展方向\n`;
                     prompt += `3. 壮年期（30-40岁）事业与财富高峰期分析\n`;
                     prompt += `4. 中年期（40-50岁）稳定发展期特点\n`;
                     prompt += `5. 晚年期（50岁以后）运势变化\n`;
                     prompt += `6. 大运交接期的注意事项\n`;
                     prompt += `7. 如何把握各阶段机遇的建议\n`;
                     break;
                     
                 case 'personality':
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行详细的性格分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。分析内容应包括：\n`;
                     prompt += `1. 核心性格特质与天赋才能\n`;
                     prompt += `2. 性格优势与特长详解\n`;
                     prompt += `3. 性格中需要注意的弱点\n`;
                     prompt += `4. 人际交往模式与沟通风格\n`;
                     prompt += `5. 思维方式与决策特点\n`;
                     prompt += `6. 情绪管理能力分析\n`;
                     prompt += `7. 性格发展与自我提升建议\n`;
                     break;
                     
                 case 'career':
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行详细的事业财富分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。分析内容应包括：\n`;
                     prompt += `1. 最适合的职业领域与行业\n`;
                     prompt += `2. 职业发展路径与关键转折点\n`;
                     prompt += `3. 事业成功的关键因素\n`;
                     prompt += `4. 财富来源与积累模式\n`;
                     prompt += `5. 正财与偏财运势分析\n`;
                     prompt += `6. 投资理财建议与风险提示\n`;
                     prompt += `7. 事业与财富平衡的人生规划\n`;
                     break;
                     
                 case 'marriage':
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行详细的婚姻分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。分析内容应包括：\n`;
                     prompt += `1. 婚姻运势与缘分总体评估\n`;
                     prompt += `2. 理想伴侣的性格与特质描述\n`;
                     prompt += `3. 婚姻生活的特点与模式\n`;
                     prompt += `4. 婚姻中可能面临的挑战\n`;
                     prompt += `5. 最佳婚姻时机与年龄段\n`;
                     prompt += `6. 婚姻关系经营的建议\n`;
                     prompt += `7. 提升婚姻质量的实用方法\n`;
                     break;
                     
                 case 'children':
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行详细的子女分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。分析内容应包括：\n`;
                     prompt += `1. 子女缘分与数量预测\n`;
                     prompt += `2. 子女可能的性格特点\n`;
                     prompt += `3. 亲子关系的特点与互动模式\n`;
                     prompt += `4. 子女教育的最佳方式\n`;
                     prompt += `5. 子女成长中的关键阶段\n`;
                     prompt += `6. 如何培养子女的天赋与能力\n`;
                     prompt += `7. 亲子关系和谐的实用建议\n`;
                     break;
                     
                 case 'health':
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行详细的健康分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。分析内容应包括：\n`;
                     prompt += `1. 先天体质与健康状况评估\n`;
                     prompt += `2. 需要特别关注的身体系统\n`;
                     prompt += `3. 不同年龄段的健康风险\n`;
                     prompt += `4. 季节性健康变化与注意事项\n`;
                     prompt += `5. 适合的运动与锻炼方式\n`;
                     prompt += `6. 饮食调理与营养建议\n`;
                     prompt += `7. 预防疾病的养生保健方法\n`;
                     break;
                     
                 default:
                     prompt += `请基于以上本地计算的准确八字信息（包括当前身强身弱和起运时间），进行全面的命理分析。请不要重新计算八字、当前身强身弱或起运时间，直接使用提供的信息。\n`;
             }
             
             prompt += `\n请用人性化、清晰的语言表达，避免过于专业的术语，使普通人也能理解。分析要全面、深入、具体，不要笼统。`;
             
             try {
                 // 调用DeepSeek API
                 const response = await fetch(apiUrl, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                         'Authorization': `Bearer ${apiKey}`
                     },
                     body: JSON.stringify({
                         model: "deepseek-chat",
                         messages: [
                             {
                                 role: "user",
                                 content: prompt
                             }
                         ],
                         temperature: 0.7,
                         max_tokens: 2000
                     })
                 });
                 
                 if (!response.ok) {
                     throw new Error(`API请求失败: ${response.status}`);
                 }
                 
                 const data = await response.json();
                 
                 if (!data.choices || !data.choices[0] || !data.choices[0].message || !data.choices[0].message.content) {
                     throw new Error('API返回数据格式不正确');
                 }
                 
                 const analysisContent = data.choices[0].message.content;
                 
                 // 检查内容是否为空
                 if (!analysisContent.trim()) {
                     throw new Error('API返回内容为空');
                 }
                 
                 // 缓存结果
                 localStorage.setItem(cacheKey, analysisContent);
                 
                 return analysisContent;
             } catch (error) {
                 console.error('DeepSeek API调用失败:', error);
                 throw error;
             }
         }
         
         // 生成八字哈希键（用于缓存）
         function generateBaziHashKey(data) {
             return `${data.name}-${data.gender}-${data.birthDate}-${data.birthTime}`;
         }

         /* ==================== 用户管理功能 ==================== */

         // API配置
          const API_BASE = 'https://api.mybazi.net';
          const API_URL = `${API_BASE}/api`;

         // DOM元素
         const userWelcome = document.getElementById('userWelcome');
         const usernameDisplay = document.getElementById('usernameDisplay');
         const loginBtn = document.getElementById('loginBtn');
         const logoutBtn = document.getElementById('logoutBtn');

         const rechargeBtn = document.getElementById('rechargeBtn');
         const authModal = document.getElementById('authModal');
         const rechargeModal = document.getElementById('rechargeModal');
         const closeAuth = document.getElementById('closeAuth');
         const closeRecharge = document.getElementById('closeRecharge');
         const loginTab = document.getElementById('loginTab');
         const registerTab = document.getElementById('registerTab');
         const loginForm = document.getElementById('loginForm');
         const registerForm = document.getElementById('registerForm');
         const rechargeForm = document.getElementById('rechargeForm');
         const loginMessage = document.getElementById('loginMessage');
         const registerMessage = document.getElementById('registerMessage');
         const submitLogin = document.getElementById('submitLogin');
         const submitRegister = document.getElementById('submitRegister');
         const loginSpinner = document.getElementById('loginSpinner');
         const registerSpinner = document.getElementById('registerSpinner');

         // 检查登录状态
         function checkLoginStatus() {
             const token = localStorage.getItem('token');
             const username = localStorage.getItem('username');
             
             if (token && username) {
                 userWelcome.style.display = 'block';
                 usernameDisplay.textContent = username;
                 loginBtn.style.display = 'none';
                 document.getElementById('userButtonsContainer').style.display = 'flex';
                 document.getElementById('userBalance').style.display = 'block';
                 
                 // 更新余额
                 updateBalance();
             } else {
                 userWelcome.style.display = 'none';
                 loginBtn.style.display = 'block';
                 document.getElementById('userButtonsContainer').style.display = 'none';
                 document.getElementById('userBalance').style.display = 'none';
             }
         }

         // 更新用户余额
         async function updateBalance() {
             try {
                 const response = await fetch(`${API_URL}/user/balance`, {
                     headers: {
                         'Authorization': `Bearer ${localStorage.getItem('token')}`
                     }
                 });
                 
                 if (!response.ok) {
                     if (response.status === 401) {
                         // 处理未授权错误
                         localStorage.removeItem('token');
                         localStorage.removeItem('username');
                         checkLoginStatus();
                         throw new Error('会话已过期，请重新登录');
                     }
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 
                 const data = await response.json();
                 const balanceAmountEl = document.getElementById('balanceAmount');
                 
                 if (data.balance !== undefined && balanceAmountEl) {
                     balanceAmountEl.textContent = data.balance;
                 }
                 
                 // 同时更新充值弹窗中的余额显示
                 await updateBalanceDisplay();
             } catch (error) {
                 const balanceAmountEl = document.getElementById('balanceAmount');
                 if (balanceAmountEl) balanceAmountEl.textContent = '获取失败';
                 // 显示用户消息
                 showAuthMessage(document.getElementById('rechargeMessage') || loginMessage, error.message, 'error');
             }
         }

         // 更新余额支付弹窗中的余额显示
         async function updateBalanceDisplay() {
             try {
                 const response = await fetch(`${API_URL}/user/balance`, {
                     headers: {
                         'Authorization': `Bearer ${localStorage.getItem('token')}`
                     }
                 });
                 
                 if (response.ok) {
                     const data = await response.json();
                     const userBalanceDisplay = document.getElementById('userBalanceDisplay');
                     
                     if (data.balance !== undefined && userBalanceDisplay) {
                         userBalanceDisplay.textContent = parseFloat(data.balance).toFixed(2);
                         
                         // 检查余额是否充足
                         setTimeout(() => {
                             checkBalanceSufficient();
                         }, 100);
                     }
                 }
             } catch (error) {
                 console.error('更新余额显示失败:', error);
                 // 如果获取余额失败，显示默认值
                 const userBalanceDisplay = document.getElementById('userBalanceDisplay');
                 if (userBalanceDisplay) {
                     userBalanceDisplay.textContent = '0.00';
                     setTimeout(() => {
                         checkBalanceSufficient();
                     }, 100);
                 }
             }
         }

         // 切换登录/注册标签页
         function switchAuthTab(tab) {
             if (tab === 'login') {
                 loginTab.classList.add('active');
                 registerTab.classList.remove('active');
                 loginForm.classList.add('active');
                 registerForm.classList.remove('active');
             } else {
                 loginTab.classList.remove('active');
                 registerTab.classList.add('active');
                 loginForm.classList.remove('active');
                 registerForm.classList.add('active');
             }
             
             // 清空消息
             loginMessage.style.display = 'none';
             registerMessage.style.display = 'none';
         }

         // 显示/隐藏登录弹窗
         function toggleAuthModal(show) {
             if (show) {
                 authModal.style.display = 'block';
                 document.body.style.overflow = 'hidden';
             } else {
                 authModal.style.display = 'none';
                 document.body.style.overflow = '';
             }
         }

         // 处理登录
         async function handleLogin(e) {
             e.preventDefault();
             
             const username = document.getElementById('loginUsername').value.trim();
             const password = document.getElementById('loginPassword').value.trim();
             
             if (!username || !password) {
                 showAuthMessage(loginMessage, '请输入用户名和密码', 'error');
                 return;
             }
             
             submitLogin.disabled = true;
             loginSpinner.style.display = 'inline-block';
             document.getElementById('loginText').style.display = 'none';
             
             try {
                 const response = await fetch(`${API_BASE}/api/login`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ name: username, password })
                 });
                 
                 const result = await response.json();
                 
                 if (!response.ok) {
                     throw new Error(result.error || '登录失败');
                 }
                 
                 localStorage.setItem('token', result.token);
                 localStorage.setItem('username', username);
                 
                 // 新增: 获取并缓存完整用户信息，包括balance
                 const userResponse = await fetch(`${API_BASE}/api/user/profile`, {
                     method: 'GET',
                     headers: {
                         'Authorization': `Bearer ${result.token}`,
                         'Content-Type': 'application/json'
                     }
                 });
                 
                 if (userResponse.ok) {
                     const userData = await userResponse.json();
                     localStorage.setItem('userInfo', JSON.stringify(userData));
                 }
                 
                 showAuthMessage(loginMessage, '登录成功！', 'success');
                 checkLoginStatus();
                 
                 document.getElementById('loginUsername').value = '';
                 document.getElementById('loginPassword').value = '';
                 
                 setTimeout(() => {
                     toggleAuthModal(false);
                 }, 1500);
                 
             } catch (error) {
                 console.error('登录错误:', error);
                 showAuthMessage(loginMessage, error.message, 'error');
             } finally {
                 submitLogin.disabled = false;
                 loginSpinner.style.display = 'none';
                 document.getElementById('loginText').style.display = 'inline';
             }
         }

         // 处理注册
         async function handleRegister(e) {
             e.preventDefault();
             
             const username = document.getElementById('registerUsername').value.trim();
             const email = document.getElementById('registerEmail').value.trim();
             const password = document.getElementById('registerPassword').value.trim();
             const confirmPassword = document.getElementById('registerConfirmPassword').value.trim();
             
             if (!username || username.length < 4 || username.length > 16) {
                 showAuthMessage(registerMessage, '用户名长度应为4-16位', 'error');
                 return;
             }
             
             if (!email || !validateEmail(email)) {
                 showAuthMessage(registerMessage, '请输入有效的电子邮箱', 'error');
                 return;
             }
             
             if (!password || password.length < 6) {
                 showAuthMessage(registerMessage, '密码长度至少为6位', 'error');
                 return;
             }
             
             if (password !== confirmPassword) {
                 showAuthMessage(registerMessage, '两次输入的密码不一致', 'error');
                 return;
             }
             
             submitRegister.disabled = true;
             registerSpinner.style.display = 'inline-block';
             document.getElementById('registerText').style.display = 'none';
             
             try {
                 const response = await fetch(`${API_BASE}/api/register`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ name: username, email, password })
                 });
                 
                 const result = await response.json();
                 
                 if (!response.ok) {
                     throw new Error(result.error || '注册失败');
                 }
                 
                 localStorage.setItem('token', result.token);
                 localStorage.setItem('username', username);
                 
                 showAuthMessage(registerMessage, '注册成功！已自动登录', 'success');
                 checkLoginStatus();
                 
                 document.getElementById('registerUsername').value = '';
                 document.getElementById('registerEmail').value = '';
                 document.getElementById('registerPassword').value = '';
                 document.getElementById('registerConfirmPassword').value = '';
                 
                 setTimeout(() => {
                     toggleAuthModal(false);
                     switchAuthTab('login');
                 }, 1500);
                 
             } catch (error) {
                 showAuthMessage(registerMessage, error.message, 'error');
             } finally {
                 submitRegister.disabled = false;
                 registerSpinner.style.display = 'none';
                 document.getElementById('registerText').style.display = 'inline';
             }
         }

         // 处理退出登录
         function handleLogout() {
             localStorage.removeItem('token');
             localStorage.removeItem('username');
             checkLoginStatus();
             switchAuthTab('login');
         }

         // 显示认证消息
         function showAuthMessage(element, message, type) {
             element.textContent = message;
             element.className = 'auth-message ' + type;
             element.style.display = 'block';
             
             setTimeout(() => {
                 element.style.display = 'none';
             }, 3000);
         }

         // 验证邮箱格式
         function validateEmail(email) {
             const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
             return re.test(email);
         }

         // 密码显示/隐藏切换
         function togglePassword(inputId, icon) {
             const input = document.getElementById(inputId);
             if (input.type === 'password') {
                 input.type = 'text';
                 icon.classList.remove('fa-eye');
                 icon.classList.add('fa-eye-slash');
             } else {
                 input.type = 'password';
                 icon.classList.remove('fa-eye-slash');
                 icon.classList.add('fa-eye');
             }
         }

         // 处理余额支付
         async function handleRecharge(e) {
             e.preventDefault();
             
             // 根据财富等级计算支付金额
             const paymentAmount = calculatePaymentAmount(wealthScoreValue || 60); // 默认60分
             const rechargeSpinner = document.getElementById('rechargeSpinner');
             const rechargeText = document.getElementById('rechargeText');
             const rechargeMessage = document.getElementById('rechargeMessage');
             
             rechargeSpinner.style.display = 'inline-block';
             rechargeText.style.display = 'none';
             
             if (!localStorage.getItem('token')) {
                 rechargeMessage.textContent = '请先登录后再进行支付';
                 rechargeMessage.className = 'recharge-message error';
                 rechargeMessage.style.display = 'block';
                 rechargeSpinner.style.display = 'none';
                 rechargeText.style.display = 'inline';
                 return;
             }
             
             try {
                 // 余额支付处理 - 直接调用扣费接口
                 const token = localStorage.getItem('token');
                 if (!token) {
                     throw new Error('请先登录');
                 }
                 
                 const response = await fetch(`${API_BASE}/api/user/deduct`, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                         'Authorization': `Bearer ${token}`
                     },
                     body: JSON.stringify({ 
                         amount: paymentAmount, 
                         reason: '八字详批分析服务' 
                     })
                 });
                 
                 if (!response.ok) {
                     const errorData = await response.json().catch(() => ({}));
                     throw new Error(errorData.error || '余额支付失败');
                 }
                 
                 // 支付成功后的处理
                 rechargeMessage.textContent = '支付成功！正在为您展示详细分析...';
                 rechargeMessage.className = 'recharge-message success';
                 rechargeMessage.style.display = 'block';
                 
                 // 更新余额显示
                 await updateBalanceDisplay();
                 await updateBalance();
                 
                 // 支付成功后显示隐藏内容
                 const paidContent = document.getElementById('paid-content');
                 if (paidContent) {
                     paidContent.style.display = 'block';
                 }
                 
                 // 支付成功后禁用详批按钮
                 const detailedBtn = document.getElementById('detailed-analysis-btn');
                 if (detailedBtn) {
                     detailedBtn.disabled = true;
                     detailedBtn.innerHTML = '<i class="fas fa-check"></i> 已支付';
                     detailedBtn.style.opacity = '0.6';
                     detailedBtn.style.cursor = 'not-allowed';
                 }
                 
                 // 关闭弹窗
                 setTimeout(() => {
                     document.getElementById('rechargeModal').style.display = 'none';
                 }, 2000);
                 
             } catch (error) {
                 rechargeMessage.textContent = error.message;
                 rechargeMessage.className = 'recharge-message error';
                 rechargeMessage.style.display = 'block';
             } finally {
                 rechargeSpinner.style.display = 'none';
                 rechargeText.style.display = 'inline';
             }
         }
         
         // 检查余额是否充足
         async function checkBalanceSufficient() {
             // 根据财富等级计算支付金额
             const paymentAmount = calculatePaymentAmount(wealthScoreValue || 60); // 默认60分
             const userBalance = parseFloat(document.getElementById('userBalanceDisplay').textContent) || 0;
             const insufficientBalance = document.getElementById('insufficientBalance');
             const balancePayBtn = document.getElementById('balancePayBtn');
             
             if (userBalance < paymentAmount) {
                 insufficientBalance.style.display = 'flex';
                 balancePayBtn.disabled = true;
                 balancePayBtn.style.opacity = '0.5';
                 return false;
             } else {
                 insufficientBalance.style.display = 'none';
                 balancePayBtn.disabled = false;
                 balancePayBtn.style.opacity = '1';
                 return true;
             }
         }
         
         // 处理充值按钮点击
         function handleRechargeBalance() {
             // 通过Flutter通道跳转到Stripe充值页面
             if (window.FlutterNavigation) {
                 window.FlutterNavigation.postMessage('stripe_recharge');
             } else {
                 // 降级处理：在浏览器中直接跳转
                 window.location.href = 'stripe_recharge.html';
             }
         }

         // 处理真正的充值表单提交
         async function handleActualRecharge(e) {
             e.preventDefault();
             
             const amount = document.getElementById('actualRechargeAmount').value;
             const paymentMethod = document.querySelector('input[name="actualPaymentMethod"]:checked').value;
             const actualRechargeSpinner = document.getElementById('actualRechargeSpinner');
             const actualRechargeText = document.getElementById('actualRechargeText');
             const actualRechargeMessage = document.getElementById('actualRechargeMessage');
             
             actualRechargeSpinner.style.display = 'inline-block';
             actualRechargeText.style.display = 'none';
             
             try {
                 // 确保WWPay类可用
                 if (typeof window.wwPay === 'undefined') {
                     throw new Error('支付系统未初始化，请刷新页面重试');
                 }
                 
                 // 1. 创建充值订单
                 const orderResponse = await window.wwPay.createRechargeOrder(amount, paymentMethod);
                 
                 // 2. 跳转支付平台
                 await window.wwPay.redirectToPaymentGateway(orderResponse);
                 
                 // 3. 显示支付处理中提示
                 actualRechargeMessage.textContent = '正在跳转支付平台...';
                 actualRechargeMessage.style.color = 'white';
                 
             } catch (error) {
                 actualRechargeMessage.textContent = error.message;
                 actualRechargeMessage.style.color = 'red';
             } finally {
                 actualRechargeSpinner.style.display = 'none';
                 actualRechargeText.style.display = 'inline';
             }
         }

         // 初始化用户管理事件
         function initUserManagement() {
             // 检查登录状态
             checkLoginStatus();
             
             // 登录按钮事件
             if (loginBtn) {
                 loginBtn.addEventListener('click', () => {
                     toggleAuthModal(true);
                     switchAuthTab('login');
                 });
             }
             
             // 关闭弹窗事件
             if (closeAuth) {
                 closeAuth.addEventListener('click', () => toggleAuthModal(false));
             }
             
             if (closeRecharge) {
                 closeRecharge.addEventListener('click', () => {
                     rechargeModal.style.display = 'none';
                 });
             }
             
             // 弹窗外部点击关闭
             if (authModal) {
                 authModal.addEventListener('click', (e) => {
                     if (e.target === authModal) {
                         toggleAuthModal(false);
                     }
                 });
             }
             
             if (rechargeModal) {
                 rechargeModal.addEventListener('click', (e) => {
                     if (e.target === rechargeModal) {
                         rechargeModal.style.display = 'none';
                     }
                 });
             }
             
             // 标签页切换事件
             if (loginTab) {
                 loginTab.addEventListener('click', () => switchAuthTab('login'));
             }
             if (registerTab) {
                 registerTab.addEventListener('click', () => switchAuthTab('register'));
             }
             
             // 表单提交事件
             if (loginForm) {
                 loginForm.addEventListener('submit', handleLogin);
             }
             if (registerForm) {
                 registerForm.addEventListener('submit', handleRegister);
             }
             if (rechargeForm) {
                 rechargeForm.addEventListener('submit', handleRecharge);
             }
             
             // 退出登录事件
             if (logoutBtn) {
                 logoutBtn.addEventListener('click', handleLogout);
             }
             
             // Stripe充值按钮事件
             const stripeRechargeBtn = document.getElementById('stripeRechargeBtn');
             if (stripeRechargeBtn) {
                 stripeRechargeBtn.addEventListener('click', () => {
                     // 通过Flutter通道跳转到Stripe充值页面
                     if (window.FlutterNavigation) {
                         window.FlutterNavigation.postMessage('stripe_recharge');
                     } else {
                         // 降级处理：在浏览器中直接跳转
                         window.location.href = 'stripe_recharge.html';
                     }
                 });
             }
             
             // 余额充值按钮事件
             const rechargeBalanceBtn = document.getElementById('rechargeBalanceBtn');
             if (rechargeBalanceBtn) {
                 rechargeBalanceBtn.addEventListener('click', handleRechargeBalance);
             }

             // 真正充值弹窗的事件处理
             const actualRechargeModal = document.getElementById('actualRechargeModal');
             const closeActualRecharge = document.getElementById('closeActualRecharge');
             const actualRechargeForm = document.getElementById('actualRechargeForm');

             // 关闭真正充值弹窗
             if (closeActualRecharge) {
                 closeActualRecharge.addEventListener('click', () => {
                     actualRechargeModal.style.display = 'none';
                 });
             }

             // 点击弹窗外部关闭
             if (actualRechargeModal) {
                 actualRechargeModal.addEventListener('click', (e) => {
                     if (e.target === actualRechargeModal) {
                         actualRechargeModal.style.display = 'none';
                     }
                 });
             }

             // 真正充值表单提交
             if (actualRechargeForm) {
                 actualRechargeForm.addEventListener('submit', handleActualRecharge);
             }

         }

         // 页面加载完成后初始化用户管理
         document.addEventListener('DOMContentLoaded', function() {
             initUserManagement();
             
             // 检查第三方支付回调
             const urlParams = new URLSearchParams(window.location.search);
             if (urlParams.get('trade_status') === 'TRADE_SUCCESS') {
                 // 第三方支付成功，标记支付已验证
                 sessionStorage.setItem('bazi_payment_verified', 'true');
                 sessionStorage.removeItem('bazi_payment_processing');
                 
                 // 显示详批内容
                 setTimeout(() => {
                     showDetailedAnalysis();
                 }, 500);
                 
                 // 清理URL参数
                 const cleanUrl = window.location.pathname;
                 window.history.replaceState({}, document.title, cleanUrl);
             } else {
                 // 检查是否有有效的支付验证
                 const isVerified = sessionStorage.getItem('bazi_payment_verified');
                 
                 if (isVerified === 'true') {
                     // 已支付，显示详批内容
                     showDetailedAnalysis();
                 } else {
                     // 确保页面加载时隐藏付费内容（仅当未支付时）
                     const paidContent = document.getElementById('paid-content');
                     if (paidContent) {
                         paidContent.style.display = 'none';
                     }
                     
                     // 只清除处理中的状态，保留已验证的支付状态
                     sessionStorage.removeItem('bazi_payment_processing');
                     
                     // 重置详批按钮状态
                     const detailedBtn = document.getElementById('detailed-analysis-btn');
                     if (detailedBtn) {
                         detailedBtn.disabled = false;
                         detailedBtn.innerHTML = '立即详批';
                         detailedBtn.style.opacity = '1';
                         detailedBtn.style.cursor = 'pointer';
                     }
                 }
             }
             
             // 为详批按钮添加事件监听器
             const detailedBtn = document.getElementById('detailed-analysis-btn');
             if (detailedBtn) {
                 
                 detailedBtn.addEventListener('click', function() {
                     if (this.disabled) return;
                     
                     // 检查用户是否已登录
                     const token = localStorage.getItem('token');
                     if (!token) {
                         alert('请先登录后再进行详批');
                         toggleAuthModal(true);
                         switchAuthTab('login');
                         return;
                     }
                     
                     // 检查是否已经计算过八字（需要财富等级评分）
                     if (!wealthScoreValue || wealthScoreValue === 0) {
                         alert('请先进行八字测算，获得财富等级评分后再进行详批');
                         return;
                     }
                     
                     // 检查是否已经支付过（防止重复支付）
                     if (sessionStorage.getItem('bazi_payment_verified') === 'true') {
                         // 已支付，直接显示详批内容
                         showDetailedAnalysis();
                         return;
                     }
                     
                     // 标记支付流程开始
                     sessionStorage.setItem('bazi_payment_processing', 'true');
                     
                     // 根据财富等级评分计算收费金额
                     const paymentAmount = calculatePaymentAmount(wealthScoreValue);
                     
                     // 更新页面显示的支付金额
                     const paymentAmountDisplay = document.getElementById('paymentAmount');
                     if (paymentAmountDisplay) {
                         paymentAmountDisplay.textContent = `¥${paymentAmount.toFixed(2)}`;
                     }
                     
                     const rechargeAmount = document.getElementById('rechargeAmount');
                     if (rechargeAmount) {
                         rechargeAmount.value = paymentAmount.toString();
                         rechargeAmount.readOnly = true;
                     }
                     
                     // 显示收费说明
                     const rechargeNote = document.querySelector('.recharge-note');
                     if (rechargeNote) {
                         rechargeNote.innerHTML = `<i class="fas fa-info-circle"></i> 根据您的财富等级评分 ${wealthScoreValue} 分，按传统道家收费规矩，本次详批收费 ${paymentAmount} 元`;
                     }
                     
                     // 显示充值模态，但实际为支付详批
                     rechargeModal.style.display = 'block';
                     // 初始化余额显示
                     updateBalanceDisplay();
                 });
             }
         });

         // 检查用户登录状态
         function checkLoginStatus() {
             const token = localStorage.getItem('token');
             const username = localStorage.getItem('username');
             
             const loginBtn = document.getElementById('loginBtn');
             const userWelcome = document.getElementById('userWelcome');
             const usernameDisplay = document.getElementById('usernameDisplay');
             const rechargeBtn = document.getElementById('rechargeBtn');
             const logoutBtn = document.getElementById('logoutBtn');
             const userBalance = document.getElementById('userBalance');
             
             if (token && username) {
                 // 用户已登录
                 loginBtn.style.display = 'none';
                 userWelcome.style.display = 'block';
                 usernameDisplay.textContent = username;
                 document.getElementById('userButtonsContainer').style.display = 'flex';
                 userBalance.style.display = 'block';
                 // 加载用户余额
                 loadUserBalance();
             } else {
                 // 用户未登录
                 loginBtn.style.display = 'inline-block';
                 userWelcome.style.display = 'none';
                 document.getElementById('userButtonsContainer').style.display = 'none';
                 userBalance.style.display = 'none';
             }
         }
         
         // 加载用户余额
         async function loadUserBalance() {
             const token = localStorage.getItem('token');
             if (!token) return;
             
             try {
                 const response = await fetch(`${API_BASE}/api/user/balance`, {
                     headers: {
                         'Authorization': `Bearer ${token}`
                     }
                 });
                 
                 if (response.ok) {
                     const data = await response.json();
                     const balance = data.balance || 0;
                     document.getElementById('balanceAmount').textContent = balance.toFixed(2);
                 }
             } catch (error) {
                 console.error('获取用户余额失败:', error);
             }
         }
         
         // 显示详批内容的安全函数
         function showDetailedAnalysis() {
             // 验证支付状态
             if (sessionStorage.getItem('bazi_payment_verified') !== 'true') {
                 alert('请先完成支付后再查看详批内容');
                 return;
             }
             
             const paidContent = document.getElementById('paid-content');
             const detailedBtn = document.getElementById('detailed-analysis-btn');
             
             if (paidContent) {
                 paidContent.style.display = 'block';
             }
             
             if (detailedBtn) {
                 detailedBtn.disabled = true;
                 detailedBtn.innerHTML = '已详批';
                 detailedBtn.style.opacity = '0.6';
                 detailedBtn.style.cursor = 'not-allowed';
             }
         }
         
         // 处理支付成功回调
         function handlePaymentSuccess() {
             // 标记支付已验证
             sessionStorage.setItem('bazi_payment_verified', 'true');
             sessionStorage.removeItem('bazi_payment_processing');
             
             // 显示详批内容
             showDetailedAnalysis();
             
             // 显示成功提示
             alert('支付成功！详批内容已为您展示。');
         }
         
         // 为年命纳音、日主、特殊格局容器添加CSS类名以便移动端样式控制
         function addBaziInfoClasses() {
             const infoGrid = document.querySelector('[style*="grid-template-columns: repeat(3, 1fr)"]');
             if (infoGrid) {
                 infoGrid.classList.add('bazi-info-grid');
                 const cards = infoGrid.querySelectorAll('[style*="padding: 20px"]');
                 cards.forEach(card => card.classList.add('bazi-info-card'));
             }
         }
         
         // 注释掉页面可见性监听器，避免切换标签页时清除支付状态
         // 原监听器会在用户切换标签页时错误地处理支付状态
         /*
         document.addEventListener('visibilitychange', function() {
             if (document.visibilityState === 'visible') {
                 const isProcessing = sessionStorage.getItem('bazi_payment_processing');
                 const isVerified = sessionStorage.getItem('bazi_payment_verified');
                 
                 if (isProcessing === 'true' && isVerified !== 'true') {
                     sessionStorage.removeItem('bazi_payment_processing');
                     const paidContent = document.getElementById('paid-content');
                     if (paidContent) {
                         paidContent.style.display = 'none';
                     }
                     
                     const detailedBtn = document.getElementById('detailed-analysis-btn');
                     if (detailedBtn) {
                         detailedBtn.disabled = false;
                         detailedBtn.innerHTML = '立即详批';
                         detailedBtn.style.opacity = '1';
                         detailedBtn.style.cursor = 'pointer';
                     }
                 } else if (isVerified === 'true') {
                     showDetailedAnalysis();
                 }
             }
         });
         */
         
         // 根据财富等级评分计算支付金额
         function calculatePaymentAmount(wealthScore) {
             // 20分或以下：1元
             if (wealthScore <= 20) {
                 return 1;
             }
             // 120分或以上：30元
             if (wealthScore >= 120) {
                 return 30;
             }
             // 21-119分：按比例计算
             // 公式：1 + (wealthScore - 20) / (120 - 20) * (30 - 1)
             const ratio = (wealthScore - 20) / (120 - 20);
             const amount = 1 + ratio * 29;
             // 四舍五入到整数
             return Math.round(amount);
         }

     </script>
    </div> <!-- 闭合 container -->
    </div> <!-- 闭合 page-container -->
<script src="../js/wwpay.js"></script>
<script>
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof refreshBalanceDisplay === 'function') {
                refreshBalanceDisplay();
            } else if (window.BaziPay) {
                window.BaziPay.refreshBalanceDisplay();
            }
        });
        
        // 添加测试函数
        function testSpecificBazi() {
            console.log('=== 开始测试特定八字 ===');
            
            // 测试数据：壬子年、癸丑月、己巳日、癸酉时
            const testData = {
                year: 1972,
                month: 12,
                day: 25,
                hour: 17,
                minute: 30,
                gender: 'male'
            };
            
            try {
                const solar = Solar.fromYmdHms(testData.year, testData.month, testData.day, testData.hour, testData.minute, 0);
                const lunar = solar.getLunar();
                const eightChar = lunar.getEightChar();
                
                console.log('八字信息:');
                console.log('年柱:', eightChar.getYear());
                console.log('月柱:', eightChar.getMonth());
                console.log('日柱:', eightChar.getDay());
                console.log('时柱:', eightChar.getTime());
                
                // 提取八字信息
                const dayStem = eightChar.getDay().charAt(0); // 日干
                const monthBranch = eightChar.getMonth().charAt(1); // 月支
                
                // 构建elements数组（包含所有天干地支）
                const elements = {
                    stems: [
                        eightChar.getYear().charAt(0),
                        eightChar.getMonth().charAt(0),
                        eightChar.getDay().charAt(0),
                        eightChar.getTime().charAt(0)
                    ],
                    branches: [
                        eightChar.getYear().charAt(1),
                        eightChar.getMonth().charAt(1),
                        eightChar.getDay().charAt(1),
                        eightChar.getTime().charAt(1)
                    ]
                };
                
                console.log('日干:', dayStem);
                console.log('月支:', monthBranch);
                console.log('天干:', elements.stems);
                console.log('地支:', elements.branches);
                
                // 调用身强身弱分析
                const result = calculateStrength(dayStem, elements, monthBranch);
                console.log('=== 测试结果 ===');
                console.log('强度比例:', result.ratio);
                console.log('强度百分比:', (result.ratio * 100).toFixed(2) + '%');
                console.log('生扶力量:', result.supportStrength);
                console.log('克泄力量:', result.weakenStrength);
                console.log('月令得分:', result.monthScore);
                console.log('身强身弱类型:', result.type);
                
                // 在页面上显示结果
                displayResult(result);
                
                // 将结果写入到页面标题中，方便提取
                document.title = `测试结果: ${(result.ratio * 100).toFixed(2)}% | 生扶:${result.supportStrength} | 克泄:${result.weakenStrength} | 月令:${result.monthScore} | 类型:${result.type}`;
                
            } catch (error) {
                console.error('测试出错:', error);
                console.error('错误消息:', error.message);
                console.error('错误堆栈:', error.stack);
                
                // 将错误信息写入页面标题
                document.title = `错误: ${error.message || '未知错误'}`;
            }
        }
        
        // 页面加载完成后自动执行测试
        setTimeout(() => {
            testSpecificBazi();
        }, 1000);
        
        // 添加一个全局函数来手动触发测试
        window.runTest = testSpecificBazi;
        
        // 在页面上显示结果
        function displayResult(result) {
            const resultDiv = document.createElement('div');
            resultDiv.style.cssText = 'position:fixed;top:10px;right:10px;background:white;border:2px solid black;padding:10px;z-index:9999;';
            const strengthPercentage = result.ratio ? (result.ratio * 100).toFixed(2) : '0.00';
            resultDiv.innerHTML = `
                <h3>测试结果</h3>
                <p>强度百分比: ${strengthPercentage}%</p>
                <p>生扶力量: ${result.supportStrength}</p>
                <p>克泄力量: ${result.weakenStrength}</p>
                <p>月令得分: ${result.monthScore}</p>
                <p>身强身弱类型: ${result.type}</p>
            `;
            document.body.appendChild(resultDiv);
        }
    </script>
    </body>
</html>
