<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>命格评分对比测试</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
        .score-item { margin: 5px 0; }
        .difference { color: red; font-weight: bold; }
        .same { color: green; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>命格评分对比测试 - 壬子，癸丑，己巳，癸酉</h1>
    
    <div class="test-section">
        <h2>测试八字信息</h2>
        <p><strong>八字：</strong>壬子，癸丑，己巳，癸酉</p>
        <p><strong>baziphone.html预期得分：</strong>93分</p>
        <p><strong>app当前得分：</strong>57分</p>
        <p><strong>差异：</strong>36分</p>
    </div>

    <div class="test-section">
        <h2>baziphone.html评分详情</h2>
        <div id="baziphone-scores"></div>
        <button onclick="testBaziphoneScoring()">测试baziphone.html评分</button>
    </div>

    <div class="test-section">
        <h2>对比分析</h2>
        <table id="comparison-table">
            <thead>
                <tr>
                    <th>评分项目</th>
                    <th>baziphone.html</th>
                    <th>app预期</th>
                    <th>差异</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody id="comparison-body">
            </tbody>
        </table>
    </div>

    <script>
        // 复制baziphone.html中的关键函数
        function getElementMap() {
            return {
                '甲': 'wood', '乙': 'wood',
                '丙': 'fire', '丁': 'fire',
                '戊': 'earth', '己': 'earth',
                '庚': 'metal', '辛': 'metal',
                '壬': 'water', '癸': 'water'
            };
        }

        function getHiddenStems(branch) {
            const hiddenStemsMap = {
                '子': ['癸'],
                '丑': ['己', '癸', '辛'],
                '寅': ['甲', '丙', '戊'],
                '卯': ['乙'],
                '辰': ['戊', '乙', '癸'],
                '巳': ['丙', '庚', '戊'],
                '午': ['丁', '己'],
                '未': ['己', '丁', '乙'],
                '申': ['庚', '壬', '戊'],
                '酉': ['辛'],
                '戌': ['戊', '辛', '丁'],
                '亥': ['壬', '甲']
            };
            return hiddenStemsMap[branch] || [];
        }

        // 月令强弱评分
        function calculateMonthlyStrength(dayStem, monthBranch) {
            const strengthMap = {
                '己': { '寅': 5, '卯': 8, '辰': 20, '巳': 18, '午': 15, '未': 25, '申': 10, '酉': 12, '戌': 20, '亥': 5, '子': 8, '丑': 25 }
            };
            return strengthMap[dayStem]?.[monthBranch] || 10;
        }

        // 通根强度计算
        function calculateRootStrength(dayStem, pillars) {
            const branches = [pillars.year.charAt(1), pillars.month.charAt(1), pillars.day.charAt(1), pillars.hour.charAt(1)];
            const elementMap = getElementMap();
            const dayElement = elementMap[dayStem];
            
            let rootScore = 0;
            
            branches.forEach((branch, index) => {
                const hiddenStems = getHiddenStems(branch);
                const mainStem = hiddenStems[0]; // 主气
                
                // 主气同类加分
                if (elementMap[mainStem] === dayElement) {
                    const weight = index === 2 ? 1.5 : 1.0; // 日支权重更高
                    rootScore += 8 * weight;
                }
                
                // 藏干同类加分
                hiddenStems.slice(1).forEach(stem => {
                    if (elementMap[stem] === dayElement) {
                        const weight = index === 2 ? 1.2 : 0.8;
                        rootScore += 3 * weight;
                    }
                });
            });
            
            return Math.min(15, rootScore);
        }

        // 透干强度计算
        function calculateTransparentStrength(dayStem, pillars) {
            const stems = [pillars.year.charAt(0), pillars.month.charAt(0), pillars.hour.charAt(0)];
            const elementMap = getElementMap();
            const dayElement = elementMap[dayStem];
            
            let transparentScore = 0;
            
            stems.forEach((stem, index) => {
                if (elementMap[stem] === dayElement) {
                    const weight = index === 1 ? 1.2 : 1.0; // 月干权重稍高
                    transparentScore += 6 * weight;
                }
            });
            
            return Math.min(12, transparentScore);
        }

        // 调候因子计算
        function calculateSeasonalAdjustment(dayStem, monthBranch) {
            const adjustmentMap = {
                '己': { '寅': 0.7, '卯': 0.8, '辰': 1.1, '巳': 1.0, '午': 0.9, '未': 1.2, '申': 0.8, '酉': 0.9, '戌': 1.1, '亥': 0.7, '子': 0.6, '丑': 1.1 }
            };
            return adjustmentMap[dayStem]?.[monthBranch] || 1.0;
        }

        // 高级季节助力评分
        function calculateAdvancedSeasonScore(pillars) {
            const dayStem = pillars.day.charAt(0);
            const monthBranch = pillars.month.charAt(1);
            
            // 月令得分基础
            let baseScore = calculateMonthlyStrength(dayStem, monthBranch);
            
            // 通根透干加分
            const rootScore = calculateRootStrength(dayStem, pillars);
            
            // 透干加分
            const transparentScore = calculateTransparentStrength(dayStem, pillars);
            
            // 调候因子
            const seasonalAdjustment = calculateSeasonalAdjustment(dayStem, monthBranch);
            
            const finalScore = (baseScore + rootScore + transparentScore) * seasonalAdjustment;
            return Math.max(0, Math.min(30, finalScore));
        }

        function testBaziphoneScoring() {
            const pillars = {
                year: '壬子',
                month: '癸丑',
                day: '己巳',
                hour: '癸酉'
            };

            console.log('=== baziphone.html评分测试 ===');
            console.log('八字:', pillars);

            // 测试季节助力评分
            const seasonScore = Math.round(calculateAdvancedSeasonScore(pillars) * 0.67);
            console.log('季节助力评分:', seasonScore);

            // 显示详细计算过程
            const dayStem = pillars.day.charAt(0); // 己
            const monthBranch = pillars.month.charAt(1); // 丑
            
            const baseScore = calculateMonthlyStrength(dayStem, monthBranch);
            const rootScore = calculateRootStrength(dayStem, pillars);
            const transparentScore = calculateTransparentStrength(dayStem, pillars);
            const seasonalAdjustment = calculateSeasonalAdjustment(dayStem, monthBranch);
            
            console.log('详细计算过程:');
            console.log('- 月令基础分:', baseScore);
            console.log('- 通根加分:', rootScore);
            console.log('- 透干加分:', transparentScore);
            console.log('- 调候因子:', seasonalAdjustment);
            console.log('- 最终得分:', (baseScore + rootScore + transparentScore) * seasonalAdjustment);
            console.log('- 系数调整后:', seasonScore);

            // 显示结果
            const resultDiv = document.getElementById('baziphone-scores');
            resultDiv.innerHTML = `
                <div class="score-item">季节助力评分: ${seasonScore}分</div>
                <div class="score-item">月令基础分: ${baseScore}分</div>
                <div class="score-item">通根加分: ${rootScore}分</div>
                <div class="score-item">透干加分: ${transparentScore}分</div>
                <div class="score-item">调候因子: ${seasonalAdjustment}</div>
                <div class="score-item">原始得分: ${((baseScore + rootScore + transparentScore) * seasonalAdjustment).toFixed(2)}分</div>
                <div class="score-item">系数调整后: ${seasonScore}分</div>
            `;
        }
    </script>
</body>
</html>