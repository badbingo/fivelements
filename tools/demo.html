<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>八字计算器 - 麦八字教学网</title>
    <link rel="stylesheet" href="../css/style1.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="../css/navigation.css">
    <script defer src="../js/navigation.js"></script>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2NHJXGKS0Y"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-2NHJXGKS0Y');
    </script>
    
    <style>
        /* 之前的所有CSS样式保持不变 */
        /* ... */
    </style>
</head>
<body>
    <!-- 之前的HTML结构保持不变 -->
    <!-- ... -->

    <script src="../js/lunar.js"></script>
    <script>
        // 八字分析主函数
        class BaziAnalyzer {
            constructor() {
                this.lunar = null;
                this.bazi = null;
                this.solarDate = null;
                this.gender = 'male';
            }
            
            // 从表单获取数据并计算八字
            calculateFromForm(formData) {
                const [year, month, day] = formData.birthDate.split('-').map(Number);
                const hour = parseInt(formData.birthHour);
                const minute = parseInt(formData.birthMinute);
                const timezone = parseInt(formData.timezone);
                this.gender = formData.gender;
                
                // 创建阳历日期对象
                this.solarDate = new Date(year, month - 1, day, hour, minute);
                
                // 计算农历和八字
                this.lunar = Lunar.fromDate(this.solarDate);
                this.bazi = this.lunar.getBaZi();
                
                return this.analyzeBazi();
            }
            
            // 分析八字数据
            analyzeBazi() {
                if (!this.bazi) return null;
                
                // 获取四柱
                const pillars = this.bazi.getPillars();
                
                // 1. 身强身弱分析
                const strength = this.analyzeStrength(pillars);
                
                // 2. 十神分析
                const tenGods = this.analyzeTenGods(pillars);
                
                // 3. 五行平衡分析
                const wuxing = this.analyzeWuxing(pillars);
                
                // 4. 特殊组合分析
                const combinations = this.analyzeCombinations(pillars);
                
                // 5. 用神忌神分析
                const usefulGods = this.analyzeUsefulGods(strength, wuxing);
                
                // 6. 运势分析
                const luck = this.analyzeLuck();
                
                return {
                    pillars,
                    strength,
                    tenGods,
                    wuxing,
                    combinations,
                    usefulGods,
                    luck,
                    solarDate: this.solarDate,
                    lunarDate: this.lunar
                };
            }
            
            // 身强身弱分析
            analyzeStrength(pillars) {
                const dayStem = pillars.day.stem; // 日主
                const monthBranch = pillars.month.branch; // 月令
                
                // 计算得令、得地、得势
                let score = 0;
                
                // 1. 得令（月令对日主的影响）
                const monthRelation = this.getStemBranchRelation(dayStem, monthBranch);
                if (['same', 'bornBy', 'helpBy'].includes(monthRelation)) {
                    score += 2;
                } else if (['restBy', 'consumeBy'].includes(monthRelation)) {
                    score -= 1;
                }
                
                // 2. 得地（地支藏干对日主的影响）
                pillars.forEach(pillar => {
                    const hiddenStems = pillar.branch.getHideStems();
                    hiddenStems.forEach(stem => {
                        const relation = this.getStemRelation(dayStem, stem);
                        if (relation === 'same') score += 0.5;
                        if (['bornBy', 'helpBy'].includes(relation)) score += 0.3;
                    });
                });
                
                // 3. 得势（天干对日主的影响）
                pillars.forEach(pillar => {
                    const relation = this.getStemRelation(dayStem, pillar.stem);
                    if (relation === 'same') score += 1;
                    if (['bornBy', 'helpBy'].includes(relation)) score += 0.5;
                });
                
                // 判断身强身弱
                let result = '身中';
                if (score >= 3) result = '身强';
                if (score <= 1) result = '身弱';
                
                return {
                    score,
                    result,
                    analysis: this.getStrengthAnalysis(result, dayStem)
                };
            }
            
            // 十神分析
            analyzeTenGods(pillars) {
                const dayStem = pillars.day.stem;
                const tenGodsMap = {};
                
                // 分析天干十神
                pillars.forEach(pillar => {
                    const stem = pillar.stem;
                    const relation = this.getStemRelation(dayStem, stem);
                    tenGodsMap[relation] = (tenGodsMap[relation] || 0) + 1;
                });
                
                // 分析地支藏干十神
                pillars.forEach(pillar => {
                    const hiddenStems = pillar.branch.getHideStems();
                    hiddenStems.forEach(stem => {
                        const relation = this.getStemRelation(dayStem, stem);
                        tenGodsMap[relation] = (tenGodsMap[relation] || 0) + 0.5;
                    });
                });
                
                // 十神解释
                const tenGodsInfo = {
                    'same': { name: '比肩', desc: '代表兄弟姐妹、朋友同事，性格独立自主' },
                    'helpBy': { name: '劫财', desc: '代表竞争、破财，性格外向活跃' },
                    'bornBy': { name: '食神', desc: '代表才华、口福，性格温和有创意' },
                    'bornOf': { name: '伤官', desc: '代表才华、反叛，聪明但任性' },
                    'consumeBy': { name: '正财', desc: '代表稳定收入、妻子，性格务实' },
                    'consumeOf': { name: '偏财', desc: '代表意外之财、父亲，性格慷慨' },
                    'restBy': { name: '正官', desc: '代表职位、名誉，性格正直' },
                    'restOf': { name: '七杀', desc: '代表压力、竞争，性格果断' },
                    'helpOf': { name: '正印', desc: '代表学问、母亲，性格仁慈' },
                    'bornTo': { name: '偏印', desc: '代表特殊才能、继母，性格内向' }
                };
                
                // 生成十神分布分析
                let distribution = '';
                Object.entries(tenGodsMap).forEach(([relation, count]) => {
                    const info = tenGodsInfo[relation];
                    if (info && count > 0) {
                        distribution += `${info.name}(${count.toFixed(1)}) `;
                    }
                });
                
                return {
                    map: tenGodsMap,
                    info: tenGodsInfo,
                    distribution,
                    analysis: this.getTenGodsAnalysis(tenGodsMap, tenGodsInfo)
                };
            }
            
            // 五行平衡分析
            analyzeWuxing(pillars) {
                const wuxingMap = { '木': 0, '火': 0, '土': 0, '金': 0, '水': 0 };
                
                // 统计天干五行
                pillars.forEach(pillar => {
                    const stemWuxing = pillar.stem.getWuXing();
                    wuxingMap[stemWuxing] += 1;
                });
                
                // 统计地支五行
                pillars.forEach(pillar => {
                    const branchWuxing = pillar.branch.getWuXing();
                    wuxingMap[branchWuxing] += 1;
                });
                
                // 统计藏干五行
                pillars.forEach(pillar => {
                    const hiddenStems = pillar.branch.getHideStems();
                    hiddenStems.forEach(stem => {
                        const wuxing = stem.getWuXing();
                        wuxingMap[wuxing] += 0.5;
                    });
                });
                
                // 计算五行百分比
                const total = Object.values(wuxingMap).reduce((a, b) => a + b, 0);
                const wuxingPercent = {};
                Object.keys(wuxingMap).forEach(key => {
                    wuxingPercent[key] = Math.round((wuxingMap[key] / total) * 100);
                });
                
                return {
                    map: wuxingMap,
                    percent: wuxingPercent,
                    analysis: this.getWuxingAnalysis(wuxingMap)
                };
            }
            
            // 特殊组合分析
            analyzeCombinations(pillars) {
                const combinations = [];
                
                // 检查三合局
                const branches = pillars.map(p => p.branch);
                const sanhe = this.checkSanhe(branches);
                if (sanhe) combinations.push(sanhe);
                
                // 检查六合
                const liuhe = this.checkLiuhe(branches);
                if (liuhe) combinations.push(liuhe);
                
                // 检查天干五合
                const stems = pillars.map(p => p.stem);
                const wuhe = this.checkWuhe(stems);
                if (wuhe) combinations.push(wuhe);
                
                return {
                    list: combinations,
                    analysis: this.getCombinationAnalysis(combinations)
                };
            }
            
            // 用神忌神分析
            analyzeUsefulGods(strength, wuxing) {
                const dayStem = this.bazi.getPillars().day.stem;
                const dayWuxing = dayStem.getWuXing();
                const wuxingOrder = ['木', '火', '土', '金', '水'];
                
                // 根据身强身弱确定用神
                let useful = [], avoid = [];
                
                if (strength.result === '身强') {
                    // 身强宜克泄
                    useful.push(wuxingOrder[(wuxingOrder.indexOf(dayWuxing) + 2 % 5]); // 克
                    useful.push(wuxingOrder[(wuxingOrder.indexOf(dayWuxing) + 1 % 5]); // 泄
                    avoid.push(dayWuxing); // 忌同类
                    avoid.push(wuxingOrder[(wuxingOrder.indexOf(dayWuxing) + 4 % 5]); // 忌生
                } else {
                    // 身弱宜生扶
                    useful.push(wuxingOrder[(wuxingOrder.indexOf(dayWuxing) + 4 % 5]); // 生
                    useful.push(dayWuxing); // 扶
                    avoid.push(wuxingOrder[(wuxingOrder.indexOf(dayWuxing) + 2 % 5]); // 忌克
                    avoid.push(wuxingOrder[(wuxingOrder.indexOf(dayWuxing) + 1 % 5]); // 忌泄
                }
                
                // 考虑五行平衡调整
                Object.entries(wuxing.percent).forEach(([wx, percent]) => {
                    if (percent < 20 && useful.includes(wx)) {
                        useful = useful.filter(w => w !== wx);
                    }
                    if (percent > 60 && !avoid.includes(wx)) {
                        avoid.push(wx);
                    }
                });
                
                return {
                    useful: [...new Set(useful)],
                    avoid: [...new Set(avoid)],
                    analysis: this.getUsefulGodsAnalysis(useful, avoid, strength.result)
                };
            }
            
            // 运势分析
            analyzeLuck() {
                const dayStem = this.bazi.getPillars().day.stem;
                const genderModifier = this.gender === 'male' ? 1 : -1;
                const luckPillars = this.bazi.getLuckPillars(genderModifier);
                
                // 大运分析
                const luckCycles = luckPillars.map((pillar, index) => {
                    const startAge = index * 10;
                    const endAge = (index + 1) * 10;
                    
                    return {
                        name: `第${index + 1}步大运`,
                        ageRange: `${startAge}-${endAge}岁`,
                        ganzhi: pillar.toString(),
                        description: this.getLuckDescription(pillar, dayStem)
                    };
                });
                
                // 流年分析
                const currentYear = new Date().getFullYear();
                const yearPillar = this.lunar.getYearPillar(currentYear);
                const yearAnalysis = this.getYearLuckAnalysis(yearPillar, dayStem);
                
                return {
                    cycles: luckCycles,
                    currentYear: {
                        year: currentYear,
                        ganzhi: yearPillar.toString(),
                        analysis: yearAnalysis
                    }
                };
            }
            
            /* 辅助分析方法 */
            getStemRelation(dayStem, targetStem) {
                // 获取天干与日主的关系
                return dayStem.getRelation(targetStem);
            }
            
            getStemBranchRelation(dayStem, branch) {
                // 获取地支与日主的关系
                const mainStem = branch.getHideStems()[0]; // 取地支主气
                return this.getStemRelation(dayStem, mainStem);
            }
            
            checkSanhe(branches) {
                // 检查三合局
                const sanheGroups = [
                    ['申', '子', '辰'], // 水局
                    ['亥', '卯', '未'], // 木局
                    ['寅', '午', '戌'], // 火局
                    ['巳', '酉', '丑']  // 金局
                ];
                
                for (const group of sanheGroups) {
                    const found = group.filter(b => branches.some(p => p.toString() === b));
                    if (found.length >= 2) {
                        return {
                            type: '三合局',
                            elements: group,
                            found,
                            wuxing: this.getSanheWuxing(group),
                            description: this.getSanheDescription(group)
                        };
                    }
                }
                return null;
            }
            
            checkLiuhe(branches) {
                // 检查六合
                const liuhePairs = [
                    ['子', '丑'], ['寅', '亥'], ['卯', '戌'],
                    ['辰', '酉'], ['巳', '申'], ['午', '未']
                ];
                
                for (const pair of liuhePairs) {
                    if (branches.some(b => b.toString() === pair[0]) && 
                        branches.some(b => b.toString() === pair[1])) {
                        return {
                            type: '六合',
                            pair,
                            description: this.getLiuheDescription(pair)
                        };
                    }
                }
                return null;
            }
            
            checkWuhe(stems) {
                // 检查天干五合
                const wuhePairs = [
                    ['甲', '己'], ['乙', '庚'], ['丙', '辛'],
                    ['丁', '壬'], ['戊', '癸']
                ];
                
                for (const pair of wuhePairs) {
                    if (stems.some(s => s.toString() === pair[0]) && 
                        stems.some(s => s.toString() === pair[1])) {
                        return {
                            type: '天干五合',
                            pair,
                            description: this.getWuheDescription(pair)
                        };
                    }
                }
                return null;
            }
            
            /* 分析结果生成方法 */
            getStrengthAnalysis(result, dayStem) {
                const wuxing = dayStem.getWuXing();
                const wuxingNames = { '木': '木', '火': '火', '土': '土', '金': '金', '水': '水' };
                
                if (result === '身强') {
                    return `您的日主${wuxingNames[wuxing]}能量旺盛，属于身强格局。身强的人通常精力充沛，抗压能力强，能担财官，但要注意避免过于刚强或固执。适合从事需要魄力和决断力的工作。`;
                } else if (result === '身弱') {
                    return `您的日主${wuxingNames[wuxing]}能量偏弱，属于身弱格局。身弱的人通常性格温和，但容易疲劳或缺乏自信。需要加强自身能量，适合团队合作或借助他人力量发展。`;
                } else {
                    return `您的日主${wuxingNames[wuxing]}能量适中，属于中和格局。中和的人通常适应能力强，性格平衡，但要注意保持五行流通，避免极端。`;
                }
            }
            
            getTenGodsAnalysis(tenGodsMap, tenGodsInfo) {
                let analysis = '您的命局中';
                const presentGods = Object.entries(tenGodsMap)
                    .filter(([_, count]) => count > 0)
                    .map(([rel, _]) => tenGodsInfo[rel].name);
                
                if (presentGods.length > 0) {
                    analysis += presentGods.join('、') + '较多，';
                    
                    // 特殊十神组合分析
                    if (tenGodsMap['restOf'] && tenGodsMap['helpOf']) {
                        analysis += '七杀与正印同现，表示您能化解压力，将挑战转化为动力；';
                    }
                    
                    if (tenGodsMap['consumeBy'] && tenGodsMap['bornBy']) {
                        analysis += '正财与食神搭配，显示您有通过才华获得财富的能力；';
                    }
                    
                    if (tenGodsMap['same'] >= 2 && tenGodsMap['helpBy'] >= 2) {
                        analysis += '比肩劫财多现，提示您要注意人际关系和财务管理；';
                    }
                }
                
                analysis += '这些十神组合影响着您的性格和命运走向。';
                return analysis;
            }
            
            getWuxingAnalysis(wuxingMap) {
                const sorted = Object.entries(wuxingMap).sort((a, b) => b[1] - a[1]);
                const strongest = sorted[0];
                const weakest = sorted[sorted.length - 1];
                
                let analysis = `您的命局中${strongest[0]}元素最旺(${strongest[1].toFixed(1)})，${weakest[0]}元素最弱(${weakest[1].toFixed(1)})。`;
                
                // 五行失衡提示
                if (strongest[1] / weakest[1] > 5) {
                    analysis += '五行严重失衡，需要注意健康和生活调节；';
                } else if (strongest[1] / weakest[1] > 3) {
                    analysis += '五行明显失衡，某些方面需要加强；';
                }
                
                // 五行特性分析
                analysis += `${strongest[0]}旺代表${this.getWuxingTrait(strongest[0])}，而${weakest[0]}弱可能导致${this.getWuxingWeakness(weakest[0])}。`;
                
                return analysis;
            }
            
            getCombinationAnalysis(combinations) {
                if (combinations.length === 0) {
                    return '您的命局中没有明显的特殊组合，整体格局较为平稳。';
                }
                
                let analysis = '您的命局中有以下特殊组合：';
                combinations.forEach(comb => {
                    analysis += `${comb.type}(${comb.elements ? comb.elements.join('、') : comb.pair.join('、')})，${comb.description}；`;
                });
                
                analysis += '这些组合会对您的命运产生特定影响。';
                return analysis;
            }
            
            getUsefulGodsAnalysis(useful, avoid, strength) {
                let analysis = `根据${strength}的特点，`;
                analysis += `您的用神是${useful.join('、')}，可以增强命局平衡；`;
                analysis += `忌神是${avoid.join('、')}，过多会破坏平衡。`;
                
                analysis += '在生活中可以多接触用神五行相关的事物，如：';
                useful.forEach(wx => {
                    analysis += `${wx}属性的颜色、方位、行业等；`;
                });
                
                return analysis;
            }
            
            getLuckDescription(pillar, dayStem) {
                const stemRel = this.getStemRelation(dayStem, pillar.stem);
                const branchRel = this.getStemBranchRelation(dayStem, pillar.branch);
                
                let desc = '';
                if (['same', 'helpBy'].includes(stemRel)) {
                    desc += '竞争较多，';
                }
                if (['bornBy', 'bornOf'].includes(stemRel)) {
                    desc += '才华展现，';
                }
                if (['consumeBy', 'consumeOf'].includes(stemRel)) {
                    desc += '财运变化，';
                }
                if (['restBy', 'restOf'].includes(stemRel)) {
                    desc += '事业压力，';
                }
                
                return desc || '运势平稳，需把握机会';
            }
            
            getYearLuckAnalysis(yearPillar, dayStem) {
                const stemRel = this.getStemRelation(dayStem, yearPillar.stem);
                const branchRel = this.getStemBranchRelation(dayStem, yearPillar.branch);
                
                let analysis = '今年';
                if (['same', 'helpBy'].includes(stemRel)) {
                    analysis += '人际关系活跃，但要注意竞争；';
                }
                if (['bornBy', 'bornOf'].includes(stemRel)) {
                    analysis += '创造力强，适合学习发展；';
                }
                if (['consumeBy', 'consumeOf'].includes(stemRel)) {
                    analysis += '财运波动，需谨慎理财；';
                }
                if (['restBy', 'restOf'].includes(stemRel)) {
                    analysis += '事业有压力，也是晋升机会；';
                }
                
                return analysis || '整体运势平稳，宜稳扎稳打';
            }
            
            /* 其他辅助方法 */
            getSanheWuxing(group) {
                if (group.includes('申')) return '水';
                if (group.includes('亥')) return '木';
                if (group.includes('寅')) return '火';
                return '金';
            }
            
            getSanheDescription(group) {
                const wuxing = this.getSanheWuxing(group);
                return `增强${wuxing}的力量，带来${wuxing}属性的特质`;
            }
            
            getLiuheDescription(pair) {
                const combinations = {
                    '子丑': '化土，增强土元素',
                    '寅亥': '化木，增强木元素',
                    '卯戌': '化火，增强火元素',
                    '辰酉': '化金，增强金元素',
                    '巳申': '化水，增强水元素',
                    '午未': '化土，增强土元素'
                };
                return combinations[pair.join('')] || '产生特殊影响';
            }
            
            getWuheDescription(pair) {
                const combinations = {
                    '甲己': '化土，增强土元素',
                    '乙庚': '化金，增强金元素',
                    '丙辛': '化水，增强水元素',
                    '丁壬': '化木，增强木元素',
                    '戊癸': '化火，增强火元素'
                };
                return combinations[pair.join('')] || '产生特殊影响';
            }
            
            getWuxingTrait(wuxing) {
                const traits = {
                    '木': '有活力、成长力强',
                    '火': '热情、积极',
                    '土': '稳重、务实',
                    '金': '果断、坚毅',
                    '水': '智慧、灵活'
                };
                return traits[wuxing] || '';
            }
            
            getWuxingWeakness(wuxing) {
                const weaknesses = {
                    '木': '缺乏决断力',
                    '火': '缺乏热情',
                    '土': '缺乏稳定性',
                    '金': '缺乏果断',
                    '水': '缺乏灵活性'
                };
                return weaknesses[wuxing] || '';
            }
        }

        // 页面交互逻辑
        document.addEventListener('DOMContentLoaded', function() {
            const analyzer = new BaziAnalyzer();
            
            // 表单提交处理
            document.getElementById('bazi-form').addEventListener('submit', function(e) {
                e.preventDefault();
                
                const formData = {
                    birthDate: document.getElementById('birth-date').value,
                    birthHour: document.getElementById('birth-hour').value,
                    birthMinute: document.getElementById('birth-minute').value,
                    timezone: document.getElementById('timezone').value,
                    gender: document.querySelector('input[name="gender"]:checked').value
                };
                
                // 计算八字并分析
                const result = analyzer.calculateFromForm(formData);
                if (!result) {
                    alert('请输入有效的出生信息');
                    return;
                }
                
                // 更新八字排盘显示
                updateBaziDisplay(result.pillars);
                
                // 更新基本信息显示
                updateBasicInfo(result);
                
                // 更新分析结果
                updateAnalysisResults(result);
                
                // 显示结果区域
                document.getElementById('result-section').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('result-section').scrollIntoView({ behavior: 'smooth' });
                }, 100);
            });
            
            // 更新八字排盘显示
            function updateBaziDisplay(pillars) {
                // 年柱
                document.getElementById('year-stem').innerHTML = `${pillars.year.stem}<br><span class="ten-god">(${getTenGodName(pillars.day.stem, pillars.year.stem)})</span>`;
                document.getElementById('year-branch').innerHTML = `${pillars.year.branch}<br><span class="ten-god">(${getTenGodName(pillars.day.stem, pillars.year.branch.getHideStems()[0])})</span>`;
                document.getElementById('year-hidden-god').innerHTML = pillars.year.branch.getHideStems().map(s => `${s}(${getTenGodName(pillars.day.stem, s)})`).join('<br>');
                
                // 月柱
                document.getElementById('month-stem').innerHTML = `${pillars.month.stem}<br><span class="ten-god">(${getTenGodName(pillars.day.stem, pillars.month.stem)})</span>`;
                document.getElementById('month-branch').innerHTML = `${pillars.month.branch}<br><span class="ten-god">(${getTenGodName(pillars.day.stem, pillars.month.branch.getHideStems()[0])})</span>`;
                document.getElementById('month-hidden-god').innerHTML = pillars.month.branch.getHideStems().map(s => `${s}(${getTenGodName(pillars.day.stem, s)})`).join('<br>');
                
                // 日柱
                document.getElementById('day-stem').innerHTML = `${pillars.day.stem}<br><span class="ten-god">(日元)</span>`;
                document.getElementById('day-branch').innerHTML = `${pillars.day.branch}<br><span class="ten-god">(${getTenGodName(pillars.day.stem, pillars.day.branch.getHideStems()[0])})</span>`;
                document.getElementById('day-hidden-god').innerHTML = pillars.day.branch.getHideStems().map(s => `${s}(${getTenGodName(pillars.day.stem, s)})`).join('<br>');
                
                // 时柱
                document.getElementById('hour-stem').innerHTML = `${pillars.hour.stem}<br><span class="ten-god">(${getTenGodName(pillars.day.stem, pillars.hour.stem)})</span>`;
                document.getElementById('hour-branch').innerHTML = `${pillars.hour.branch}<br><span class="ten-god">(${getTenGodName(pillars.day.stem, pillars.hour.branch.getHideStems()[0])})</span>`;
                document.getElementById('hour-hidden-god').innerHTML = pillars.hour.branch.getHideStems().map(s => `${s}(${getTenGodName(pillars.day.stem, s)})`).join('<br>');
                
                // 空亡
                document.getElementById('year-void').textContent = pillars.year.getXunKong();
                document.getElementById('month-void').textContent = pillars.month.getXunKong();
                document.getElementById('day-void').textContent = pillars.day.getXunKong();
                document.getElementById('hour-void').textContent = pillars.hour.getXunKong();
                
                // 纳音
                document.getElementById('year-nayin').textContent = pillars.year.getNaYin();
                document.getElementById('month-nayin').textContent = pillars.month.getNaYin();
                document.getElementById('day-nayin').textContent = pillars.day.getNaYin();
                document.getElementById('hour-nayin').textContent = pillars.hour.getNaYin();
                
                // 设置五行颜色类
                setWuxingClass('year-stem', pillars.year.stem);
                setWuxingClass('month-stem', pillars.month.stem);
                setWuxingClass('day-stem', pillars.day.stem);
                setWuxingClass('hour-stem', pillars.hour.stem);
                
                setWuxingClass('year-branch', pillars.year.branch);
                setWuxingClass('month-branch', pillars.month.branch);
                setWuxingClass('day-branch', pillars.day.branch);
                setWuxingClass('hour-branch', pillars.hour.branch);
            }
            
            // 更新基本信息显示
            function updateBasicInfo(result) {
                const date = result.solarDate;
                document.getElementById('result-date').textContent = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
                document.getElementById('result-time').textContent = `${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
                document.getElementById('result-lunar').textContent = result.lunarDate.toString();
                document.getElementById('result-zodiac').textContent = result.lunarDate.getYearShengXiao();
                
                // 命宫身宫计算 (简化版)
                const hour = date.getHours();
                const month = date.getMonth() + 1;
                const minggong = ((hour + 1) % 12 + month - 1) % 12;
                const shengong = ((hour + 7) % 12 + month - 1) % 12;
                
                const branches = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
                document.getElementById('result-minggong').textContent = branches[minggong] + '宫';
                document.getElementById('result-shengong').textContent = branches[shengong] + '宫';
            }
            
            // 更新分析结果
            function updateAnalysisResults(result) {
                // 1. 身强身弱分析
                document.getElementById('strength-result').innerHTML = 
                    `根据您的八字分析，您的日主属于<strong>${result.strength.result}</strong>格局。`;
                
                // 2. 十神分析
                document.getElementById('ten-god-distribution').textContent = result.tenGods.analysis;
                
                // 3. 五行平衡分析
                const wuxingValues = [
                    result.wuxing.percent['木'] || 0,
                    result.wuxing.percent['火'] || 0,
                    result.wuxing.percent['土'] || 0,
                    result.wuxing.percent['金'] || 0,
                    result.wuxing.percent['水'] || 0
                ];
                
                drawWuxingChart(wuxingValues);
                
                // 更新五行柱状图
                const wuxingItems = ['木', '火', '土', '金', '水'];
                document.querySelectorAll('.wuxing-bar').forEach((bar, i) => {
                    bar.style.width = `${wuxingValues[i]}%`;
                });
                
                document.querySelectorAll('.wuxing-value').forEach((value, i) => {
                    value.textContent = `${wuxingValues[i]}% (${getWuxingStrength(wuxingValues[i])})`;
                });
                
                document.getElementById('wuxing-analysis').textContent = result.wuxing.analysis;
                
                // 4. 特殊组合分析
                document.getElementById('combinations-analysis').textContent = result.combinations.analysis;
                
                // 5. 用神忌神分析
                document.getElementById('useful-gods-analysis').textContent = result.usefulGods.analysis;
                
                // 6. 运势分析
                const luckTableBody = document.getElementById('luck-table-body');
                luckTableBody.innerHTML = '';
                
                result.luck.cycles.forEach((cycle, index) => {
                    const row = document.createElement('tr');
                    if (index === 1) row.classList.add('current-luck'); // 假设第二步大运是当前大运
                    
                    row.innerHTML = `
                        <td>${cycle.name}</td>
                        <td>${cycle.ageRange}</td>
                        <td>${cycle.ganzhi}</td>
                        <td>${cycle.description}</td>
                    `;
                    luckTableBody.appendChild(row);
                });
                
                document.getElementById('current-year-luck').textContent = 
                    `${result.luck.currentYear.year}年(${result.luck.currentYear.ganzhi})运势：${result.luck.currentYear.analysis}`;
            }
            
            // 辅助函数：获取十神名称
            function getTenGodName(dayStem, targetStem) {
                const relation = dayStem.getRelation(targetStem);
                const map = {
                    'same': '比肩',
                    'helpBy': '劫财',
                    'bornBy': '食神',
                    'bornOf': '伤官',
                    'consumeBy': '正财',
                    'consumeOf': '偏财',
                    'restBy': '正官',
                    'restOf': '七杀',
                    'helpOf': '正印',
                    'bornTo': '偏印'
                };
                return map[relation] || '';
            }
            
            // 辅助函数：设置五行颜色类
            function setWuxingClass(elementId, stemOrBranch) {
                const element = document.getElementById(elementId);
                const wuxing = stemOrBranch.getWuXing();
                element.className = `wuxing-${wuxing.toLowerCase()}`;
            }
            
            // 辅助函数：获取五行强弱描述
            function getWuxingStrength(value) {
                if (value >= 70) return '旺';
                if (value >= 40) return '平';
                return '弱';
            }
            
            // 五行雷达图绘制
            function drawWuxingChart(data) {
                const container = document.getElementById('wuxing-chart');
                container.innerHTML = '';
                
                const width = 300;
                const height = 300;
                const center = { x: width / 2, y: height / 2 };
                const radius = 120;
                const angles = [0, 72, 144, 216, 288]; // 五行的角度
                const labels = ['木', '火', '土', '金', '水'];
                const colors = ['#2e7d32', '#c62828', '#8d6e63', '#1565c0', '#0277bd'];
                
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                container.appendChild(svg);
                
                // 绘制五边形网格
                const gridPoints = angles.map((angle, i) => {
                    const radian = (angle - 90) * Math.PI / 180;
                    return {
                        x: center.x + radius * Math.cos(radian),
                        y: center.y + radius * Math.sin(radian)
                    };
                });
                
                // 绘制五边形
                const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                polygon.setAttribute('points', gridPoints.map(p => `${p.x},${p.y}`).join(' '));
                polygon.setAttribute('class', 'wuxing-polygon');
                polygon.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(polygon);
                
                // 绘制五行轴线
                angles.forEach((angle, i) => {
                    const radian = (angle - 90) * Math.PI / 180;
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute('x1', center.x);
                    line.setAttribute('y1', center.y);
                    line.setAttribute('x2', center.x + radius * Math.cos(radian));
                    line.setAttribute('y2', center.y + radius * Math.sin(radian));
                    line.setAttribute('stroke', '#ddd');
                    line.setAttribute('stroke-width', '1');
                    svg.appendChild(line);
                    
                    // 添加五行标签
                    const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    label.setAttribute('x', center.x + (radius + 30) * Math.cos(radian));
                    label.setAttribute('y', center.y + (radius + 30) * Math.sin(radian));
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('dominant-baseline', 'middle');
                    label.setAttribute('font-weight', 'bold');
                    label.setAttribute('fill', colors[i]);
                    label.textContent = labels[i];
                    svg.appendChild(label);
                });
                
                // 绘制数据多边形
                const dataPoints = angles.map((angle, i) => {
                    const value = data[i] / 100 * radius;
                    const radian = (angle - 90) * Math.PI / 180;
                    return {
                        x: center.x + value * Math.cos(radian),
                        y: center.y + value * Math.sin(radian)
                    };
                });
                
                const dataPolygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                dataPolygon.setAttribute('points', dataPoints.map(p => `${p.x},${p.y}`).join(' '));
                dataPolygon.setAttribute('class', 'wuxing-polygon');
                dataPolygon.setAttribute('fill', 'rgba(237, 28, 36, 0.3)');
                svg.appendChild(dataPolygon);
                
                // 绘制数据点
                dataPoints.forEach((point, i) => {
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute('cx', point.x);
                    circle.setAttribute('cy', point.y);
                    circle.setAttribute('r', 6);
                    circle.setAttribute('class', 'wuxing-point');
                    circle.setAttribute('fill', colors[i]);
                    svg.appendChild(circle);
                    
                    // 添加数值标签
                    const valueLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    valueLabel.setAttribute('x', point.x);
                    valueLabel.setAttribute('y', point.y - 15);
                    valueLabel.setAttribute('text-anchor', 'middle');
                    valueLabel.setAttribute('font-size', '12');
                    valueLabel.setAttribute('fill', colors[i]);
                    valueLabel.textContent = `${data[i]}%`;
                    svg.appendChild(valueLabel);
                });
            }
            
            // 选项卡切换
            const tabs = document.querySelectorAll('.analysis-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.analysis-content').forEach(c => c.classList.remove('active'));
                    
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(`${tabId}-content`).classList.add('active');
                });
            });
            
            // 打印功能
            document.getElementById('print-btn').addEventListener('click', function() {
                window.print();
            });
            
            // 保存功能
            document.getElementById('save-btn').addEventListener('click', function() {
                alert('保存功能将在后续版本中实现');
            });
        });
    </script>
</body>
</html>
